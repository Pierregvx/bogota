new EventSource("/esbuild").onmessage = () => location.reload();
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key2 of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to2, key2) && key2 !== except)
        __defProp(to2, key2, { get: () => from3[key2], enumerable: !(desc = __getOwnPropDesc(from3, key2)) || desc.enumerable });
  }
  return to2;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e5) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e6) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e5) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e6) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      args[i4 - 1] = arguments[i4];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener, once, off, removeListener, removeAllListeners, emit, performance2, performanceNow, startTime, process, defines;
var init_virtual_process_polyfill = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js"() {
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof window.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof window.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener = noop;
    once = noop;
    off = noop;
    removeListener = noop;
    removeAllListeners = noop;
    emit = noop;
    performance2 = window.performance || {};
    performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    process = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener,
      once,
      off,
      removeListener,
      removeAllListeners,
      emit,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    defines = {};
    Object.keys(defines).forEach((key2) => {
      const segs = key2.split(".");
      let target = process;
      for (let i4 = 0; i4 < segs.length; i4++) {
        const seg = segs[i4];
        if (i4 === segs.length - 1) {
          target[seg] = defines[key2];
        } else {
          target = target[seg] || (target[seg] = {});
        }
      }
    });
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup[i4] = code[i4];
    revLookup[code.charCodeAt(i4)] = i4;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function base64toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i4, j4, l5, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l5 = placeHolders > 0 ? len - 4 : len;
  var L4 = 0;
  for (i4 = 0, j4 = 0; i4 < l5; i4 += 4, j4 += 3) {
    tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
    arr[L4++] = tmp >> 16 & 255;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
    arr[L4++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i4 = start; i4 < end; i4 += 3) {
    tmp = (uint8[i4] << 16) + (uint8[i4 + 1] << 8) + uint8[i4 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function base64fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len2 = len - extraBytes; i4 < len2; i4 += maxChunkLength) {
    parts.push(
      encodeChunk(
        uint8,
        i4,
        i4 + maxChunkLength > len2 ? len2 : i4 + maxChunkLength
      )
    );
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill3, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill3, encoding) : createBuffer(that, size).fill(fill3);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i4 = 0; i4 < size; ++i4) {
      that[i4] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i4 = 0; i4 < length; i4 += 1) {
    that[i4] = array[i4] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes"
    );
  }
  return length | 0;
}
function internalIsBuffer(b3) {
  return !!(b3 != null && b3._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b3, n4, m5) {
  var i4 = b3[n4];
  b3[n4] = b3[m5];
  b3[m5] = i4;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(
          buffer,
          val,
          byteOffset
        );
      } else {
        return Uint8Array.prototype.lastIndexOf.call(
          buffer,
          val,
          byteOffset
        );
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i5) {
    if (indexSize === 1) {
      return buf[i5];
    } else {
      return buf.readUInt16BE(i5 * indexSize);
    }
  }
  var i4;
  if (dir) {
    var foundIndex = -1;
    for (i4 = byteOffset; i4 < arrLength; i4++) {
      if (read2(arr, i4) === read2(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i4 = byteOffset; i4 >= 0; i4--) {
      var found = true;
      for (var j4 = 0; j4 < valLength; j4++) {
        if (read2(arr, i4 + j4) !== read2(val, j4)) {
          found = false;
          break;
        }
      }
      if (found)
        return i4;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i4 = 0; i4 < length; ++i4) {
    var parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (isNaN(parsed))
      return i4;
    buf[offset + i4] = parsed;
  }
  return i4;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(
    utf8ToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(
    utf16leToBytes(string, buf.length - offset),
    buf,
    offset,
    length
  );
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64fromByteArray(buf);
  } else {
    return base64fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i4 = start;
  while (i4 < end) {
    var firstByte = buf[i4];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i4 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          fourthByte = buf[i4 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i4 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i4 = 0;
  while (i4 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i4 = start; i4 < end; ++i4) {
    ret += String.fromCharCode(buf[i4] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i4 = start; i4 < end; ++i4) {
    ret += String.fromCharCode(buf[i4]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i4 = start; i4 < end; ++i4) {
    out += toHex(buf[i4]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i4 = 0; i4 < bytes.length; i4 += 2) {
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i4 = 0, j4 = Math.min(buf.length - offset, 2); i4 < j4; ++i4) {
    buf[offset + i4] = (value & 255 << 8 * (littleEndian ? i4 : 1 - i4)) >>> (littleEndian ? i4 : 1 - i4) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i4 = 0, j4 = Math.min(buf.length - offset, 4); i4 < j4; ++i4) {
    buf[offset + i4] = value >>> (littleEndian ? i4 : 3 - i4) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      4,
      34028234663852886e22,
      -34028234663852886e22
    );
  }
  ieee754write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(
      buf,
      value,
      offset,
      8,
      17976931348623157e292,
      -17976931348623157e292
    );
  }
  ieee754write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n4) {
  if (n4 < 16)
    return "0" + n4.toString(16);
  return n4.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i4 = 0; i4 < length; ++i4) {
    codePoint = string.charCodeAt(i4);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    byteArray.push(str.charCodeAt(i4) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c4, hi, lo2;
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    if ((units -= 2) < 0)
      break;
    c4 = str.charCodeAt(i4);
    hi = c4 >> 8;
    lo2 = c4 % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i4 = 0; i4 < length; ++i4) {
    if (i4 + offset >= dst.length || i4 >= src.length)
      break;
    dst[i4 + offset] = src[i4];
  }
  return i4;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function ieee754read(buffer, offset, isLE, mLen, nBytes) {
  var e5, m5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE ? nBytes - 1 : 0;
  var d4 = isLE ? -1 : 1;
  var s4 = buffer[offset + i4];
  i4 += d4;
  e5 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e5 = e5 * 256 + buffer[offset + i4], i4 += d4, nBits -= 8) {
  }
  m5 = e5 & (1 << -nBits) - 1;
  e5 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m5 = m5 * 256 + buffer[offset + i4], i4 += d4, nBits -= 8) {
  }
  if (e5 === 0) {
    e5 = 1 - eBias;
  } else if (e5 === eMax) {
    return m5 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m5 = m5 + Math.pow(2, mLen);
    e5 = e5 - eBias;
  }
  return (s4 ? -1 : 1) * m5 * Math.pow(2, e5 - mLen);
}
function ieee754write(buffer, value, offset, isLE, mLen, nBytes) {
  var e5, m5, c4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE ? 0 : nBytes - 1;
  var d4 = isLE ? 1 : -1;
  var s4 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m5 = isNaN(value) ? 1 : 0;
    e5 = eMax;
  } else {
    e5 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c4 = Math.pow(2, -e5)) < 1) {
      e5--;
      c4 *= 2;
    }
    if (e5 + eBias >= 1) {
      value += rt / c4;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c4 >= 2) {
      e5++;
      c4 /= 2;
    }
    if (e5 + eBias >= eMax) {
      m5 = 0;
      e5 = eMax;
    } else if (e5 + eBias >= 1) {
      m5 = (value * c4 - 1) * Math.pow(2, mLen);
      e5 = e5 + eBias;
    } else {
      m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e5 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i4] = m5 & 255, i4 += d4, m5 /= 256, mLen -= 8) {
  }
  e5 = e5 << mLen | m5;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i4] = e5 & 255, i4 += d4, e5 /= 256, eLen -= 8) {
  }
  buffer[offset + i4 - d4] |= s4 * 128;
}
var lookup, revLookup, Arr, inited, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_Buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    Buffer2.TYPED_ARRAY_SUPPORT = window.TYPED_ARRAY_SUPPORT !== void 0 ? window.TYPED_ARRAY_SUPPORT : true;
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer2.kMaxLength = kMaxLength();
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      }
    }
    Buffer2.alloc = function(size, fill3, encoding) {
      return alloc(null, size, fill3, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a4, b3) {
      if (!internalIsBuffer(a4) || !internalIsBuffer(b3)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a4 === b3)
        return 0;
      var x5 = a4.length;
      var y5 = b3.length;
      for (var i4 = 0, len = Math.min(x5, y5); i4 < len; ++i4) {
        if (a4[i4] !== b3[i4]) {
          x5 = a4[i4];
          y5 = b3[i4];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i4;
      if (length === void 0) {
        length = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length += list[i4].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        var buf = list[i4];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 2) {
        swap(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 4) {
        swap(this, i4, i4 + 3);
        swap(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 8) {
        swap(this, i4, i4 + 7);
        swap(this, i4 + 1, i4 + 6);
        swap(this, i4 + 2, i4 + 5);
        swap(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b3) {
      if (!internalIsBuffer(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3)
        return true;
      return Buffer2.compare(this, b3) === 0;
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x5 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x5, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x5 = thisCopy[i4];
          y5 = targetCopy[i4];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i4 = 0; i4 < sliceLen; ++i4) {
          newBuf[i4] = this[i4 + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset + i4] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset + i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i4 = byteLength3;
      var mul = 1;
      var val = this[offset + --i4];
      while (i4 > 0 && (mul *= 256)) {
        val += this[offset + --i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i4 = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        this[offset + i4] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i4 = byteLength3 - 1;
      var mul = 1;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        this[offset + i4] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i4 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i4 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i4;
      if (this === target && start < targetStart && targetStart < end) {
        for (i4 = len - 1; i4 >= 0; --i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i4 = 0; i4 < len; ++i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js
var init_buffer = __esm({
  "node_modules/@esbuild-plugins/node-globals-polyfill/_buffer.js"() {
    init_Buffer();
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format3) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format3, args);
            }
          }
        }
        function error2(format3) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format3, args);
            }
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props2, context2, updater) {
          this.props = props2;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props2, context2, updater) {
          this.props = props2;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a4) {
          return isArrayImpl(a4);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type2;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type2;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x5) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config3) {
          {
            if (hasOwnProperty3.call(config3, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.ref !== void 0;
        }
        function hasValidKey(config3) {
          {
            if (hasOwnProperty3.call(config3, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.key !== void 0;
        }
        function defineKeyPropWarningGetter(props2, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props2, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props2, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props2, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config3) {
          {
            if (typeof config3.ref === "string" && ReactCurrentOwner.current && config3.__self && ReactCurrentOwner.current.stateNode !== config3.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config3.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type2, key2, ref, self2, source, owner, props2) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key: key2,
            ref,
            props: props2,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement3(type2, config3, children) {
          var propName;
          var props2 = {};
          var key2 = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref = config3.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config3);
              }
            }
            if (hasValidKey(config3)) {
              {
                checkKeyStringCoercion(config3.key);
              }
              key2 = "" + config3.key;
            }
            self2 = config3.__self === void 0 ? null : config3.__self;
            source = config3.__source === void 0 ? null : config3.__source;
            for (propName in config3) {
              if (hasOwnProperty3.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props2[propName] = config3[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props2.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i4 = 0; i4 < childrenLength; i4++) {
              childArray[i4] = arguments[i4 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props2.children = childArray;
          }
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps) {
              if (props2[propName] === void 0) {
                props2[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key2 || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key2) {
                defineKeyPropWarningGetter(props2, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props2, displayName);
              }
            }
          }
          return ReactElement(type2, key2, ref, self2, source, ReactCurrentOwner.current, props2);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config3, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props2 = assign({}, element.props);
          var key2 = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref = config3.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config3)) {
              {
                checkKeyStringCoercion(config3.key);
              }
              key2 = "" + config3.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config3) {
              if (hasOwnProperty3.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config3[propName] === void 0 && defaultProps !== void 0) {
                  props2[propName] = defaultProps[propName];
                } else {
                  props2[propName] = config3[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props2.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i4 = 0; i4 < childrenLength; i4++) {
              childArray[i4] = arguments[i4 + 2];
            }
            props2.children = childArray;
          }
          return ReactElement(element.type, key2, ref, self2, source, owner, props2);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key2) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key2.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type2 = typeof children;
          if (type2 === "undefined" || type2 === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type2) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray4(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c4) {
                return c4;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray4(children)) {
            for (var i4 = 0; i4 < children.length; i4++) {
              child = children[i4];
              nextName = nextNamePrefix + getElementKey(child, i4);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type2 === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context2) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context2, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n4 = 0;
          mapChildren(children, function() {
            n4++;
          });
          return n4;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext3(defaultValue) {
          var context2 = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          context2.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context2
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context2
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context2.Provider;
                },
                set: function(_Provider) {
                  context2.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context2._currentValue;
                },
                set: function(_currentValue) {
                  context2._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context2._currentValue2;
                },
                set: function(_currentValue2) {
                  context2._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context2._threadCount;
                },
                set: function(_threadCount) {
                  context2._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context2.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context2.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context2.Consumer = Consumer;
          }
          {
            context2._currentRenderer = null;
            context2._currentRenderer2 = null;
          }
          return context2;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error3) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error3;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type2, compare6) {
          {
            if (!isValidElementType(type2)) {
              error2("memo: The first argument must be a component. Instead received: %s", type2 === null ? "null" : typeof type2);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type2,
            compare: compare6 === void 0 ? null : compare6
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type2.name && !type2.displayName) {
                  type2.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext2(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init3) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init3);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props2, {
                  value: prevLog
                }),
                info: assign({}, props2, {
                  value: prevInfo
                }),
                warn: assign({}, props2, {
                  value: prevWarn
                }),
                error: assign({}, props2, {
                  value: prevError
                }),
                group: assign({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x5) {
                var match = x5.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x5) {
                  control = x5;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x5) {
                  control = x5;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x5) {
                control = x5;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                c4--;
              }
              for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                if (sampleLines[s4] !== controlLines[c4]) {
                  if (s4 !== 1 || c4 !== 1) {
                    do {
                      s4--;
                      c4--;
                      if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x5) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray4(node)) {
            for (var i4 = 0; i4 < node.length; i4++) {
              var child = node[i4];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type2);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i4 = 0; i4 < keys2.length; i4++) {
              var key2 = keys2[i4];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type2, props2, children) {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props2);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray4(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            {
              error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement3.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i4 = 2; i4 < arguments.length; i4++) {
              validateChildKeys(arguments[i4], type2);
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type2) {
          var validatedFactory = createElementWithValidation.bind(null, type2);
          validatedFactory.type = type2;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type2
                });
                return type2;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props2, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i4 = 2; i4 < arguments.length; i4++) {
            validateChildKeys(arguments[i4], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue3 = ReactCurrentActQueue.current;
                if (queue3 !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue3);
                }
              }
            } catch (error3) {
              popActScope(prevActScopeDepth);
              throw error3;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error3) {
                    popActScope(prevActScopeDepth);
                    reject(error3);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue3 = ReactCurrentActQueue.current;
            if (queue3 !== null) {
              try {
                flushActQueue(queue3);
                enqueueTask(function() {
                  if (queue3.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error3) {
                reject(error3);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue3) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i4 = 0;
              try {
                for (; i4 < queue3.length; i4++) {
                  var callback = queue3[i4];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue3.length = 0;
              } catch (error3) {
                queue3 = queue3.slice(i4 + 1);
                throw error3;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext3;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext2;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect2;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo2;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i4) {
          var index = i4;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare6(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i4) {
          var index = i4;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare6(left, node) < 0) {
              if (rightIndex < length && compare6(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare6(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare6(a4, b3) {
          var diff = a4.sortIndex - b3.sortIndex;
          return diff !== 0 ? diff : a4.id - b3.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms2) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime4;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime4 = currentTime + delay;
            } else {
              startTime4 = currentTime;
            }
          } else {
            startTime4 = currentTime;
          }
          var timeout2;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout2 = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout2 = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout2 = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime4 + timeout2;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime4,
            expirationTime,
            sortIndex: -1
          };
          if (startTime4 > currentTime) {
            newTask.sortIndex = startTime4;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime4 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime3 = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime3;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime3 = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms2) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms2);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React8 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn(format3) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format3, args);
            }
          }
        }
        function error2(format3) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format3, args);
            }
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment4 = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = false;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i4 = 0; i4 < dependencies.length; i4++) {
            allNativeEvents.add(dependencies[i4]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            name,
            null,
            false,
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            name,
            null,
            false,
            false
          );
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            name,
            null,
            false,
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            false,
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            true,
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node, name, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value = node.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name)) {
              return;
            }
            if (!node.hasAttribute(name)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node.getAttribute(name);
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node, name, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name);
          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
              var _attributeName = name;
              if (value === null) {
                node.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name);
                }
                node.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type2 = propertyInfo.type;
              node[propertyName] = type2 === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props2, {
                  value: prevLog
                }),
                info: assign({}, props2, {
                  value: prevInfo
                }),
                warn: assign({}, props2, {
                  value: prevWarn
                }),
                error: assign({}, props2, {
                  value: prevError
                }),
                group: assign({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x5) {
                var match = x5.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x5) {
                  control = x5;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x5) {
                  control = x5;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x5) {
                control = x5;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                c4--;
              }
              for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                if (sampleLines[s4] !== controlLines[c4]) {
                  if (s4 !== 1 || c4 !== 1) {
                    do {
                      s4--;
                      c4--;
                      if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x5) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x5) {
            return "\nError generating stack: " + x5.message + "\n" + x5.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type2;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type2;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x5) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type2 = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context2 = type2;
              return getContextName$1(context2) + ".Consumer";
            case ContextProvider:
              var provider2 = type2;
              return getContextName$1(provider2._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type2, type2.render, "ForwardRef");
            case Fragment4:
              return "Fragment";
            case HostComponent:
              return type2;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type2);
            case Mode:
              if (type2 === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type2 === "function") {
                return type2.displayName || type2.name || null;
              }
              if (typeof type2 === "string") {
                return type2;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString4(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props2) {
          {
            if (!(hasReadOnlyValue[props2.type] || props2.onChange || props2.onInput || props2.readOnly || props2.disabled || props2.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props2.onChange || props2.readOnly || props2.disabled || props2.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type2 = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type2 === "checkbox" || type2 === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value = "";
          if (!node) {
            return value;
          }
          if (isCheckable(node)) {
            value = node.checked ? "true" : "false";
          } else {
            value = node.value;
          }
          return value;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node[valueField]);
          }
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get4 = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get4.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set2.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e5) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props2) {
          var usesChecked = props2.type === "checkbox" || props2.type === "radio";
          return usesChecked ? props2.checked != null : props2.value != null;
        }
        function getHostProps(element, props2) {
          var node = element;
          var checked3 = props2.checked;
          var hostProps = assign({}, props2, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked3 != null ? checked3 : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props2) {
          {
            checkControlledValueProps("input", props2);
            if (props2.checked !== void 0 && props2.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props2.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props2.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props2.defaultValue == null ? "" : props2.defaultValue;
          node._wrapperState = {
            initialChecked: props2.checked != null ? props2.checked : props2.defaultChecked,
            initialValue: getToStringValue(props2.value != null ? props2.value : defaultValue),
            controlled: isControlled(props2)
          };
        }
        function updateChecked(element, props2) {
          var node = element;
          var checked3 = props2.checked;
          if (checked3 != null) {
            setValueForProperty(node, "checked", checked3, false);
          }
        }
        function updateWrapper(element, props2) {
          var node = element;
          {
            var controlled = isControlled(props2);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props2);
          var value = getToStringValue(props2.value);
          var type2 = props2.type;
          if (value != null) {
            if (type2 === "number") {
              if (value === 0 && node.value === "" || node.value != value) {
                node.value = toString4(value);
              }
            } else if (node.value !== toString4(value)) {
              node.value = toString4(value);
            }
          } else if (type2 === "submit" || type2 === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props2.hasOwnProperty("value")) {
              setDefaultValue(node, props2.type, value);
            } else if (props2.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props2.type, getToStringValue(props2.defaultValue));
            }
          }
          {
            if (props2.checked == null && props2.defaultChecked != null) {
              node.defaultChecked = !!props2.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props2, isHydrating2) {
          var node = element;
          if (props2.hasOwnProperty("value") || props2.hasOwnProperty("defaultValue")) {
            var type2 = props2.type;
            var isButton = type2 === "submit" || type2 === "reset";
            if (isButton && (props2.value === void 0 || props2.value === null)) {
              return;
            }
            var initialValue = toString4(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name = node.name;
          if (name !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name !== "") {
            node.name = name;
          }
        }
        function restoreControlledState(element, props2) {
          var node = element;
          updateWrapper(node, props2);
          updateNamedCousins(node, props2);
        }
        function updateNamedCousins(rootNode, props2) {
          var name = props2.name;
          if (props2.type === "radio" && name != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
            for (var i4 = 0; i4 < group.length; i4++) {
              var otherNode = group[i4];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type2, value) {
          if (type2 !== "number" || getActiveElement(node.ownerDocument) !== node) {
            if (value == null) {
              node.defaultValue = toString4(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString4(value)) {
              node.defaultValue = toString4(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props2) {
          {
            if (props2.value == null) {
              if (typeof props2.children === "object" && props2.children !== null) {
                React8.Children.forEach(props2.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props2.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props2.selected != null && !didWarnSelectedSetOnOption) {
              error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props2) {
          if (props2.value != null) {
            element.setAttribute("value", toString4(getToStringValue(props2.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a4) {
          return isArrayImpl(a4);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props2) {
          {
            checkControlledValueProps("select", props2);
            for (var i4 = 0; i4 < valuePropNames.length; i4++) {
              var propName = valuePropNames[i4];
              if (props2[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray4(props2[propName]);
              if (props2.multiple && !propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props2.multiple && propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options2 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i4 = 0; i4 < selectedValues.length; i4++) {
              selectedValue["$" + selectedValues[i4]] = true;
            }
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i2].value);
              if (options2[_i2].selected !== selected) {
                options2[_i2].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString4(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i22 = 0; _i22 < options2.length; _i22++) {
              if (options2[_i22].value === _selectedValue) {
                options2[_i22].selected = true;
                if (setDefaultSelected) {
                  options2[_i22].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i22].disabled) {
                defaultSelected = options2[_i22];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props2) {
          return assign({}, props2, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props2) {
          var node = element;
          {
            checkSelectPropTypes(props2);
          }
          node._wrapperState = {
            wasMultiple: !!props2.multiple
          };
          {
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props2) {
          var node = element;
          node.multiple = !!props2.multiple;
          var value = props2.value;
          if (value != null) {
            updateOptions(node, !!props2.multiple, value, false);
          } else if (props2.defaultValue != null) {
            updateOptions(node, !!props2.multiple, props2.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props2) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props2.multiple;
          var value = props2.value;
          if (value != null) {
            updateOptions(node, !!props2.multiple, value, false);
          } else if (wasMultiple !== !!props2.multiple) {
            if (props2.defaultValue != null) {
              updateOptions(node, !!props2.multiple, props2.defaultValue, true);
            } else {
              updateOptions(node, !!props2.multiple, props2.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props2) {
          var node = element;
          var value = props2.value;
          if (value != null) {
            updateOptions(node, !!props2.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props2) {
          var node = element;
          if (props2.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign({}, props2, {
            value: void 0,
            defaultValue: void 0,
            children: toString4(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props2) {
          var node = element;
          {
            checkControlledValueProps("textarea", props2);
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props2.value;
          if (initialValue == null) {
            var children = props2.children, defaultValue = props2.defaultValue;
            if (children != null) {
              {
                error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray4(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props2) {
          var node = element;
          var value = getToStringValue(props2.value);
          var defaultValue = getToStringValue(props2.defaultValue);
          if (value != null) {
            var newValue = toString4(value);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props2.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString4(defaultValue);
          }
        }
        function postMountWrapper$3(element, props2) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props2) {
          updateWrapper$1(element, props2);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type2) {
          switch (type2) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type2) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type2);
          }
          if (parentNamespace === SVG_NAMESPACE && type2 === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
          if (node.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key2) {
          return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_5, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name,
              camelize(name.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter2 = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter2 + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter2 = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key2 in styles) {
            var longhands = shorthandToLonghand[key2] || [key2];
            for (var i4 = 0; i4 < longhands.length; i4++) {
              expanded[longhands[i4]] = key2;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key2 in expandedUpdates) {
              var originalKey = expandedUpdates[key2];
              var correctOriginalKey = expandedStyles[key2];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props2) {
          if (!props2) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props2.children != null || props2.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props2.dangerouslySetInnerHTML != null) {
            if (props2.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props2.dangerouslySetInnerHTML !== "object" || !(HTML in props2.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props2.suppressContentEditableWarning && props2.contentEditable && props2.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props2.style != null && typeof props2.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props2) {
          if (tagName.indexOf("-") === -1) {
            return typeof props2.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty3.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props2) {
          {
            var invalidProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty(type2, key2);
              if (!isValid) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props2) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnInvalidARIAProps(type2, props2);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props2) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props2 != null && props2.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props2.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty3.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props2, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty$1(type2, key2, props2[key2], eventRegistry);
              if (!isValid) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props2, eventRegistry) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnUnknownProperties(type2, props2, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i4 = 0; i4 < queuedTargets.length; i4++) {
              restoreStateOfTarget(queuedTargets[i4]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn2, bookkeeping) {
          return fn2(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn2, a4, b3) {
          if (isInsideEventHandler) {
            return fn2(a4, b3);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn2, a4, b3);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name, type2, props2) {
          switch (name) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props2.disabled && isInteractive(type2));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props2 = getFiberCurrentPropsFromNode(stateNode);
          if (props2 === null) {
            return null;
          }
          var listener = props2[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props2)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e5) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name, func, context2, a4, b3, c4, d4, e5, f5) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context2, funcArgs);
          } catch (error3) {
            this.onError(error3);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context2, a4, b3, c4, d4, e5, f5) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context2, funcArgs);
                didError = false;
              }
              var error3;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error3 = event.error;
                didSetError = true;
                if (error3 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error3 != null && typeof error3 === "object") {
                    try {
                      error3._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name ? name : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error3);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error3) {
            hasError = true;
            caughtError = error3;
          }
        };
        function invokeGuardedCallback(name, func, context2, a4, b3, c4, d4, e5, f5) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name, func, context2, a4, b3, c4, d4, e5, f5) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error3 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error3;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error3 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error3;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get3(key2) {
          return key2._reactInternals;
        }
        function has(key2) {
          return key2._reactInternals !== void 0;
        }
        function set(key2, value) {
          key2._reactInternals = value;
        }
        var NoFlags = 0;
        var PerformedWork = 1;
        var Placement = 2;
        var Update = 4;
        var ChildDeletion = 16;
        var ContentReset = 32;
        var Callback = 64;
        var DidCapture = 128;
        var ForceClientRender = 256;
        var Ref = 512;
        var Snapshot = 1024;
        var Passive = 2048;
        var Hydrating = 4096;
        var Visibility = 8192;
        var StoreConsistency = 16384;
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = 32767;
        var Incomplete = 32768;
        var ShouldCapture = 65536;
        var ForceUpdateForLegacySuspense = 131072;
        var Forked = 1048576;
        var RefStatic = 2097152;
        var LayoutStatic = 4194304;
        var PassiveStatic = 8388608;
        var MountLayoutDev = 16777216;
        var MountPassiveDev = 33554432;
        var BeforeMutationMask = Update | Snapshot | 0;
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get3(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a4 = fiber;
          var b3 = alternate;
          while (true) {
            var parentA = a4.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a4 = b3 = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a4) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b3) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a4.return !== b3.return) {
              a4 = parentA;
              b3 = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a4) {
                  didFindChild = true;
                  a4 = parentA;
                  b3 = parentB;
                  break;
                }
                if (_child === b3) {
                  didFindChild = true;
                  b3 = parentA;
                  a4 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a4) {
                    didFindChild = true;
                    a4 = parentB;
                    b3 = parentA;
                    break;
                  }
                  if (_child === b3) {
                    didFindChild = true;
                    b3 = parentB;
                    a4 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a4.alternate !== b3) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a4.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a4.stateNode.current === a4) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            var match = findCurrentHostFiberImpl(child);
            if (match !== null) {
              return match;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match !== null) {
                return match;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error2("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root3, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root3, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root3, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root3.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root3) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root3);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map3 = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index2 = 0; index2 < TotalLanes; index2++) {
              var label = getLabelForLane(lane);
              map3.set(lane, label);
              lane *= 2;
            }
            return map3;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = 0;
        var ConcurrentMode = 1;
        var ProfileMode = 2;
        var StrictLegacyMode = 8;
        var StrictEffectsMode = 16;
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log2 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x5) {
          var asUint = x5 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log2(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = 0;
        var NoLane = 0;
        var SyncLane = 1;
        var InputContinuousHydrationLane = 2;
        var InputContinuousLane = 4;
        var DefaultHydrationLane = 8;
        var DefaultLane = 16;
        var TransitionHydrationLane = 32;
        var TransitionLanes = 4194240;
        var TransitionLane1 = 64;
        var TransitionLane2 = 128;
        var TransitionLane3 = 256;
        var TransitionLane4 = 512;
        var TransitionLane5 = 1024;
        var TransitionLane6 = 2048;
        var TransitionLane7 = 4096;
        var TransitionLane8 = 8192;
        var TransitionLane9 = 16384;
        var TransitionLane10 = 32768;
        var TransitionLane11 = 65536;
        var TransitionLane12 = 131072;
        var TransitionLane13 = 262144;
        var TransitionLane14 = 524288;
        var TransitionLane15 = 1048576;
        var TransitionLane16 = 2097152;
        var RetryLanes = 130023424;
        var RetryLane1 = 4194304;
        var RetryLane2 = 8388608;
        var RetryLane3 = 16777216;
        var RetryLane4 = 33554432;
        var RetryLane5 = 67108864;
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = 134217728;
        var NonIdleLanes = 268435455;
        var IdleHydrationLane = 268435456;
        var IdleLane = 536870912;
        var OffscreenLane = 1073741824;
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root3, wipLanes) {
          var pendingLanes = root3.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root3.suspendedLanes;
          var pingedLanes = root3.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root3.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root3.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              nextLanes |= entanglements[index2];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root3, lanes) {
          var eventTimes = root3.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var eventTime = eventTimes[index2];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root3, currentTime) {
          var pendingLanes = root3.pendingLanes;
          var suspendedLanes = root3.suspendedLanes;
          var pingedLanes = root3.pingedLanes;
          var expirationTimes = root3.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var expirationTime = expirationTimes[index2];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index2] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root3.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root3) {
          return getHighestPriorityLanes(root3.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root3) {
          var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root3, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root3, lanes) {
          return (lanes & root3.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a4, b3) {
          return (a4 & b3) !== NoLanes;
        }
        function isSubsetOfLanes(set2, subset) {
          return (set2 & subset) === subset;
        }
        function mergeLanes(a4, b3) {
          return a4 | b3;
        }
        function removeLanes(set2, subset) {
          return set2 & ~subset;
        }
        function intersectLanes(a4, b3) {
          return a4 & b3;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a4, b3) {
          return a4 !== NoLane && a4 < b3 ? a4 : b3;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i4 = 0; i4 < TotalLanes; i4++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root3, updateLane, eventTime) {
          root3.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
          }
          var eventTimes = root3.eventTimes;
          var index2 = laneToIndex(updateLane);
          eventTimes[index2] = eventTime;
        }
        function markRootSuspended(root3, suspendedLanes) {
          root3.suspendedLanes |= suspendedLanes;
          root3.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root3.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root3, pingedLanes, eventTime) {
          root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root3, remainingLanes) {
          var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
          root3.pendingLanes = remainingLanes;
          root3.suspendedLanes = NoLanes;
          root3.pingedLanes = NoLanes;
          root3.expiredLanes &= remainingLanes;
          root3.mutableReadLanes &= remainingLanes;
          root3.entangledLanes &= remainingLanes;
          var entanglements = root3.entanglements;
          var eventTimes = root3.eventTimes;
          var expirationTimes = root3.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            entanglements[index2] = NoLanes;
            eventTimes[index2] = NoTimestamp;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root3, entangledLanes) {
          var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
          var entanglements = root3.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            if (lane & entangledLanes | entanglements[index2] & entangledLanes) {
              entanglements[index2] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root3, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root3, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root3, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
          var memoizedUpdaters = root3.memoizedUpdaters;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root3, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn2) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn2();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a4, b3) {
          return a4 !== 0 && a4 < b3 ? a4 : b3;
        }
        function lowerEventPriority(a4, b3) {
          return a4 === 0 || a4 > b3 ? a4 : b3;
        }
        function isHigherEventPriority(a4, b3) {
          return a4 !== 0 && a4 < b3;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root3) {
          var currentState = root3.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn2) {
          _attemptSynchronousHydration = fn2;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn2) {
          attemptContinuousHydration = fn2;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn2) {
          attemptHydrationAtCurrentPriority = fn2;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn2) {
          getCurrentUpdatePriority$1 = fn2;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn2) {
          attemptHydrationAtPriority = fn2;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root3 = nearestMounted.stateNode;
                if (isRootDehydrated(root3)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i4 = 0;
          for (; i4 < queuedExplicitHydrationTargets.length; i4++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i4].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i4, 0, queuedTarget);
          if (i4 === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map3) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map3.delete(key2);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i4 = 1; i4 < queuedDiscreteEvents.length; i4++) {
              var queuedEvent = queuedDiscreteEvents[i4];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i2 = 0; _i2 < queuedExplicitHydrationTargets.length; _i2++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i2];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root3 = nearestMounted.stateNode;
                if (isRootDehydrated(root3)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root2 = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root2 = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root2 = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start = 0; start < startLength; start++) {
            if (startValue[start] !== endValue[start]) {
              break;
            }
          }
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root2) {
            return root2.value;
          }
          return root2.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize = Interface[_propName];
              if (normalize) {
                this[_propName] = normalize(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key2 = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key2 !== "Unidentified") {
              return key2;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners3 = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners3.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners: listeners3
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners3 = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners3.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners: listeners3
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners3 = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners3.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners: listeners3
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state = node._wrapperState;
          if (!state || !state.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from3;
          var to2;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from3 = targetInst;
            to2 = _related ? getClosestInstanceFromNode(_related) : null;
            if (to2 !== null) {
              var nearestMounted = getNearestMountedFiber(to2);
              if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                to2 = null;
              }
            }
          } else {
            from3 = null;
            to2 = targetInst;
          }
          if (from3 === to2) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from3 == null ? win : getNodeFromInstance(from3);
          var toNode = to2 == null ? win : getNodeFromInstance(to2);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from3, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from3, to2);
        }
        function is(x5, y5) {
          return x5 === y5 && (x5 !== 0 || 1 / x5 === 1 / y5) || x5 !== x5 && y5 !== y5;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i4 = 0; i4 < keysA.length; i4++) {
            var currentKey = keysA[i4];
            if (!hasOwnProperty3.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root3, offset) {
          var node = getLeafNode(root3);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                  node,
                  offset: offset - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e5) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end = length;
                }
                if ((next = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
          if (start === -1 || end === -1) {
            return null;
          }
          return {
            start,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc = node.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node.textContent.length;
          var start = Math.min(offsets.start, length);
          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i4 = 0; i4 < ancestors.length; i4++) {
              var info = ancestors[i4];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners3 = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners3.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners: listeners3
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i4 = 0; i4 < simpleEventPluginEvents.length; i4++) {
            var eventName = simpleEventPluginEvents[i4];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type2 = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type2, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i4 = dispatchListeners.length - 1; i4 >= 0; i4--) {
              var _dispatchListeners$i = dispatchListeners[i4], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i2 = 0; _i2 < dispatchListeners.length; _i2++) {
              var _dispatchListeners$_i = dispatchListeners[_i2], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i4 = 0; i4 < dispatchQueue.length; i4++) {
            var _dispatchQueue$i = dispatchQueue[i4], event = _dispatchQueue$i.event, listeners3 = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners3, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop:
                while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container2 = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container2, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container2 !== null) {
                      var parentNode = getClosestInstanceFromNode(container2);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container2 = container2.parentNode;
                    }
                  }
                  node = node.return;
                }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners3 = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners3.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners3;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners3 = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners3.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners3.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners3;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners3 = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners3.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners3.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners3.length !== 0) {
            dispatchQueue.push({
              event,
              listeners: listeners3
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from3, to2) {
          var common = from3 && to2 ? getLowestCommonAncestor(from3, to2) : null;
          if (from3 !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from3, common, false);
          }
          if (to2 !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            dialog: true,
            webview: true
          };
          validatePropertiesInDevelopment = function(type2, props2) {
            validateProperties(type2, props2);
            validateProperties$1(type2, props2);
            validateProperties$2(type2, props2, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name) {
              names.push(name);
            });
            error2("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop3() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop3;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i4 = 0; i4 < updatePayload.length; i4 += 2) {
            var propKey = updatePayload[i4];
            var propValue = updatePayload[i4 + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement3(type2, props2, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type2);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type2, props2);
              if (!isCustomComponentTag && type2 !== type2.toLowerCase()) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2);
              }
            }
            if (type2 === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props2.is === "string") {
              domElement = ownerDocument.createElement(type2, {
                is: props2.is
              });
            } else {
              domElement = ownerDocument.createElement(type2);
              if (type2 === "select") {
                var node = domElement;
                if (props2.multiple) {
                  node.multiple = true;
                } else if (props2.size) {
                  node.size = props2.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type2);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty3.call(warnedUnknownTags, type2)) {
                warnedUnknownTags[type2] = true;
                error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type2);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props2;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props2 = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props2 = rawProps;
              break;
            case "video":
            case "audio":
              for (var i4 = 0; i4 < mediaEventTypes.length; i4++) {
                listenToNonDelegatedEvent(mediaEventTypes[i4], domElement);
              }
              props2 = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props2 = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props2 = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props2 = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props2 = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props2 = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props2 = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props2 = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props2 = rawProps;
          }
          assertValidProps(tag, props2);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props2, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props2.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i4 = 0; i4 < mediaEventTypes.length; i4++) {
                listenToNonDelegatedEvent(mediaEventTypes[i4], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i2 = 0; _i2 < attributes.length; _i2++) {
              var name = attributes[_i2].name.toLowerCase();
              switch (name) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i2].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props2) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text) {
          {
            if (text === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props2) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props2);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props2);
              return;
            case "select":
              restoreControlledState$1(domElement, props2);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error2("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type2;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type2 = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root3 = rootContainerInstance.documentElement;
              namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container2.namespaceURI || null;
              type2 = container2.tagName;
              namespace = getChildNamespace(ownNamespace, type2);
              break;
            }
          }
          {
            var validatedTag = type2.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type2, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type2);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type2);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type2, props2, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type2, null, hostContextDev.ancestorInfo);
            if (typeof props2.children === "string" || typeof props2.children === "number") {
              var string = "" + props2.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement3(type2, props2, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props2);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type2, props2, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type2, props2, rootContainerInstance);
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props2.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type2, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type2, oldProps, newProps);
        }
        function shouldSetTextContent(type2, props2) {
          return type2 === "textarea" || type2 === "noscript" || typeof props2.children === "string" || typeof props2.children === "number" || typeof props2.dangerouslySetInnerHTML === "object" && props2.dangerouslySetInnerHTML !== null && props2.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error3) {
          setTimeout(function() {
            throw error3;
          });
        }
        function commitMount(domElement, type2, newProps, internalInstanceHandle) {
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type2, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type2, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container2, child) {
          var parentNode;
          if (container2.nodeType === COMMENT_NODE) {
            parentNode = container2.parentNode;
            parentNode.insertBefore(child, container2);
          } else {
            parentNode = container2;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container2._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container2, child, beforeChild) {
          if (container2.nodeType === COMMENT_NODE) {
            container2.parentNode.insertBefore(child, beforeChild);
          } else {
            container2.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container2, child) {
          if (container2.nodeType === COMMENT_NODE) {
            container2.parentNode.removeChild(child);
          } else {
            container2.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
          if (container2.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container2.parentNode, suspenseInstance);
          } else if (container2.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container2, suspenseInstance);
          }
          retryIfBlockedOn(container2);
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props2) {
          instance = instance;
          var styleProp = props2[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainer(container2) {
          if (container2.nodeType === ELEMENT_NODE) {
            container2.textContent = "";
          } else if (container2.nodeType === DOCUMENT_NODE) {
            if (container2.documentElement) {
              container2.removeChild(container2.documentElement);
            }
          }
        }
        function canHydrateInstance(instance, type2, props2) {
          if (instance.nodeType !== ELEMENT_NODE || type2.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text) {
          if (text === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function canHydrateSuspenseInstance(instance) {
          if (instance.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
          var dataset = instance.nextSibling && instance.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          instance._reactRetry = callback;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type2, props2, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props2);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance, type2, props2, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container2) {
          retryIfBlockedOn(container2);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentNode, instance);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type2, props2) {
          {
            warnForInsertedHydratedElement(parentContainer, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
          {
            warnForInsertedHydratedText(parentContainer, text);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type2, props2) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedElement(parentNode, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedText(parentNode, text);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type2, props2, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type2);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props2) {
          node[internalPropsKey] = props2;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index < 0) {
            {
              error2("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index]) {
              error2("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index];
          valueStack[index] = null;
          {
            fiberStack[index] = null;
          }
          index--;
        }
        function push(cursor, value, fiber) {
          index++;
          valueStack[index] = cursor.current;
          {
            fiberStack[index] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type2 = workInProgress2.type;
            var contextTypes = type2.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context2);
            }
            return context2;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type2) {
          {
            var childContextTypes = type2.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context2, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push(contextStackCursor, context2, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type2, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type2.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type2, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type2, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component = node.type;
                  if (isContextProvider(Component)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i4 = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue3 = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i4 < queue3.length; i4++) {
                var callback = queue3[i4];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error3) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i4 + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error3;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index2) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index2 + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance,
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null)
                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance) {
          warnUnhydratedInstance(returnFiber, instance);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type2 = fiber.type;
                    var props2 = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type2);
                    break;
                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null)
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type2 = fiber.type;
              var props2 = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type2);
              if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                return true;
              }
              return false;
            }
            case HostText: {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error3) {
          if (hydrationErrors === null) {
            hydrationErrors = [error3];
          } else {
            hydrationErrors.push(error3);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictLegacyMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set2) {
            var array = [];
            set2.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props2 = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props2[propName] === void 0) {
                props2[propName] = defaultProps[propName];
              }
            }
            return props2;
          }
          return baseProps;
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context2, nextValue) {
          {
            push(valueCursor, context2._currentValue, providerFiber);
            context2._currentValue = nextValue;
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context2, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context2._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node === propagationRoot) {
              break;
            }
            node = node.return;
          }
          {
            if (node !== propagationRoot) {
              error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context2, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context2, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context2, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list = fiber.dependencies;
            if (list !== null) {
              nextFiber = fiber.child;
              var dependency = list.firstContext;
              while (dependency !== null) {
                if (dependency.context === context2) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update = createUpdate(NoTimestamp, lane);
                    update.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null)
                      ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update.next = update;
                      } else {
                        update.next = pending.next;
                        pending.next = update;
                      }
                      sharedQueue.pending = update;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list.lanes = mergeLanes(list.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context2) {
          {
            if (isDisallowedContextReadInDEV) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context2._currentValue;
          if (lastFullyObservedContext === context2)
            ;
          else {
            var contextItem = {
              context: context2,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue3) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue3];
          } else {
            concurrentQueues.push(queue3);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i4 = 0; i4 < concurrentQueues.length; i4++) {
              var queue3 = concurrentQueues[i4];
              var lastInterleavedUpdate = queue3.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue3.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue3.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue3.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue3, update, lane) {
          var interleaved = queue3.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue3);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue3.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue3, update, lane) {
          var interleaved = queue3.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue3);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue3.interleaved = update;
        }
        function enqueueConcurrentClassUpdate(fiber, queue3, update, lane) {
          var interleaved = queue3.interleaved;
          if (interleaved === null) {
            update.next = update;
            pushConcurrentUpdateQueue(queue3);
          } else {
            update.next = interleaved.next;
            interleaved.next = update;
          }
          queue3.interleaved = update;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root3 = node.stateNode;
            return root3;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue3 = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue3;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue3 = workInProgress2.updateQueue;
          var currentQueue3 = current2.updateQueue;
          if (queue3 === currentQueue3) {
            var clone = {
              baseState: currentQueue3.baseState,
              firstBaseUpdate: currentQueue3.firstBaseUpdate,
              lastBaseUpdate: currentQueue3.lastBaseUpdate,
              shared: currentQueue3.shared,
              effects: currentQueue3.effects
            };
            workInProgress2.updateQueue = clone;
          }
        }
        function createUpdate(eventTime, lane) {
          var update = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update;
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
          }
        }
        function entangleTransitions(root3, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root3, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue3 = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue3 = current2.updateQueue;
            if (queue3 === currentQueue3) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue3.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update = firstBaseUpdate;
                do {
                  var clone = {
                    eventTime: update.eventTime,
                    lane: update.lane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone;
                  } else {
                    newLast.next = clone;
                    newLast = clone;
                  }
                  update = update.next;
                } while (update !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue3 = {
                baseState: currentQueue3.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue3.shared,
                effects: currentQueue3.effects
              };
              workInProgress2.updateQueue = queue3;
              return;
            }
          }
          var lastBaseUpdate = queue3.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue3.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue3.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue3, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case ReplaceState: {
              var payload = update.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props2, instance, renderLanes2) {
          var queue3 = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue3.shared;
          }
          var firstBaseUpdate = queue3.firstBaseUpdate;
          var lastBaseUpdate = queue3.lastBaseUpdate;
          var pendingQueue = queue3.shared.pending;
          if (pendingQueue !== null) {
            queue3.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue3 = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue3.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue3.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue3.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue3.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
              var updateLane = update.lane;
              var updateEventTime = update.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    lane: NoLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue3, update, newState, props2, instance);
                var callback = update.callback;
                if (callback !== null && update.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue3.effects;
                  if (effects === null) {
                    queue3.effects = [update];
                  } else {
                    effects.push(update);
                  }
                }
              }
              update = update.next;
              if (update === null) {
                pendingQueue = queue3.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update = _firstPendingUpdate;
                  queue3.lastBaseUpdate = _lastPendingUpdate;
                  queue3.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue3.baseState = newBaseState;
            queue3.firstBaseUpdate = newFirstBaseUpdate;
            queue3.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue3.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue3.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context2) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context2);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i4 = 0; i4 < effects.length; i4++) {
              var effect = effects[i4];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var fakeInternalInstance = {};
        var emptyRefsObject = new React8.Component().refs;
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type2, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type2) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(fiber, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitions(root3, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray4(_state))) {
              error2("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props2) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context2 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance = new ctor(props2, context2);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance = new ctor(props2, context2);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context2);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = emptyRefsObject;
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function coerceRef(returnFiber, current2, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref = function(value) {
                var refs = resolvedInst.refs;
                if (refs === emptyRefsObject) {
                  refs = resolvedInst.refs = {};
                }
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init3 = lazyType._init;
          return init3(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
            }
            if (current2 !== null) {
              if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                var existing = useFiber(current2, element.props);
                existing.ref = coerceRef(returnFiber, current2, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment, lanes, key2) {
            if (current2 === null || current2.tag !== Fragment4) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key2);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return createChild(returnFiber, init3(payload), lanes);
                }
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key2 = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key2 !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key2) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key2) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init3(payload), lanes);
                }
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                if (key2 !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init3(payload), lanes);
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key2 = child.key;
                  if (typeof key2 !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key2);
                    break;
                  }
                  if (!knownKeys.has(key2)) {
                    knownKeys.add(key2);
                    break;
                  }
                  error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key2);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init3 = child._init;
                  warnOnInvalidKey(init3(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i4 = 0; i4 < newChildren.length; i4++) {
                var child = newChildren[i4];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key2 = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key2) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment4) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key2 = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key2) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init3 = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init3(payload), lanes);
              }
              if (isArray4(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (current2 !== null && workInProgress2.child !== current2.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c4) {
          if (c4 === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c4;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context2 = requiredContext(contextStackCursor$1.current);
          return context2;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context2 = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context2, fiber.type);
          if (context2 === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props2 = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = 0;
        var HasEffect = 1;
        var Insertion = 2;
        var Layout = 4;
        var Passive$1 = 8;
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i4 = 0; i4 < workInProgressSources.length; i4++) {
            var mutableSource = workInProgressSources[i4];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root3, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version5 = getVersion(mutableSource._source);
          if (root3.mutableSourceEagerHydrationData == null) {
            root3.mutableSourceEagerHydrationData = [mutableSource, version5];
          } else {
            root3.mutableSourceEagerHydrationData.push(mutableSource, version5);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray4(deps)) {
              error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table = "";
                var secondColumnStart = 30;
                for (var i4 = 0; i4 <= hookTypesUpdateIndexDev; i4++) {
                  var oldHookName = hookTypesDev[i4];
                  var newHookName = i4 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i4 + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table += row;
                }
                error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props2, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props2, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props2, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
              error2("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue3 = hook.queue;
              if (queue3 !== null) {
                queue3.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init3) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init3 !== void 0) {
            initialState = init3(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue3 = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = queue3;
          var dispatch = queue3.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue3);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init3) {
          var hook = updateWorkInProgressHook();
          var queue3 = hook.queue;
          if (queue3 === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue3.lastRenderedReducer = reducer;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue3.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue3.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
              var updateLane = update.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone = {
                  lane: updateLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    lane: NoLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update.hasEagerState) {
                  newState = update.eagerState;
                } else {
                  var action = update.action;
                  newState = reducer(newState, action);
                }
              }
              update = update.next;
            } while (update !== null && update !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue3.lastRenderedState = newState;
          }
          var lastInterleaved = queue3.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue3.lanes = NoLanes;
          }
          var dispatch = queue3.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init3) {
          var hook = updateWorkInProgressHook();
          var queue3 = hook.queue;
          if (queue3 === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue3.lastRenderedReducer = reducer;
          var dispatch = queue3.dispatch;
          var lastRenderPhaseUpdate = queue3.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue3.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
              var action = update.action;
              newState = reducer(newState, action);
              update = update.next;
            } while (update !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue3.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root3 = getWorkInProgressRoot();
            if (root3 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root3, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root3 = getWorkInProgressRoot();
            if (root3 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root3, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check];
            } else {
              stores.push(check);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue3 = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue3;
          var dispatch = queue3.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue3);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
          var effect = {
            tag,
            create,
            destroy,
            deps,
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
        }
        function mountEffect(create, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
          }
        }
        function updateEffect(create, deps) {
          return updateEffectImpl(Passive, Passive$1, create, deps);
        }
        function mountInsertionEffect(create, deps) {
          return mountEffectImpl(Update, Insertion, create, deps);
        }
        function updateInsertionEffect(create, deps) {
          return updateEffectImpl(Update, Insertion, create, deps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start;
          return [isPending, start];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root3 = getWorkInProgressRoot();
          var identifierPrefix = root3.identifierPrefix;
          var id;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            id += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id;
          return id;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id = hook.memoizedState;
          return id;
        }
        function dispatchReducerAction(fiber, queue3, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue3, update);
          } else {
            var root3 = enqueueConcurrentHookUpdate(fiber, queue3, update, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitionUpdate(root3, queue3, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue3, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue3, update);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue3.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue3.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update.hasEagerState = true;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue3, update, lane);
                    return;
                  }
                } catch (error3) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root3 = enqueueConcurrentHookUpdate(fiber, queue3, update, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
              entangleTransitionUpdate(root3, queue3, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue3, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue3.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          queue3.pending = update;
        }
        function entangleTransitionUpdate(root3, queue3, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue3.lanes;
            queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue3.lanes = newQueueLanes;
            markRootEntangled(root3, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init3) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init3);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root3 = parentFiber.stateNode;
                  root3.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root3 = parentFiber.stateNode;
                  if (root3 !== null) {
                    root3.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function createCapturedValueAtFiber(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value, digest, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error3 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error3 != null && error3._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error3);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error3);
            }
          } catch (e5) {
            setTimeout(function() {
              throw e5;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          update.payload = {
            element: null
          };
          var error3 = errorInfo.value;
          update.callback = function() {
            onUncaughtError(error3);
            logCapturedError(fiber, errorInfo);
          };
          return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update;
        }
        function attachPingListener(root3, wakeable, lanes) {
          var pingCache = root3.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root3.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node = returnFiber;
          do {
            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
              return node;
            }
            node = node.return;
          } while (node !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update = createUpdate(NoTimestamp, SyncLane);
                  update.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root3, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root3, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root3, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root3, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var render2 = Component.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (current2 === null) {
            var type2 = Component.type;
            if (isSimpleFunctionComponent(type2) && Component.compare === null && Component.defaultProps === void 0) {
              var resolvedType = type2;
              {
                resolvedType = resolveFunctionForHotReloading(type2);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type2);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(type2)
                );
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current2.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare6 = Component.compare;
            compare6 = compare6 !== null ? compare6 : shallowEqual;
            if (compare6(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  outerMemoType = init3(payload);
                } catch (x5) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context2, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(Component)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root3 = workInProgress2.stateNode;
          if (root3.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
          } else if (root3.context) {
            pushTopLevelContextObject(workInProgress2, root3.context, false);
          }
          pushHostContainer(workInProgress2, root3.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current2 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root3 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type2 = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type2, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type2, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props2 = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init3 = lazyComponent._init;
          var Component = init3(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props2);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      "prop",
                      getComponentNameFromType(Component)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component,
                resolveDefaultProps(Component.type, resolvedProps),
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props2 = workInProgress2.pendingProps;
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component, props2, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component, props2, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component, props2, context2, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current2.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2,
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error3;
              if (message) {
                error3 = new Error(message);
              } else {
                error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error3, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root3 = getWorkInProgressRoot();
              if (root3 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current2.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current2.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index2) {
          {
            var isAnArray = isArray4(childSlot);
            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable) {
              var type2 = isAnArray ? "array" : "iterable";
              error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type2, index2, type2);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray4(children)) {
                for (var i4 = 0; i4 < children.length; i4++) {
                  if (!validateSuspenseListNestedChild(children[i4], i4)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i2 = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i2)) {
                        return;
                      }
                      _i2++;
                    }
                  }
                } else {
                  error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  tail,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  _tail,
                  null,
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  null,
                  null,
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context2 = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context2, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context2, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context2 = workInProgress2.type;
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render2 = newProps.children;
          {
            if (typeof render2 !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render2(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current2, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current2];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current2);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          var updateLanes = current2.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root3 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context2 = workInProgress2.type._context;
              pushProvider(workInProgress2, context2, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
              if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
              }
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type2 = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type2 ? _unresolvedProps2 : resolveDefaultProps(type2, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type2, _resolvedProps2, renderLanes2);
            }
            case Fragment4:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(current2, workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type2, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type2, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current2 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment4:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current2 !== null) {
                    var prevState = current2.memoizedState;
                    if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type2 = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type2, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type2, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type2, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current2, workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.renderingStartTime = now();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current2 !== null) {
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current2, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root3 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root3 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context2 = interruptedWork.type._context;
              popProvider(context2, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error3) {
          {
            invokeGuardedCallback(null, function() {
              throw error3;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current2, instance) {
          instance.props = current2.memoizedProps;
          instance.state = current2.memoizedState;
          if (current2.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current2);
            }
          } else {
            instance.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          try {
            callComponentWillUnmountWithTimer(current2, instance);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
          try {
            instance.componentDidMount();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            commitAttachRef(current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current2);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error3) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error3);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root3, firstChild) {
          focusedInstanceHandle = prepareForCommit(root3.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root3 = finishedWork.stateNode;
                  clearContainer(root3.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root3 = parentFiber.stateNode;
                          root3.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current2 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                      var prevState = current2.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type2 = finishedWork.type;
                  var props2 = finishedWork.memoizedProps;
                  commitMount(_instance2, type2, props2);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current2 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node) {
          switch (node.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                } finally {
                  recordLayoutEffectDuration(node);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              }
              break;
            }
            case ClassComponent: {
              var instance = node.stateNode;
              if (typeof instance.componentDidMount === "function") {
                safelyCallComponentDidMount(node, node.return, instance);
              }
              safelyAttachRef(node, node.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node, node.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
          var hostSubtreeRoot = null;
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node;
                  try {
                    var instance = node.stateNode;
                    if (isHidden) {
                      hideInstance(instance);
                    } else {
                      unhideInstance(node.stateNode, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if (node.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node.stateNode;
                    if (isHidden) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node = node.return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings:
            while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root3, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent:
              while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance = deletedFiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (deletedFiber.mode & ConcurrentMode) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root3, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root3;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root3);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i4 = 0; i4 < deletions.length; i4++) {
              var childToDelete = deletions[i4];
              try {
                commitDeletionEffects(root3, parentFiber, childToDelete);
              } catch (error3) {
                captureCommitPhaseError(childToDelete, parentFiber, error3);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root3);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance = finishedWork.stateNode;
                  try {
                    resetTextContent(instance);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                    var type2 = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type2, oldProps, newProps, finishedWork);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current2 !== null ? current2.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current2 !== null) {
                    var prevRootState = current2.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root3.containerInfo);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden = newState !== null;
                offscreenInstance.isHidden = isHidden;
                if (isHidden) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current2 !== null && current2.memoizedState !== null;
              if (finishedWork.mode & ConcurrentMode) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root3, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root3, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root3, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error3) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error3);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root3, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root3;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root3, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                continue;
              } else {
                var current2 = fiber.alternate;
                var wasHidden = current2 !== null && current2.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    root3,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current2 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i4 = 0; i4 < deletions.length; i4++) {
                  var fiberToDelete = deletions[i4];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current2.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                recordPassiveEffectDuration(current2);
              } else {
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                try {
                  instance.componentDidMount();
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error2("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = 0;
        var BatchedContext = 1;
        var RenderContext = 2;
        var CommitContext = 4;
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error2("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root3, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root3, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root3 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root3, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
          var current2 = root3.current;
          current2.lanes = lane;
          markRootUpdated(root3, lane, eventTime);
          ensureRootIsScheduled(root3, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (executionContext & RenderContext) !== NoContext;
        }
        function ensureRootIsScheduled(root3, currentTime) {
          var existingCallbackNode = root3.callbackNode;
          markStarvedLanesAsExpired(root3, currentTime);
          var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root3.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root3.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
          }
          root3.callbackPriority = newCallbackPriority;
          root3.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root3, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root3.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root3.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root3, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root3, lanes);
              var finishedWork = root3.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root3, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root3, NoLanes);
                  markRootSuspended$1(root3, lanes);
                  ensureRootIsScheduled(root3, now());
                  throw _fatalError;
                }
              }
              root3.finishedWork = finishedWork;
              root3.finishedLanes = lanes;
              finishConcurrentRender(root3, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root3, now());
          if (root3.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root3);
          }
          return null;
        }
        function recoverFromConcurrentError(root3, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root3)) {
            var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root3.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root3, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors2) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors2;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors2);
          }
        }
        function finishConcurrentRender(root3, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root3, lanes);
              if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root3, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root3.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root3, suspendedLanes);
                    break;
                  }
                  root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root3, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node = finishedWork;
          while (true) {
            if (node.flags & StoreConsistency) {
              var updateQueue = node.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i4 = 0; i4 < checks.length; i4++) {
                    var check = checks[i4];
                    var getSnapshot = check.getSnapshot;
                    var renderedValue = check.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error3) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node.child;
            if (node.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node;
              node = child;
              continue;
            }
            if (node === finishedWork) {
              return true;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return true;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root3, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root3, suspendedLanes);
        }
        function performSyncWorkOnRoot(root3) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root3, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root3, now());
            return null;
          }
          var exitStatus = renderRootSync(root3, lanes);
          if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root3, NoLanes);
            markRootSuspended$1(root3, lanes);
            ensureRootIsScheduled(root3, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root3.current.alternate;
          root3.finishedWork = finishedWork;
          root3.finishedLanes = lanes;
          commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root3, now());
          return null;
        }
        function flushRoot(root3, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root3, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root3, now());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn2, a4) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn2(a4);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn2, a4, b3, c4, d4) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn2(a4, b3, c4, d4);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync(fn2) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn2) {
              return fn2();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root3, lanes) {
          root3.finishedWork = null;
          root3.finishedLanes = NoLanes;
          var timeoutHandle = root3.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root3.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current2 = interruptedWork.alternate;
              unwindInterruptedWork(current2, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root3;
          var rootWorkInProgress = createWorkInProgress(root3.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root3, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error3) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error3];
          } else {
            workInProgressRootConcurrentErrors.push(error3);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root3, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root3, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root3, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root3, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root3, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root3, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root3, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
            } else {
              var _next = unwindWork(current2, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root3, recoverableErrors, transitions) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root3.finishedWork;
          var lanes = root3.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root3.finishedWork = null;
          root3.finishedLanes = NoLanes;
          if (finishedWork === root3.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root3.callbackNode = null;
          root3.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root3, remainingLanes);
          if (root3 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root3, finishedWork, lanes);
            resetAfterCommit(root3.containerInfo);
            root3.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root3, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root3.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root3;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root3.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root3.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root3.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root3, now());
          if (recoverableErrors !== null) {
            var onRecoverableError = root3.onRecoverableError;
            for (var i4 = 0; i4 < recoverableErrors.length; i4++) {
              var recoverableError = recoverableErrors[i4];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root3.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root3 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root3;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root3 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root3.current);
          commitPassiveMountEffects(root3, root3.current, lanes, transitions);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i4 = 0; i4 < profilerEffects.length; i4++) {
              var _fiber = profilerEffects[i4];
              commitPassiveEffectDurations(root3, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root3.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root3 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root3;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root3);
          {
            var stateNode = root3.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error3) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error3;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
          var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root3 = enqueueUpdate(rootFiber, update, SyncLane);
          var eventTime = requestEventTime();
          if (root3 !== null) {
            markRootUpdated(root3, SyncLane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root3 = enqueueUpdate(fiber, update, SyncLane);
                var eventTime = requestEventTime();
                if (root3 !== null) {
                  markRootUpdated(root3, SyncLane, eventTime);
                  ensureRootIsScheduled(root3, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root3, wakeable, pingedLanes) {
          var pingCache = root3.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root3, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
          if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root3, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root3, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root3 !== null) {
            markRootUpdated(root3, retryLane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current2 = firstChild;
            var subtreeRoot = null;
            while (current2 !== null) {
              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                current2 = current2.child;
              } else {
                if ((current2.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current2);
                }
                if (current2.sibling !== null) {
                  current2 = current2.sibling;
                } else {
                  current2 = subtreeRoot = current2.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current2, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root3, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root3, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
          {
            if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              return type2;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type2) {
          return resolveFunctionForHotReloading(type2);
        }
        function resolveForwardRefForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              if (type2 !== null && type2 !== void 0 && typeof type2.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type2.render);
                if (type2.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type2.displayName !== void 0) {
                    syntheticType.displayName = type2.displayName;
                  }
                  return syntheticType;
                }
              }
              return type2;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root3, update) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
            flushPassiveEffects();
            flushSync(function() {
              scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root3, element) {
          {
            if (root3.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync(function() {
              updateContainer(element, root3, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root3, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e5) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key2, mode) {
          this.tag = tag;
          this.key = key2;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key2, mode) {
          return new FiberNode(tag, pendingProps, key2, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type2) {
          return typeof type2 === "function" && !shouldConstruct$1(type2) && type2.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current2.flags & StaticMask;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type2, key2, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type2;
          if (typeof type2 === "function") {
            if (shouldConstruct$1(type2)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type2 === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type2) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key2);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key2);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key2);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key2);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type2 === "object" && type2 !== null) {
                    switch (type2.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key2, mode);
          fiber.elementType = type2;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type2 = element.type;
          var key2 = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type2, key2, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key2) {
          var fiber = createFiber(Fragment4, elements, key2, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key2) {
          {
            if (typeof pendingProps.id !== "string") {
              error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key2, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key2) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key2, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
          var fiber = createFiber(HostText, content, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i2 = 0; _i2 < TotalLanes; _i2++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root3 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root3.current = uninitializedFiber;
          uninitializedFiber.stateNode = root3;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root3;
        }
        var ReactVersion = "18.2.0";
        function createPortal(children, containerInfo, implementation) {
          var key2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key2);
          }
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: key2 == null ? null : "" + key2,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get3(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get3(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys2 = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root3 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root3.context = getContextForSubtree(null);
          var current2 = root3.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current2);
          var update = createUpdate(eventTime, lane);
          update.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current2, update, lane);
          scheduleInitialHydrationOnRoot(root3, lane, eventTime);
          return root3;
        }
        function updateContainer(element, container2, parentComponent, callback) {
          {
            onScheduleRoot(container2, element);
          }
          var current$1 = container2.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context2 = getContextForSubtree(parentComponent);
          if (container2.context === null) {
            container2.context = context2;
          } else {
            container2.pendingContext = context2;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
            }
          }
          var update = createUpdate(eventTime, lane);
          update.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update.callback = callback;
          }
          var root3 = enqueueUpdate(current$1, update, lane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
            entangleTransitions(root3, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container2) {
          var containerFiber = container2.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root3 = fiber.stateNode;
              if (isRootDehydrated(root3)) {
                var lanes = getHighestPriorityPendingLanes(root3);
                flushRoot(root3, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync(function() {
                var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root4 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path2, index2) {
            var key2 = path2[index2];
            var updated = isArray4(obj) ? obj.slice() : assign({}, obj);
            if (index2 + 1 === path2.length) {
              if (isArray4(updated)) {
                updated.splice(key2, 1);
              } else {
                delete updated[key2];
              }
              return updated;
            }
            updated[key2] = copyWithDeleteImpl(obj[key2], path2, index2 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path2) {
            return copyWithDeleteImpl(obj, path2, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
            var oldKey = oldPath[index2];
            var updated = isArray4(obj) ? obj.slice() : assign({}, obj);
            if (index2 + 1 === oldPath.length) {
              var newKey = newPath[index2];
              updated[newKey] = updated[oldKey];
              if (isArray4(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(
                obj[oldKey],
                oldPath,
                newPath,
                index2 + 1
              );
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i4 = 0; i4 < newPath.length - 1; i4++) {
                if (oldPath[i4] !== newPath[i4]) {
                  warn("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path2, index2, value) {
            if (index2 >= path2.length) {
              return value;
            }
            var key2 = path2[index2];
            var updated = isArray4(obj) ? obj.slice() : assign({}, obj);
            updated[key2] = copyWithSetImpl(obj[key2], path2, index2 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path2, value) {
            return copyWithSetImpl(obj, path2, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path2, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path2, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path2) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path2);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path2, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path2, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path2) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path2);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            getCurrentFiber: getCurrentFiberForDevTools,
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error3) {
          console["error"](error3);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root3 = this._internalRoot;
          if (root3 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error2("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container2 = root3.containerInfo;
            if (container2.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root3.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container2) {
                  error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root3, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root3 = this._internalRoot;
          if (root3 !== null) {
            this._internalRoot = null;
            var container2 = root3.containerInfo;
            {
              if (isAlreadyRendering()) {
                error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync(function() {
              updateContainer(null, root3, null, null);
            });
            unmarkContainerAsRoot(container2);
          }
        };
        function createRoot2(container2, options2) {
          if (!isValidContainer(container2)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container2);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                  error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root3 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root3.current, container2);
          var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root3);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container2, initialChildren, options2) {
          if (!isValidContainer(container2)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container2);
          {
            if (initialChildren === void 0) {
              error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root3 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root3.current, container2);
          listenToAllSupportedEvents(container2);
          if (mutableSources) {
            for (var i4 = 0; i4 < mutableSources.length; i4++) {
              var mutableSource = mutableSources[i4];
              registerMutableSourceForHydration(root3, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root3);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container2) {
          {
            if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
              error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container2)) {
              if (container2._reactRootContainer) {
                error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container2) {
            if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container2) {
                  error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container2._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container2);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
              error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container2) {
          if (!container2) {
            return null;
          }
          if (container2.nodeType === DOCUMENT_NODE) {
            return container2.documentElement;
          } else {
            return container2.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root3);
                originalCallback.call(instance);
              };
            }
            var root3 = createHydrationContainer(
              initialChildren,
              callback,
              container2,
              LegacyRoot,
              null,
              false,
              false,
              "",
              noopOnRecoverableError
            );
            container2._reactRootContainer = root3;
            markContainerAsRoot(root3.current, container2);
            var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync();
            return root3;
          } else {
            var rootSibling;
            while (rootSibling = container2.lastChild) {
              container2.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(_root);
                _originalCallback.call(instance);
              };
            }
            var _root = createContainer(
              container2,
              LegacyRoot,
              null,
              false,
              false,
              "",
              noopOnRecoverableError
            );
            container2._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container2);
            var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container2, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container2);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container2._reactRootContainer;
          var root3;
          if (!maybeRoot) {
            root3 = legacyCreateRootFromDOMContainer(container2, children, parentComponent, callback, forceHydrate);
          } else {
            root3 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root3);
                originalCallback.call(instance);
              };
            }
            updateContainer(children, root3, parentComponent, callback);
          }
          return getPublicRootInstance(root3);
        }
        function findDOMNode(componentOrElement) {
          {
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container2, callback) {
          {
            error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container2)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback);
        }
        function render(element, container2, callback) {
          {
            error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container2)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        function unmountComponentAtNode(container2) {
          if (!isValidContainerLegacy(container2)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container2._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container2);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync(function() {
              legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
                container2._reactRootContainer = null;
                unmarkContainerAsRoot(container2);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container2);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container2.nodeType === ELEMENT_NODE && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
        function createPortal$1(children, container2) {
          var key2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container2)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container2, null, key2);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container2, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot2(container2, options2);
        }
        function hydrateRoot$1(container2, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container2, initialChildren, options2);
        }
        function flushSync$1(fn2) {
          {
            if (isAlreadyRendering()) {
              error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync(fn2);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var m5 = require_react_dom();
    if (false) {
      exports.createRoot = m5.createRoot;
      exports.hydrateRoot = m5.hydrateRoot;
    } else {
      i4 = m5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c4, o4) {
        i4.usingClientEntryPoint = true;
        try {
          return m5.createRoot(c4, o4);
        } finally {
          i4.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c4, h5, o4) {
        i4.usingClientEntryPoint = true;
        try {
          return m5.hydrateRoot(c4, h5, o4);
        } finally {
          i4.usingClientEntryPoint = false;
        }
      };
    }
    var i4;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames() {
        var classes = [];
        for (var i4 = 0; i4 < arguments.length; i4++) {
          var arg = arguments[i4];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key2 in arg) {
              if (hasOwn2.call(arg, key2) && arg[key2]) {
                classes.push(key2);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        var React8 = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error2(format3) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format3, args);
            }
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type2;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type2;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x5) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props2, {
                  value: prevLog
                }),
                info: assign({}, props2, {
                  value: prevInfo
                }),
                warn: assign({}, props2, {
                  value: prevWarn
                }),
                error: assign({}, props2, {
                  value: prevError
                }),
                group: assign({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x5) {
                var match = x5.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x5) {
                  control = x5;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x5) {
                  control = x5;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x5) {
                control = x5;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                c4--;
              }
              for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                if (sampleLines[s4] !== controlLines[c4]) {
                  if (s4 !== 1 || c4 !== 1) {
                    do {
                      s4--;
                      c4--;
                      if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x5) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a4) {
          return isArrayImpl(a4);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config3) {
          {
            if (hasOwnProperty3.call(config3, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.ref !== void 0;
        }
        function hasValidKey(config3) {
          {
            if (hasOwnProperty3.call(config3, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config3, self2) {
          {
            if (typeof config3.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config3.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props2, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props2, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props2, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props2, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type2, key2, ref, self2, source, owner, props2) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key: key2,
            ref,
            props: props2,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type2, config3, maybeKey, source, self2) {
          {
            var propName;
            var props2 = {};
            var key2 = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key2 = "" + maybeKey;
            }
            if (hasValidKey(config3)) {
              {
                checkKeyStringCoercion(config3.key);
              }
              key2 = "" + config3.key;
            }
            if (hasValidRef(config3)) {
              ref = config3.ref;
              warnIfStringRefCannotBeAutoConverted(config3, self2);
            }
            for (propName in config3) {
              if (hasOwnProperty3.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props2[propName] = config3[propName];
              }
            }
            if (type2 && type2.defaultProps) {
              var defaultProps = type2.defaultProps;
              for (propName in defaultProps) {
                if (props2[propName] === void 0) {
                  props2[propName] = defaultProps[propName];
                }
              }
            }
            if (key2 || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key2) {
                defineKeyPropWarningGetter(props2, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props2, displayName);
              }
            }
            return ReactElement(type2, key2, ref, self2, source, ReactCurrentOwner.current, props2);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray4(node)) {
              for (var i4 = 0; i4 < node.length; i4++) {
                var child = node[i4];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type2);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i4 = 0; i4 < keys2.length; i4++) {
              var key2 = keys2[i4];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type2, props2, key2, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type2);
            if (!validType) {
              var info = "";
              if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type2 === null) {
                typeString = "null";
              } else if (isArray4(type2)) {
                typeString = "array";
              } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type2;
              }
              error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type2, props2, key2, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props2.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray4(children)) {
                    for (var i4 = 0; i4 < children.length; i4++) {
                      validateChildKeys(children[i4], type2);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type2);
                }
              }
            }
            if (type2 === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type2, props2, key2) {
          {
            return jsxWithValidation(type2, props2, key2, true);
          }
        }
        function jsxWithValidationDynamic(type2, props2, key2) {
          {
            return jsxWithValidation(type2, props2, key2, false);
          }
        }
        var jsx7 = jsxWithValidationDynamic;
        var jsxs4 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx7;
        exports.jsxs = jsxs4;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name) {
      const res = getFromWindow3(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e5) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i4 = 0; i4 < links.length; i4++) {
          const link = links[i4];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path2 = loc.pathname.split("/");
                    path2.pop();
                    const finalPath = path2.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i4 = 0; i4 < metaTags.length; i4++) {
          const tag = metaTags[i4];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName2() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName2();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser3 = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser3, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version5 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version5, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version5, os2);
}
function detectOS(ua2) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a2 = operatingSystemRules[ii], os2 = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua2);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    __spreadArrays = function() {
      for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
        s4 += arguments[i4].length;
      for (var r5 = Array(s4), k5 = 0, i4 = 0; i4 < il; i4++)
        for (var a4 = arguments[i4], j4 = 0, jl = a4.length; j4 < jl; j4++, k5++)
          r5[k5] = a4[j4];
      return r5;
    };
    BrowserInfo = function() {
      function BrowserInfo2(name, version5, os2) {
        this.name = name;
        this.version = version5;
        this.os = os2;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = function() {
      function NodeInfo2(version5) {
        this.version = version5;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo2(name, version5, os2, bot) {
        this.name = name;
        this.version = version5;
        this.os = os2;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env5 = detectEnv();
  return env5 && env5.os ? env5.os : void 0;
}
function isAndroid() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("ios") || os2.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os2 = detectOS2();
  return os2 ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env5 = detectEnv();
  const result = env5 && env5.name ? env5.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    windowMetadata = __toESM(require_cjs2());
    windowGetters = __toESM(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    init_virtual_process_polyfill();
    init_buffer();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key2, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key2);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform4 = "mobile") {
  var _a2;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a2 = entry.image_url.sm) !== null && _a2 !== void 0 ? _a2 : "",
    universalLink: entry[platform4].universal || "",
    deepLink: entry[platform4].native || ""
  };
}
function formatMobileRegistry(registry, platform4 = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform4].universal || !!entry[platform4].native).map((entry) => formatMobileRegistryEntry(entry, platform4));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node-modules-polyfills:buffer
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer3,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  SlowBuffer: () => SlowBuffer,
  isBuffer: () => isBuffer2,
  kMaxLength: () => _kMaxLength
});
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup2[i4] = code[i4];
    revLookup2[code.charCodeAt(i4)] = i4;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited2) {
    init2();
  }
  var i4, j4, l5, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l5 = placeHolders > 0 ? len - 4 : len;
  var L4 = 0;
  for (i4 = 0, j4 = 0; i4 < l5; i4 += 4, j4 += 3) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 18 | revLookup2[b64.charCodeAt(i4 + 1)] << 12 | revLookup2[b64.charCodeAt(i4 + 2)] << 6 | revLookup2[b64.charCodeAt(i4 + 3)];
    arr[L4++] = tmp >> 16 & 255;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 2 | revLookup2[b64.charCodeAt(i4 + 1)] >> 4;
    arr[L4++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i4)] << 10 | revLookup2[b64.charCodeAt(i4 + 1)] << 4 | revLookup2[b64.charCodeAt(i4 + 2)] >> 2;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i4 = start; i4 < end; i4 += 3) {
    tmp = (uint8[i4] << 16) + (uint8[i4 + 1] << 8) + uint8[i4 + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i4 = 0, len2 = len - extraBytes; i4 < len2; i4 += maxChunkLength) {
    parts.push(encodeChunk2(uint8, i4, i4 + maxChunkLength > len2 ? len2 : i4 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e5, m5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i4 = isLE ? nBytes - 1 : 0;
  var d4 = isLE ? -1 : 1;
  var s4 = buffer[offset + i4];
  i4 += d4;
  e5 = s4 & (1 << -nBits) - 1;
  s4 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e5 = e5 * 256 + buffer[offset + i4], i4 += d4, nBits -= 8) {
  }
  m5 = e5 & (1 << -nBits) - 1;
  e5 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m5 = m5 * 256 + buffer[offset + i4], i4 += d4, nBits -= 8) {
  }
  if (e5 === 0) {
    e5 = 1 - eBias;
  } else if (e5 === eMax) {
    return m5 ? NaN : (s4 ? -1 : 1) * Infinity;
  } else {
    m5 = m5 + Math.pow(2, mLen);
    e5 = e5 - eBias;
  }
  return (s4 ? -1 : 1) * m5 * Math.pow(2, e5 - mLen);
}
function write2(buffer, value, offset, isLE, mLen, nBytes) {
  var e5, m5, c4;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i4 = isLE ? 0 : nBytes - 1;
  var d4 = isLE ? 1 : -1;
  var s4 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m5 = isNaN(value) ? 1 : 0;
    e5 = eMax;
  } else {
    e5 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c4 = Math.pow(2, -e5)) < 1) {
      e5--;
      c4 *= 2;
    }
    if (e5 + eBias >= 1) {
      value += rt / c4;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c4 >= 2) {
      e5++;
      c4 /= 2;
    }
    if (e5 + eBias >= eMax) {
      m5 = 0;
      e5 = eMax;
    } else if (e5 + eBias >= 1) {
      m5 = (value * c4 - 1) * Math.pow(2, mLen);
      e5 = e5 + eBias;
    } else {
      m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e5 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i4] = m5 & 255, i4 += d4, m5 /= 256, mLen -= 8) {
  }
  e5 = e5 << mLen | m5;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i4] = e5 & 255, i4 += d4, e5 /= 256, eLen -= 8) {
  }
  buffer[offset + i4 - d4] |= s4 * 128;
}
function kMaxLength2() {
  return Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length) {
  if (kMaxLength2() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer3.prototype;
  } else {
    if (that === null) {
      that = new Buffer3(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
    return new Buffer3(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from2(this, arg, encodingOrOffset, length);
}
function from2(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString2(that, value, encodingOrOffset);
  }
  return fromObject2(that, value);
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill3, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill3 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill3, encoding) : createBuffer2(that, size).fill(fill3);
  }
  return createBuffer2(that, size);
}
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer3.TYPED_ARRAY_SUPPORT) {
    for (var i4 = 0; i4 < size; ++i4) {
      that[i4] = 0;
    }
  }
  return that;
}
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength2(string, encoding) | 0;
  that = createBuffer2(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length);
  for (var i4 = 0; i4 < length; i4 += 1) {
    that[i4] = array[i4] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer3.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer3.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length) {
  if (length >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer3.alloc(+length);
}
function internalIsBuffer2(b3) {
  return !!(b3 != null && b3._isBuffer);
}
function byteLength2(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString2(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start, end);
      case "ascii":
        return asciiSlice2(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start, end);
      case "base64":
        return base64Slice2(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap2(b3, n4, m5) {
  var i4 = b3[n4];
  b3[n4] = b3[m5];
  b3[m5] = i4;
}
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer3.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer3.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i5) {
    if (indexSize === 1) {
      return buf[i5];
    } else {
      return buf.readUInt16BE(i5 * indexSize);
    }
  }
  var i4;
  if (dir) {
    var foundIndex = -1;
    for (i4 = byteOffset; i4 < arrLength; i4++) {
      if (read2(arr, i4) === read2(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i4;
        if (i4 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i4 -= i4 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i4 = byteOffset; i4 >= 0; i4--) {
      var found = true;
      for (var j4 = 0; j4 < valLength; j4++) {
        if (read2(arr, i4 + j4) !== read2(val, j4)) {
          found = false;
          break;
        }
      }
      if (found)
        return i4;
    }
  }
  return -1;
}
function hexWrite2(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i4 = 0; i4 < length; ++i4) {
    var parsed = parseInt(string.substr(i4 * 2, 2), 16);
    if (isNaN(parsed))
      return i4;
    buf[offset + i4] = parsed;
  }
  return i4;
}
function utf8Write2(buf, string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
}
function asciiWrite2(buf, string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), buf, offset, length);
}
function latin1Write2(buf, string, offset, length) {
  return asciiWrite2(buf, string, offset, length);
}
function base64Write2(buf, string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), buf, offset, length);
}
function ucs2Write2(buf, string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset), buf, offset, length);
}
function base64Slice2(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i4 = start;
  while (i4 < end) {
    var firstByte = buf[i4];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i4 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i4 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i4 + 1];
          thirdByte = buf[i4 + 2];
          fourthByte = buf[i4 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i4 += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i4 = 0;
  while (i4 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i4 = start; i4 < end; ++i4) {
    ret += String.fromCharCode(buf[i4] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i4 = start; i4 < end; ++i4) {
    ret += String.fromCharCode(buf[i4]);
  }
  return ret;
}
function hexSlice2(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i4 = start; i4 < end; ++i4) {
    out += toHex2(buf[i4]);
  }
  return out;
}
function utf16leSlice2(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i4 = 0; i4 < bytes.length; i4 += 2) {
    res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
  }
  return res;
}
function checkOffset2(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt2(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt162(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i4 = 0, j4 = Math.min(buf.length - offset, 2); i4 < j4; ++i4) {
    buf[offset + i4] = (value & 255 << 8 * (littleEndian ? i4 : 1 - i4)) >>> (littleEndian ? i4 : 1 - i4) * 8;
  }
}
function objectWriteUInt322(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i4 = 0, j4 = Math.min(buf.length - offset, 4); i4 < j4; ++i4) {
    buf[offset + i4] = value >>> (littleEndian ? i4 : 3 - i4) * 8 & 255;
  }
}
function checkIEEE7542(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 4);
  }
  write2(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble2(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value, offset, 8);
  }
  write2(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex2(n4) {
  if (n4 < 16)
    return "0" + n4.toString(16);
  return n4.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i4 = 0; i4 < length; ++i4) {
    codePoint = string.charCodeAt(i4);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i4 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    byteArray.push(str.charCodeAt(i4) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c4, hi, lo2;
  var byteArray = [];
  for (var i4 = 0; i4 < str.length; ++i4) {
    if ((units -= 2) < 0)
      break;
    c4 = str.charCodeAt(i4);
    hi = c4 >> 8;
    lo2 = c4 % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray(base64clean2(str));
}
function blitBuffer2(src, dst, offset, length) {
  for (var i4 = 0; i4 < length; ++i4) {
    if (i4 + offset >= dst.length || i4 >= src.length)
      break;
    dst[i4 + offset] = src[i4];
  }
  return i4;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var lookup2, revLookup2, Arr2, inited2, toString2, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH2, INVALID_BASE64_RE2;
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    init_virtual_process_polyfill();
    init_buffer();
    lookup2 = [];
    revLookup2 = [];
    Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited2 = false;
    toString2 = {}.toString;
    isArray = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer3.TYPED_ARRAY_SUPPORT = window.TYPED_ARRAY_SUPPORT !== void 0 ? window.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength2();
    Buffer3.poolSize = 8192;
    Buffer3._augment = function(arr) {
      arr.__proto__ = Buffer3.prototype;
      return arr;
    };
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from2(null, value, encodingOrOffset, length);
    };
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
    }
    Buffer3.alloc = function(size, fill3, encoding) {
      return alloc2(null, size, fill3, encoding);
    };
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe2(null, size);
    };
    Buffer3.isBuffer = isBuffer2;
    Buffer3.compare = function compare3(a4, b3) {
      if (!internalIsBuffer2(a4) || !internalIsBuffer2(b3)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a4 === b3)
        return 0;
      var x5 = a4.length;
      var y5 = b3.length;
      for (var i4 = 0, len = Math.min(x5, y5); i4 < len; ++i4) {
        if (a4[i4] !== b3[i4]) {
          x5 = a4[i4];
          y5 = b3[i4];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding2(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i4;
      if (length === void 0) {
        length = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length += list[i4].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        var buf = list[i4];
        if (!internalIsBuffer2(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer3.byteLength = byteLength2;
    Buffer3.prototype._isBuffer = true;
    Buffer3.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 2) {
        swap2(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap322() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 4) {
        swap2(this, i4, i4 + 3);
        swap2(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap642() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 8) {
        swap2(this, i4, i4 + 7);
        swap2(this, i4 + 1, i4 + 6);
        swap2(this, i4 + 2, i4 + 5);
        swap2(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString3() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length);
      return slowToString2.apply(this, arguments);
    };
    Buffer3.prototype.equals = function equals2(b3) {
      if (!internalIsBuffer2(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3)
        return true;
      return Buffer3.compare(this, b3) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer3.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer2(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x5 = thisEnd - thisStart;
      var y5 = end - start;
      var len = Math.min(x5, y5);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x5 = thisCopy[i4];
          y5 = targetCopy[i4];
          break;
        }
      }
      if (x5 < y5)
        return -1;
      if (y5 < x5)
        return 1;
      return 0;
    };
    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
    };
    Buffer3.prototype.write = function write3(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite2(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write2(this, string, offset, length);
          case "ascii":
            return asciiWrite2(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write2(this, string, offset, length);
          case "base64":
            return base64Write2(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write2(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
    Buffer3.prototype.slice = function slice2(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i4 = 0; i4 < sliceLen; ++i4) {
          newBuf[i4] = this[i4 + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.readUIntLE = function readUIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset + i4] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUIntBE = function readUIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        checkOffset2(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUInt8 = function readUInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUInt16LE = function readUInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUInt16BE = function readUInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUInt32LE = function readUInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUInt32BE = function readUInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength3 && (mul *= 256)) {
        val += this[offset + i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE2(offset, byteLength3, noAssert) {
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert)
        checkOffset2(offset, byteLength3, this.length);
      var i4 = byteLength3;
      var mul = 1;
      var val = this[offset + --i4];
      while (i4 > 0 && (mul *= 256)) {
        val += this[offset + --i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt82(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE2(offset, noAssert) {
      if (!noAssert)
        checkOffset2(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer3.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i4 = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        this[offset + i4] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength3 = byteLength3 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt2(this, value, offset, byteLength3, maxBytes, 0);
      }
      var i4 = byteLength3 - 1;
      var mul = 1;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        this[offset + i4] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUInt8 = function writeUInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 255, 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUInt16LE = function writeUInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt16BE = function writeUInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 65535, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeUInt32LE = function writeUInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeUInt32BE = function writeUInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 4294967295, 0);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i4 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt2(this, value, offset, byteLength3, limit - 1, -limit);
      }
      var i4 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt82(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 1, 127, -128);
      if (!Buffer3.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt162(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 2, 32767, -32768);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt162(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt322(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE2(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt2(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt322(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer3.prototype.writeFloatLE = function writeFloatLE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE2(value, offset, noAssert) {
      return writeFloat2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE2(value, offset, noAssert) {
      return writeDouble2(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i4;
      if (this === target && start < targetStart && targetStart < end) {
        for (i4 = len - 1; i4 >= 0; --i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i4 = 0; i4 < len; ++i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer3(val, encoding).toString());
        var len = bytes.length;
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node-modules-polyfills-commonjs:buffer
var require_buffer = __commonJS({
  "node-modules-polyfills-commonjs:buffer"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_buffer2(), __toCommonJS(buffer_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/@walletconnect/core/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/core/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 <<= 4;
          if (c4 >= 49 && c4 <= 54) {
            r5 |= c4 - 49 + 10;
          } else if (c4 >= 17 && c4 <= 22) {
            r5 |= c4 - 17 + 10;
          } else {
            r5 |= c4 & 15;
          }
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        for (i4 = number.length - 6, j4 = 0; i4 >= start; i4 -= 6) {
          w6 = parseHex(number, i4, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j4++;
          }
        }
        if (i4 + 6 !== start) {
          w6 = parseHex(number, start, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          r5.strip();
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString4 = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString4.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer2.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer2.from(arr);
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root2 = WINDOW ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = window;
      } else if (WEB_WORKER) {
        root2 = self;
      }
      var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n4, s4) {
          return methods["cshake" + bits2].update(message, outputBits, n4, s4)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key2, message, outputBits, s4) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s4)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
          var type2 = OUTPUT_TYPES[i5];
          method[type2] = createMethod2(bits2, padding, type2);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n4, s4) {
          if (!n4 && !s4) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n4, s4], w6);
          }
        };
        method.update = function(message, outputBits, n4, s4) {
          return method.create(outputBits, n4, s4).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key2, outputBits, s4) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s4], w6).bytepad([key2], w6);
        };
        method.update = function(key2, message, outputBits, s4) {
          return method.create(key2, outputBits, s4).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i4 = 0; i4 < algorithms.length; ++i4) {
        var algorithm = algorithms[i4];
        var bits = algorithm.bits;
        for (var j4 = 0; j4 < bits.length; ++j4) {
          var methodName = algorithm.name + "_" + bits[j4];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j4], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j4];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i5 = 0; i5 < 50; ++i5) {
          this.s[i5] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type2 = typeof message;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s4 = this.s, i5, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          if (notString) {
            for (i5 = this.start; index < length && i5 < byteCount; ++index) {
              blocks[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
            }
          } else {
            for (i5 = this.start; index < length && i5 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i5 >> 2] |= code << SHIFT[i5++ & 3];
              } else if (code < 2048) {
                blocks[i5 >> 2] |= (192 | code >> 6) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i5 >> 2] |= (224 | code >> 12) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i5 >> 2] |= (240 | code >> 18) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
              }
            }
          }
          this.lastByteIndex = i5;
          if (i5 >= byteCount) {
            this.start = i5 - byteCount;
            this.block = blocks[blockCount];
            for (i5 = 0; i5 < blockCount; ++i5) {
              s4[i5] ^= blocks[i5];
            }
            f5(s4);
            this.reset = true;
          } else {
            this.start = i5;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x5, right) {
        var o4 = x5 & 255, n4 = 1;
        var bytes = [o4];
        x5 = x5 >> 8;
        o4 = x5 & 255;
        while (o4 > 0) {
          bytes.unshift(o4);
          x5 = x5 >> 8;
          o4 = x5 & 255;
          ++n4;
        }
        if (right) {
          bytes.push(n4);
        } else {
          bytes.unshift(n4);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type2 = typeof str;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i5 = 0; i5 < str.length; ++i5) {
            var code = str.charCodeAt(i5);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i5) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w6) {
        var bytes = this.encode(w6);
        for (var i5 = 0; i5 < strs.length; ++i5) {
          bytes += this.encodeString(strs[i5]);
        }
        var paddingBytes = w6 - bytes % w6;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s4 = this.s;
        blocks[i5 >> 2] |= this.padding[i5 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i5 = 1; i5 < blockCount + 1; ++i5) {
            blocks[i5] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i5 = 0; i5 < blockCount; ++i5) {
          s4[i5] ^= blocks[i5];
        }
        f5(s4);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j5 = 0;
        var hex = "", block;
        while (j5 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j5 < outputBlocks; ++i5, ++j5) {
            block = s4[i5];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j5 % blockCount === 0) {
            f5(s4);
            i5 = 0;
          }
        }
        if (extraBytes) {
          block = s4[i5];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j5 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j5 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j5 < outputBlocks; ++i5, ++j5) {
            array[j5] = s4[i5];
          }
          if (j5 % blockCount === 0) {
            f5(s4);
          }
        }
        if (extraBytes) {
          array[i5] = s4[i5];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j5 = 0;
        var array = [], offset, block;
        while (j5 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j5 < outputBlocks; ++i5, ++j5) {
            offset = j5 << 2;
            block = s4[i5];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j5 % blockCount === 0) {
            f5(s4);
          }
        }
        if (extraBytes) {
          offset = j5 << 2;
          block = s4[i5];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f5 = function(s4) {
        var h5, l5, n4, c02, c1, c22, c32, c4, c5, c6, c7, c8, c9, b02, b12, b22, b3, b4, b5, b6, b7, b8, b9, b10, b11, b122, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n4 = 0; n4 < 48; n4 += 2) {
          c02 = s4[0] ^ s4[10] ^ s4[20] ^ s4[30] ^ s4[40];
          c1 = s4[1] ^ s4[11] ^ s4[21] ^ s4[31] ^ s4[41];
          c22 = s4[2] ^ s4[12] ^ s4[22] ^ s4[32] ^ s4[42];
          c32 = s4[3] ^ s4[13] ^ s4[23] ^ s4[33] ^ s4[43];
          c4 = s4[4] ^ s4[14] ^ s4[24] ^ s4[34] ^ s4[44];
          c5 = s4[5] ^ s4[15] ^ s4[25] ^ s4[35] ^ s4[45];
          c6 = s4[6] ^ s4[16] ^ s4[26] ^ s4[36] ^ s4[46];
          c7 = s4[7] ^ s4[17] ^ s4[27] ^ s4[37] ^ s4[47];
          c8 = s4[8] ^ s4[18] ^ s4[28] ^ s4[38] ^ s4[48];
          c9 = s4[9] ^ s4[19] ^ s4[29] ^ s4[39] ^ s4[49];
          h5 = c8 ^ (c22 << 1 | c32 >>> 31);
          l5 = c9 ^ (c32 << 1 | c22 >>> 31);
          s4[0] ^= h5;
          s4[1] ^= l5;
          s4[10] ^= h5;
          s4[11] ^= l5;
          s4[20] ^= h5;
          s4[21] ^= l5;
          s4[30] ^= h5;
          s4[31] ^= l5;
          s4[40] ^= h5;
          s4[41] ^= l5;
          h5 = c02 ^ (c4 << 1 | c5 >>> 31);
          l5 = c1 ^ (c5 << 1 | c4 >>> 31);
          s4[2] ^= h5;
          s4[3] ^= l5;
          s4[12] ^= h5;
          s4[13] ^= l5;
          s4[22] ^= h5;
          s4[23] ^= l5;
          s4[32] ^= h5;
          s4[33] ^= l5;
          s4[42] ^= h5;
          s4[43] ^= l5;
          h5 = c22 ^ (c6 << 1 | c7 >>> 31);
          l5 = c32 ^ (c7 << 1 | c6 >>> 31);
          s4[4] ^= h5;
          s4[5] ^= l5;
          s4[14] ^= h5;
          s4[15] ^= l5;
          s4[24] ^= h5;
          s4[25] ^= l5;
          s4[34] ^= h5;
          s4[35] ^= l5;
          s4[44] ^= h5;
          s4[45] ^= l5;
          h5 = c4 ^ (c8 << 1 | c9 >>> 31);
          l5 = c5 ^ (c9 << 1 | c8 >>> 31);
          s4[6] ^= h5;
          s4[7] ^= l5;
          s4[16] ^= h5;
          s4[17] ^= l5;
          s4[26] ^= h5;
          s4[27] ^= l5;
          s4[36] ^= h5;
          s4[37] ^= l5;
          s4[46] ^= h5;
          s4[47] ^= l5;
          h5 = c6 ^ (c02 << 1 | c1 >>> 31);
          l5 = c7 ^ (c1 << 1 | c02 >>> 31);
          s4[8] ^= h5;
          s4[9] ^= l5;
          s4[18] ^= h5;
          s4[19] ^= l5;
          s4[28] ^= h5;
          s4[29] ^= l5;
          s4[38] ^= h5;
          s4[39] ^= l5;
          s4[48] ^= h5;
          s4[49] ^= l5;
          b02 = s4[0];
          b12 = s4[1];
          b32 = s4[11] << 4 | s4[10] >>> 28;
          b33 = s4[10] << 4 | s4[11] >>> 28;
          b14 = s4[20] << 3 | s4[21] >>> 29;
          b15 = s4[21] << 3 | s4[20] >>> 29;
          b46 = s4[31] << 9 | s4[30] >>> 23;
          b47 = s4[30] << 9 | s4[31] >>> 23;
          b28 = s4[40] << 18 | s4[41] >>> 14;
          b29 = s4[41] << 18 | s4[40] >>> 14;
          b20 = s4[2] << 1 | s4[3] >>> 31;
          b21 = s4[3] << 1 | s4[2] >>> 31;
          b22 = s4[13] << 12 | s4[12] >>> 20;
          b3 = s4[12] << 12 | s4[13] >>> 20;
          b34 = s4[22] << 10 | s4[23] >>> 22;
          b35 = s4[23] << 10 | s4[22] >>> 22;
          b16 = s4[33] << 13 | s4[32] >>> 19;
          b17 = s4[32] << 13 | s4[33] >>> 19;
          b48 = s4[42] << 2 | s4[43] >>> 30;
          b49 = s4[43] << 2 | s4[42] >>> 30;
          b40 = s4[5] << 30 | s4[4] >>> 2;
          b41 = s4[4] << 30 | s4[5] >>> 2;
          b222 = s4[14] << 6 | s4[15] >>> 26;
          b23 = s4[15] << 6 | s4[14] >>> 26;
          b4 = s4[25] << 11 | s4[24] >>> 21;
          b5 = s4[24] << 11 | s4[25] >>> 21;
          b36 = s4[34] << 15 | s4[35] >>> 17;
          b37 = s4[35] << 15 | s4[34] >>> 17;
          b18 = s4[45] << 29 | s4[44] >>> 3;
          b19 = s4[44] << 29 | s4[45] >>> 3;
          b10 = s4[6] << 28 | s4[7] >>> 4;
          b11 = s4[7] << 28 | s4[6] >>> 4;
          b42 = s4[17] << 23 | s4[16] >>> 9;
          b43 = s4[16] << 23 | s4[17] >>> 9;
          b24 = s4[26] << 25 | s4[27] >>> 7;
          b25 = s4[27] << 25 | s4[26] >>> 7;
          b6 = s4[36] << 21 | s4[37] >>> 11;
          b7 = s4[37] << 21 | s4[36] >>> 11;
          b38 = s4[47] << 24 | s4[46] >>> 8;
          b39 = s4[46] << 24 | s4[47] >>> 8;
          b30 = s4[8] << 27 | s4[9] >>> 5;
          b31 = s4[9] << 27 | s4[8] >>> 5;
          b122 = s4[18] << 20 | s4[19] >>> 12;
          b13 = s4[19] << 20 | s4[18] >>> 12;
          b44 = s4[29] << 7 | s4[28] >>> 25;
          b45 = s4[28] << 7 | s4[29] >>> 25;
          b26 = s4[38] << 8 | s4[39] >>> 24;
          b27 = s4[39] << 8 | s4[38] >>> 24;
          b8 = s4[48] << 14 | s4[49] >>> 18;
          b9 = s4[49] << 14 | s4[48] >>> 18;
          s4[0] = b02 ^ ~b22 & b4;
          s4[1] = b12 ^ ~b3 & b5;
          s4[10] = b10 ^ ~b122 & b14;
          s4[11] = b11 ^ ~b13 & b15;
          s4[20] = b20 ^ ~b222 & b24;
          s4[21] = b21 ^ ~b23 & b25;
          s4[30] = b30 ^ ~b32 & b34;
          s4[31] = b31 ^ ~b33 & b35;
          s4[40] = b40 ^ ~b42 & b44;
          s4[41] = b41 ^ ~b43 & b45;
          s4[2] = b22 ^ ~b4 & b6;
          s4[3] = b3 ^ ~b5 & b7;
          s4[12] = b122 ^ ~b14 & b16;
          s4[13] = b13 ^ ~b15 & b17;
          s4[22] = b222 ^ ~b24 & b26;
          s4[23] = b23 ^ ~b25 & b27;
          s4[32] = b32 ^ ~b34 & b36;
          s4[33] = b33 ^ ~b35 & b37;
          s4[42] = b42 ^ ~b44 & b46;
          s4[43] = b43 ^ ~b45 & b47;
          s4[4] = b4 ^ ~b6 & b8;
          s4[5] = b5 ^ ~b7 & b9;
          s4[14] = b14 ^ ~b16 & b18;
          s4[15] = b15 ^ ~b17 & b19;
          s4[24] = b24 ^ ~b26 & b28;
          s4[25] = b25 ^ ~b27 & b29;
          s4[34] = b34 ^ ~b36 & b38;
          s4[35] = b35 ^ ~b37 & b39;
          s4[44] = b44 ^ ~b46 & b48;
          s4[45] = b45 ^ ~b47 & b49;
          s4[6] = b6 ^ ~b8 & b02;
          s4[7] = b7 ^ ~b9 & b12;
          s4[16] = b16 ^ ~b18 & b10;
          s4[17] = b17 ^ ~b19 & b11;
          s4[26] = b26 ^ ~b28 & b20;
          s4[27] = b27 ^ ~b29 & b21;
          s4[36] = b36 ^ ~b38 & b30;
          s4[37] = b37 ^ ~b39 & b31;
          s4[46] = b46 ^ ~b48 & b40;
          s4[47] = b47 ^ ~b49 & b41;
          s4[8] = b8 ^ ~b02 & b22;
          s4[9] = b9 ^ ~b12 & b3;
          s4[18] = b18 ^ ~b10 & b122;
          s4[19] = b19 ^ ~b11 & b13;
          s4[28] = b28 ^ ~b20 & b222;
          s4[29] = b29 ^ ~b21 & b23;
          s4[38] = b38 ^ ~b30 & b32;
          s4[39] = b39 ^ ~b31 & b33;
          s4[48] = b48 ^ ~b40 & b42;
          s4[49] = b49 ^ ~b41 & b43;
          s4[0] ^= RC[n4];
          s4[1] ^= RC[n4 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i4 = 0; i4 < methodNames.length; ++i4) {
          root2[methodNames[i4]] = methods[methodNames[i4]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (window === null || window === void 0 ? void 0 : window.crypto) || (window === null || window === void 0 ? void 0 : window.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o4, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_crypto(), exports);
    __exportStar(require_env(), exports);
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x5) => `%${x5.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i4 = 1; i4 < tokens.length; i4++) {
          input = decodeComponents(tokens, i4).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i4 = 0; i4 < entries.length; i4++) {
        var key2 = entries[i4];
        input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key2) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key2, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key2, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key2, options), "[]"].join("")];
            }
            return [...result, [encode2(key2, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key2) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key2, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key2, options)];
            }
            return [...result, [encode2(key2, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key2, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key2);
            key2 = key2.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = {};
            }
            accumulator[key2][result[1]] = value;
          };
        case "bracket":
          return (key2, value, accumulator) => {
            result = /(\[\])$/.exec(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "comma":
        case "separator":
          return (key2, value, accumulator) => {
            const isArray4 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray4 ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key2] = newValue;
          };
        default:
          return (key2, value, accumulator) => {
            if (accumulator[key2] === void 0) {
              accumulator[key2] = value;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a4, b3) => Number(a4) - Number(b3)).map((key2) => input[key2]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse8(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key2, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key2, options), value, ret);
      }
      for (const key2 of Object.keys(ret)) {
        const value = ret[key2];
        if (typeof value === "object" && value !== null) {
          for (const k5 of Object.keys(value)) {
            value[k5] = parseValue(value[k5], options);
          }
        } else {
          ret[key2] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
        const value = ret[key2];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key2] = keysSorter(value);
        } else {
          result[key2] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse8;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key2) => options.skipNull && isNullOrUndefined2(object[key2]) || options.skipEmptyString && object[key2] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key2 of Object.keys(object)) {
        if (!shouldFilter(key2)) {
          objectCopy[key2] = object[key2];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key2) => {
        const value = object[key2];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key2, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key2), []).join("&");
        }
        return encode2(key2, options) + "=" + encode2(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse8(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 <<= 4;
          if (c4 >= 49 && c4 <= 54) {
            r5 |= c4 - 49 + 10;
          } else if (c4 >= 17 && c4 <= 22) {
            r5 |= c4 - 17 + 10;
          } else {
            r5 |= c4 & 15;
          }
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        for (i4 = number.length - 6, j4 = 0; i4 >= start; i4 -= 6) {
          w6 = parseHex(number, i4, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j4++;
          }
        }
        if (i4 + 6 !== start) {
          w6 = parseHex(number, start, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          r5.strip();
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 <<= 4;
          if (c4 >= 49 && c4 <= 54) {
            r5 |= c4 - 49 + 10;
          } else if (c4 >= 17 && c4 <= 22) {
            r5 |= c4 - 17 + 10;
          } else {
            r5 |= c4 & 15;
          }
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        for (i4 = number.length - 6, j4 = 0; i4 >= start; i4 -= 6) {
          w6 = parseHex(number, i4, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j4++;
          }
        }
        if (i4 + 6 !== start) {
          w6 = parseHex(number, start, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          r5.strip();
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/qrcode/node_modules/isarray/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var toString4 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString4.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var isArray4 = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e5) {
        return false;
      }
    }
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer4(arg, offset, length) {
      if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
        return new Buffer4(arg, offset, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe3(this, arg);
      }
      return from3(this, arg, offset, length);
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      Buffer4.prototype.__proto__ = Uint8Array.prototype;
      Buffer4.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) {
        Object.defineProperty(Buffer4, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked3(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan3(val) {
      return val !== val;
    }
    function createBuffer3(that, length) {
      var buf;
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer4.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer4(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe3(that, size) {
      var buf = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
      if (!Buffer4.TYPED_ARRAY_SUPPORT) {
        for (var i4 = 0; i4 < size; ++i4) {
          buf[i4] = 0;
        }
      }
      return buf;
    }
    function fromString3(that, string) {
      var length = byteLength3(string) | 0;
      var buf = createBuffer3(that, length);
      var actual = buf.write(string);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike3(that, array) {
      var length = array.length < 0 ? 0 : checked3(array.length) | 0;
      var buf = createBuffer3(that, length);
      for (var i4 = 0; i4 < length; i4 += 1) {
        buf[i4] = array[i4] & 255;
      }
      return buf;
    }
    function fromArrayBuffer3(that, array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer4.prototype;
      } else {
        buf = fromArrayLike3(that, buf);
      }
      return buf;
    }
    function fromObject3(that, obj) {
      if (Buffer4.isBuffer(obj)) {
        var len = checked3(obj.length) | 0;
        var buf = createBuffer3(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan3(obj.length)) {
            return createBuffer3(that, 0);
          }
          return fromArrayLike3(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike3(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes3(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i4 = 0; i4 < length; ++i4) {
        codePoint = string.charCodeAt(i4);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i4 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength3(string) {
      if (Buffer4.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      return utf8ToBytes3(string).length;
    }
    function blitBuffer3(src, dst, offset, length) {
      for (var i4 = 0; i4 < length; ++i4) {
        if (i4 + offset >= dst.length || i4 >= src.length)
          break;
        dst[i4 + offset] = src[i4];
      }
      return i4;
    }
    function utf8Write3(buf, string, offset, length) {
      return blitBuffer3(utf8ToBytes3(string, buf.length - offset), buf, offset, length);
    }
    function from3(that, value, offset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer3(that, value, offset, length);
      }
      if (typeof value === "string") {
        return fromString3(that, value, offset);
      }
      return fromObject3(that, value);
    }
    Buffer4.prototype.write = function write4(string, offset, length) {
      if (offset === void 0) {
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write3(this, string, offset, length);
    };
    Buffer4.prototype.slice = function slice3(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer4.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer4.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer4(sliceLen, void 0);
        for (var i4 = 0; i4 < sliceLen; ++i4) {
          newBuf[i4] = this[i4 + start];
        }
      }
      return newBuf;
    };
    Buffer4.prototype.copy = function copy3(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i4;
      if (this === target && start < targetStart && targetStart < end) {
        for (i4 = len - 1; i4 >= 0; --i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
        for (i4 = 0; i4 < len; ++i4) {
          target[i4 + targetStart] = this[i4 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill3(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        var bytes = Buffer4.isBuffer(val) ? val : new Buffer4(val);
        var len = bytes.length;
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    Buffer4.concat = function concat4(list, length) {
      if (!isArray4(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer3(null, 0);
      }
      var i4;
      if (length === void 0) {
        length = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length += list[i4].length;
        }
      }
      var buffer = allocUnsafe3(null, length);
      var pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        var buf = list[i4];
        if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer4.byteLength = byteLength3;
    Buffer4.prototype._isBuffer = true;
    Buffer4.isBuffer = function isBuffer5(b3) {
      return !!(b3 != null && b3._isBuffer);
    };
    module.exports.alloc = function(size) {
      var buffer = new Buffer4(size);
      buffer.fill(0);
      return buffer;
    };
    module.exports.from = function(data) {
      return new Buffer4(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version5) {
      if (!version5)
        throw new Error('"version" cannot be null or undefined');
      if (version5 < 1 || version5 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version5 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version5) {
      return CODEWORDS_COUNT[version5];
    };
    exports.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f5) {
      if (typeof f5 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f5;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString3(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i4 = 0; i4 < length; i4++) {
          this.putBit((num >>> length - i4 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version5) {
      if (version5 === 1)
        return [];
      var posCount = Math.floor(version5 / 7) + 2;
      var size = getSymbolSize(version5);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i4 = 1; i4 < posCount - 1; i4++) {
        positions[i4] = positions[i4 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version5) {
      var coords = [];
      var pos = exports.getRowColCoords(version5);
      var posLength = pos.length;
      for (var i4 = 0; i4 < posLength; i4++) {
        for (var j4 = 0; j4 < posLength; j4++) {
          if (i4 === 0 && j4 === 0 || i4 === 0 && j4 === posLength - 1 || i4 === posLength - 1 && j4 === 0) {
            continue;
          }
          coords.push([pos[i4], pos[j4]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version5) {
      var size = getSymbolSize(version5);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from3(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i4 = 0; i4 < modulesCount; i4++)
        darkCount += data.data[i4];
      var k5 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k5 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i4, j4) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i4 + j4) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i4 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j4 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i4 + j4) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i4 / 2) + Math.floor(j4 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i4 * j4 % 2 + i4 * j4 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i4 * j4 % 2 + i4 * j4 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i4 * j4 % 3 + (i4 + j4) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p5 = 0; p5 < numPatterns; p5++) {
        setupFormatFunc(p5);
        exports.applyMask(p5, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p5, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p5;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version5, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version5 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version5 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version5 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version5 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version5, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version5 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version5 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version5 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version5 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x5 = 1;
      for (var i4 = 0; i4 < 255; i4++) {
        EXP_TABLE[i4] = x5;
        LOG_TABLE[x5] = i4;
        x5 <<= 1;
        if (x5 & 256) {
          x5 ^= 285;
        }
      }
      for (i4 = 255; i4 < 512; i4++) {
        EXP_TABLE[i4] = EXP_TABLE[i4 - 255];
      }
    })();
    exports.log = function log2(n4) {
      if (n4 < 1)
        throw new Error("log(" + n4 + ")");
      return LOG_TABLE[n4];
    };
    exports.exp = function exp(n4) {
      return EXP_TABLE[n4];
    };
    exports.mul = function mul(x5, y5) {
      if (x5 === 0 || y5 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x5] + LOG_TABLE[y5]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports.mul = function mul(p12, p22) {
      var coeff = BufferUtil.alloc(p12.length + p22.length - 1);
      for (var i4 = 0; i4 < p12.length; i4++) {
        for (var j4 = 0; j4 < p22.length; j4++) {
          coeff[i4 + j4] ^= GF.mul(p12[i4], p22[j4]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i4 = 0; i4 < divisor.length; i4++) {
          result[i4] ^= GF.mul(divisor[i4], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i4 = 0; i4 < degree; i4++) {
        poly = exports.mul(poly, [1, GF.exp(i4)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer4 = require_buffer().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad2 = BufferUtil.alloc(this.degree);
      var paddedData = Buffer4.concat([data, pad2], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    exports.isValid = function isValid(version5) {
      return !isNaN(version5) && version5 >= 1 && version5 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version5) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version5)) {
        throw new Error("Invalid version: " + version5);
      }
      if (version5 >= 1 && version5 < 10)
        return mode.ccBits[0];
      else if (version5 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString4(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e5) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray4 = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version5) {
      return Mode.getCharCountIndicator(mode, version5) + 4;
    }
    function getTotalBitsFromDataArray(segments, version5) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version5);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from3(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version5, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version5)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version5);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version5, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version5);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray4(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version5) {
      if (!VersionCheck.isValid(version5) || version5 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d4 = version5 << 12;
      while (Utils.getBCHDigit(d4) - G18_BCH >= 0) {
        d4 ^= G18 << Utils.getBCHDigit(d4) - G18_BCH;
      }
      return version5 << 12 | d4;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d4 = data << 10;
      while (Utils.getBCHDigit(d4) - G15_BCH >= 0) {
        d4 ^= G15 << Utils.getBCHDigit(d4) - G15_BCH;
      }
      return (data << 10 | d4) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write4(bitBuffer) {
      var i4, group, value;
      for (i4 = 0; i4 + 3 <= this.data.length; i4 += 3) {
        group = this.data.substr(i4, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i4;
      if (remainingNum > 0) {
        group = this.data.substr(i4);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write4(bitBuffer) {
      var i4;
      for (i4 = 0; i4 + 2 <= this.data.length; i4 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i4]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i4 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i4]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i4 = 0, l5 = this.data.length; i4 < l5; i4++) {
        bitBuffer.put(this.data[i4], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i4;
      for (i4 = 0; i4 < this.data.length; i4++) {
        var value = Utils.toSJIS(this.data[i4]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i4] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var dijkstra = {
      single_source_shortest_paths: function(graph, s4, d4) {
        var predecessors = {};
        var costs = {};
        costs[s4] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s4, 0);
        var closest, u5, v5, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u5 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u5] || {};
          for (v5 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v5)) {
              cost_of_e = adjacent_nodes[v5];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v5];
              first_visit = typeof costs[v5] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v5] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v5, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v5] = u5;
              }
            }
          }
        }
        if (typeof d4 !== "undefined" && typeof costs[d4] === "undefined") {
          var msg = ["Could not find a path from ", s4, " to ", d4, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d4) {
        var nodes = [];
        var u5 = d4;
        var predecessor;
        while (u5) {
          nodes.push(u5);
          predecessor = predecessors[u5];
          u5 = predecessors[u5];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s4, d4) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s4, d4);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d4
        );
      },
      PriorityQueue: {
        make: function(opts) {
          var T5 = dijkstra.PriorityQueue, t5 = {}, key2;
          opts = opts || {};
          for (key2 in T5) {
            if (T5.hasOwnProperty(key2)) {
              t5[key2] = T5[key2];
            }
          }
          t5.queue = [];
          t5.sorter = opts.sorter || T5.default_sorter;
          return t5;
        },
        default_sorter: function(a4, b3) {
          return a4.cost - b3.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode, str) {
      var segments = [];
      var result;
      while ((result = regex2.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s12, s22) {
        return s12.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i4 = 0; i4 < segs.length; i4++) {
        var seg = segs[i4];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version5) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i4 = 0; i4 < nodes.length; i4++) {
        var nodeGroup = nodes[i4];
        var currentNodeIds = [];
        for (var j4 = 0; j4 < nodeGroup.length; j4++) {
          var node = nodeGroup[j4];
          var key2 = "" + i4 + j4;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (var n4 = 0; n4 < prevNodeIds.length; n4++) {
            var prevNodeId = prevNodeIds[n4];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version5);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n4 = 0; n4 < prevNodeIds.length; n4++) {
        graph[prevNodeIds[n4]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString3(data, version5) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version5);
      var path2 = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i4 = 1; i4 < path2.length - 1; i4++) {
        optimizedSegs.push(graph.table[path2[i4]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray4 = require_isarray();
    function setupFinderPattern(matrix, version5) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version5);
      for (var i4 = 0; i4 < pos.length; i4++) {
        var row = pos[i4][0];
        var col = pos[i4][1];
        for (var r5 = -1; r5 <= 7; r5++) {
          if (row + r5 <= -1 || size <= row + r5)
            continue;
          for (var c4 = -1; c4 <= 7; c4++) {
            if (col + c4 <= -1 || size <= col + c4)
              continue;
            if (r5 >= 0 && r5 <= 6 && (c4 === 0 || c4 === 6) || c4 >= 0 && c4 <= 6 && (r5 === 0 || r5 === 6) || r5 >= 2 && r5 <= 4 && c4 >= 2 && c4 <= 4) {
              matrix.set(row + r5, col + c4, true, true);
            } else {
              matrix.set(row + r5, col + c4, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r5 = 8; r5 < size - 8; r5++) {
        var value = r5 % 2 === 0;
        matrix.set(r5, 6, value, true);
        matrix.set(6, r5, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version5) {
      var pos = AlignmentPattern.getPositions(version5);
      for (var i4 = 0; i4 < pos.length; i4++) {
        var row = pos[i4][0];
        var col = pos[i4][1];
        for (var r5 = -2; r5 <= 2; r5++) {
          for (var c4 = -2; c4 <= 2; c4++) {
            if (r5 === -2 || r5 === 2 || c4 === -2 || c4 === 2 || r5 === 0 && c4 === 0) {
              matrix.set(row + r5, col + c4, true, true);
            } else {
              matrix.set(row + r5, col + c4, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version5) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version5);
      var row, col, mod;
      for (var i4 = 0; i4 < 18; i4++) {
        row = Math.floor(i4 / 3);
        col = i4 % 3 + size - 8 - 3;
        mod = (bits >> i4 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i4, mod;
      for (i4 = 0; i4 < 15; i4++) {
        mod = (bits >> i4 & 1) === 1;
        if (i4 < 6) {
          matrix.set(i4, 8, mod, true);
        } else if (i4 < 8) {
          matrix.set(i4 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i4, 8, mod, true);
        }
        if (i4 < 8) {
          matrix.set(8, size - i4 - 1, mod, true);
        } else if (i4 < 9) {
          matrix.set(8, 15 - i4 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i4 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c4 = 0; c4 < 2; c4++) {
            if (!matrix.isReserved(row, col - c4)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c4, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version5, errorCorrectionLevel, segments) {
      var buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version5));
        data.write(buffer);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version5);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version5, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (var i4 = 0; i4 < remainingByte; i4++) {
        buffer.put(i4 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version5, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version5, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version5);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version5, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version5, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs2 = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer = BufferUtil.from(bitBuffer.buffer);
      for (var b3 = 0; b3 < ecTotalBlocks; b3++) {
        var dataSize = b3 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b3] = buffer.slice(offset, offset + dataSize);
        ecData[b3] = rs2.encode(dcData[b3]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i4, r5;
      for (i4 = 0; i4 < maxDataSize; i4++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          if (i4 < dcData[r5].length) {
            data[index++] = dcData[r5][i4];
          }
        }
      }
      for (i4 = 0; i4 < ecCount; i4++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          data[index++] = ecData[r5][i4];
        }
      }
      return data;
    }
    function createSymbol(data, version5, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray4(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version5;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version5) {
        version5 = bestVersion;
      } else if (version5 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      var dataBits = createData(version5, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version5);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version5);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version5);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version5 >= 7) {
        setupVersionInfo(modules, version5);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version5,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version5;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version5 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version5, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c4) {
          return [c4, c4];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i4 = 0; i4 < symbolSize; i4++) {
        for (var j4 = 0; j4 < symbolSize; j4++) {
          var posDst = (i4 * symbolSize + j4) * 4;
          var pxColor = opts.color.light;
          if (i4 >= scaledMargin && j4 >= scaledMargin && i4 < symbolSize - scaledMargin && j4 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i4 - scaledMargin) / scale);
            var jSrc = Math.floor((j4 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e5) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type2 = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type2, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x5, y5) {
      var str = cmd + x5;
      if (typeof y5 !== "undefined")
        str += " " + y5;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path2 = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i4 = 0; i4 < data.length; i4++) {
        var col = Math.floor(i4 % size);
        var row = Math.floor(i4 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i4]) {
          lineLength++;
          if (!(i4 > 0 && col > 0 && data[i4 - 1])) {
            path2 += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i4 + 1])) {
            path2 += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path2;
    }
    exports.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path2 = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path2 + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e5) {
            reject(e5);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e5) {
        cb(e5);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _5, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i4 = 0; i4 < selection.rangeCount; i4++) {
        ranges.push(selection.getRangeAt(i4));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format3(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text, options) {
      var debug2, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug2 = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e5) {
          e5.stopPropagation();
          if (options.format) {
            e5.preventDefault();
            if (typeof e5.clipboardData === "undefined") {
              debug2 && console.warn("unable to use e.clipboardData");
              debug2 && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format4 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format4, text);
            } else {
              e5.clipboardData.clearData();
              e5.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e5.preventDefault();
            options.onCopy(e5.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug2 && console.error("unable to copy using execCommand: ", err);
        debug2 && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug2 && console.error("unable to copy using clipboardData: ", err2);
          debug2 && console.error("falling back to prompt");
          message = format3("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/preact/dist/preact.module.js
function a(n4, l5) {
  for (var u5 in l5)
    n4[u5] = l5[u5];
  return n4;
}
function v(n4) {
  var l5 = n4.parentNode;
  l5 && l5.removeChild(n4);
}
function h(n4, l5, u5) {
  var i4, t5 = arguments, r5 = {};
  for (i4 in l5)
    "key" !== i4 && "ref" !== i4 && (r5[i4] = l5[i4]);
  if (arguments.length > 3)
    for (u5 = [u5], i4 = 3; i4 < arguments.length; i4++)
      u5.push(t5[i4]);
  if (null != u5 && (r5.children = u5), "function" == typeof n4 && null != n4.defaultProps)
    for (i4 in n4.defaultProps)
      void 0 === r5[i4] && (r5[i4] = n4.defaultProps[i4]);
  return p(n4, r5, l5 && l5.key, l5 && l5.ref, null);
}
function p(l5, u5, i4, t5, r5) {
  var o4 = { type: l5, props: u5, key: i4, ref: t5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r5 };
  return null == r5 && (o4.__v = o4), n.vnode && n.vnode(o4), o4;
}
function y() {
  return {};
}
function d(n4) {
  return n4.children;
}
function m(n4, l5) {
  this.props = n4, this.context = l5;
}
function w(n4, l5) {
  if (null == l5)
    return n4.__ ? w(n4.__, n4.__.__k.indexOf(n4) + 1) : null;
  for (var u5; l5 < n4.__k.length; l5++)
    if (null != (u5 = n4.__k[l5]) && null != u5.__e)
      return u5.__e;
  return "function" == typeof n4.type ? w(n4) : null;
}
function k(n4) {
  var l5, u5;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l5 = 0; l5 < n4.__k.length; l5++)
      if (null != (u5 = n4.__k[l5]) && null != u5.__e) {
        n4.__e = n4.__c.base = u5.__e;
        break;
      }
    return k(n4);
  }
}
function g(l5) {
  (!l5.__d && (l5.__d = true) && u.push(l5) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);
}
function _() {
  for (var n4; i = u.length; )
    n4 = u.sort(function(n5, l5) {
      return n5.__v.__b - l5.__v.__b;
    }), u = [], n4.some(function(n5) {
      var l5, u5, i4, t5, r5, o4, f5;
      n5.__d && (o4 = (r5 = (l5 = n5).__v).__e, (f5 = l5.__P) && (u5 = [], (i4 = a({}, r5)).__v = i4, t5 = A(f5, r5, i4, l5.__n, void 0 !== f5.ownerSVGElement, null, u5, null == o4 ? w(r5) : o4), T(u5, r5), t5 != o4 && k(r5)));
    });
}
function b(n4, l5, u5, i4, t5, r5, o4, f5, s4) {
  var a4, h5, p5, y5, d4, m5, k5, g4 = u5 && u5.__k || c, _5 = g4.length;
  if (f5 == e && (f5 = null != r5 ? r5[0] : _5 ? w(u5, 0) : null), a4 = 0, l5.__k = x(l5.__k, function(u6) {
    if (null != u6) {
      if (u6.__ = l5, u6.__b = l5.__b + 1, null === (p5 = g4[a4]) || p5 && u6.key == p5.key && u6.type === p5.type)
        g4[a4] = void 0;
      else
        for (h5 = 0; h5 < _5; h5++) {
          if ((p5 = g4[h5]) && u6.key == p5.key && u6.type === p5.type) {
            g4[h5] = void 0;
            break;
          }
          p5 = null;
        }
      if (y5 = A(n4, u6, p5 = p5 || e, i4, t5, r5, o4, f5, s4), (h5 = u6.ref) && p5.ref != h5 && (k5 || (k5 = []), p5.ref && k5.push(p5.ref, null, u6), k5.push(h5, u6.__c || y5, u6)), null != y5) {
        var c4;
        if (null == m5 && (m5 = y5), void 0 !== u6.__d)
          c4 = u6.__d, u6.__d = void 0;
        else if (r5 == p5 || y5 != f5 || null == y5.parentNode) {
          n:
            if (null == f5 || f5.parentNode !== n4)
              n4.appendChild(y5), c4 = null;
            else {
              for (d4 = f5, h5 = 0; (d4 = d4.nextSibling) && h5 < _5; h5 += 2)
                if (d4 == y5)
                  break n;
              n4.insertBefore(y5, f5), c4 = f5;
            }
          "option" == l5.type && (n4.value = "");
        }
        f5 = void 0 !== c4 ? c4 : y5.nextSibling, "function" == typeof l5.type && (l5.__d = f5);
      } else
        f5 && p5.__e == f5 && f5.parentNode != n4 && (f5 = w(p5));
    }
    return a4++, u6;
  }), l5.__e = m5, null != r5 && "function" != typeof l5.type)
    for (a4 = r5.length; a4--; )
      null != r5[a4] && v(r5[a4]);
  for (a4 = _5; a4--; )
    null != g4[a4] && D(g4[a4], g4[a4]);
  if (k5)
    for (a4 = 0; a4 < k5.length; a4++)
      j(k5[a4], k5[++a4], k5[++a4]);
}
function x(n4, l5, u5) {
  if (null == u5 && (u5 = []), null == n4 || "boolean" == typeof n4)
    l5 && u5.push(l5(null));
  else if (Array.isArray(n4))
    for (var i4 = 0; i4 < n4.length; i4++)
      x(n4[i4], l5, u5);
  else
    u5.push(l5 ? l5("string" == typeof n4 || "number" == typeof n4 ? p(null, n4, null, null, n4) : null != n4.__e || null != n4.__c ? p(n4.type, n4.props, n4.key, null, n4.__v) : n4) : n4);
  return u5;
}
function P(n4, l5, u5, i4, t5) {
  var r5;
  for (r5 in u5)
    "children" === r5 || "key" === r5 || r5 in l5 || N(n4, r5, null, u5[r5], i4);
  for (r5 in l5)
    t5 && "function" != typeof l5[r5] || "children" === r5 || "key" === r5 || "value" === r5 || "checked" === r5 || u5[r5] === l5[r5] || N(n4, r5, l5[r5], u5[r5], i4);
}
function C(n4, l5, u5) {
  "-" === l5[0] ? n4.setProperty(l5, u5) : n4[l5] = "number" == typeof u5 && false === s.test(l5) ? u5 + "px" : null == u5 ? "" : u5;
}
function N(n4, l5, u5, i4, t5) {
  var r5, o4, f5, e5, c4;
  if (t5 ? "className" === l5 && (l5 = "class") : "class" === l5 && (l5 = "className"), "style" === l5)
    if (r5 = n4.style, "string" == typeof u5)
      r5.cssText = u5;
    else {
      if ("string" == typeof i4 && (r5.cssText = "", i4 = null), i4)
        for (e5 in i4)
          u5 && e5 in u5 || C(r5, e5, "");
      if (u5)
        for (c4 in u5)
          i4 && u5[c4] === i4[c4] || C(r5, c4, u5[c4]);
    }
  else
    "o" === l5[0] && "n" === l5[1] ? (o4 = l5 !== (l5 = l5.replace(/Capture$/, "")), f5 = l5.toLowerCase(), l5 = (f5 in n4 ? f5 : l5).slice(2), u5 ? (i4 || n4.addEventListener(l5, z, o4), (n4.l || (n4.l = {}))[l5] = u5) : n4.removeEventListener(l5, z, o4)) : "list" !== l5 && "tagName" !== l5 && "form" !== l5 && "type" !== l5 && "size" !== l5 && !t5 && l5 in n4 ? n4[l5] = null == u5 ? "" : u5 : "function" != typeof u5 && "dangerouslySetInnerHTML" !== l5 && (l5 !== (l5 = l5.replace(/^xlink:?/, "")) ? null == u5 || false === u5 ? n4.removeAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase()) : n4.setAttributeNS("http://www.w3.org/1999/xlink", l5.toLowerCase(), u5) : null == u5 || false === u5 && !/^ar/.test(l5) ? n4.removeAttribute(l5) : n4.setAttribute(l5, u5));
}
function z(l5) {
  this.l[l5.type](n.event ? n.event(l5) : l5);
}
function A(l5, u5, i4, t5, r5, o4, f5, e5, c4) {
  var s4, v5, h5, p5, y5, w6, k5, g4, _5, x5, P4 = u5.type;
  if (void 0 !== u5.constructor)
    return null;
  (s4 = n.__b) && s4(u5);
  try {
    n:
      if ("function" == typeof P4) {
        if (g4 = u5.props, _5 = (s4 = P4.contextType) && t5[s4.__c], x5 = s4 ? _5 ? _5.props.value : s4.__ : t5, i4.__c ? k5 = (v5 = u5.__c = i4.__c).__ = v5.__E : ("prototype" in P4 && P4.prototype.render ? u5.__c = v5 = new P4(g4, x5) : (u5.__c = v5 = new m(g4, x5), v5.constructor = P4, v5.render = E), _5 && _5.sub(v5), v5.props = g4, v5.state || (v5.state = {}), v5.context = x5, v5.__n = t5, h5 = v5.__d = true, v5.__h = []), null == v5.__s && (v5.__s = v5.state), null != P4.getDerivedStateFromProps && (v5.__s == v5.state && (v5.__s = a({}, v5.__s)), a(v5.__s, P4.getDerivedStateFromProps(g4, v5.__s))), p5 = v5.props, y5 = v5.state, h5)
          null == P4.getDerivedStateFromProps && null != v5.componentWillMount && v5.componentWillMount(), null != v5.componentDidMount && v5.__h.push(v5.componentDidMount);
        else {
          if (null == P4.getDerivedStateFromProps && g4 !== p5 && null != v5.componentWillReceiveProps && v5.componentWillReceiveProps(g4, x5), !v5.__e && null != v5.shouldComponentUpdate && false === v5.shouldComponentUpdate(g4, v5.__s, x5) || u5.__v === i4.__v && !v5.__) {
            for (v5.props = g4, v5.state = v5.__s, u5.__v !== i4.__v && (v5.__d = false), v5.__v = u5, u5.__e = i4.__e, u5.__k = i4.__k, v5.__h.length && f5.push(v5), s4 = 0; s4 < u5.__k.length; s4++)
              u5.__k[s4] && (u5.__k[s4].__ = u5);
            break n;
          }
          null != v5.componentWillUpdate && v5.componentWillUpdate(g4, v5.__s, x5), null != v5.componentDidUpdate && v5.__h.push(function() {
            v5.componentDidUpdate(p5, y5, w6);
          });
        }
        v5.context = x5, v5.props = g4, v5.state = v5.__s, (s4 = n.__r) && s4(u5), v5.__d = false, v5.__v = u5, v5.__P = l5, s4 = v5.render(v5.props, v5.state, v5.context), u5.__k = null != s4 && s4.type == d && null == s4.key ? s4.props.children : Array.isArray(s4) ? s4 : [s4], null != v5.getChildContext && (t5 = a(a({}, t5), v5.getChildContext())), h5 || null == v5.getSnapshotBeforeUpdate || (w6 = v5.getSnapshotBeforeUpdate(p5, y5)), b(l5, u5, i4, t5, r5, o4, f5, e5, c4), v5.base = u5.__e, v5.__h.length && f5.push(v5), k5 && (v5.__E = v5.__ = null), v5.__e = false;
      } else
        null == o4 && u5.__v === i4.__v ? (u5.__k = i4.__k, u5.__e = i4.__e) : u5.__e = $(i4.__e, u5, i4, t5, r5, o4, f5, c4);
    (s4 = n.diffed) && s4(u5);
  } catch (l6) {
    u5.__v = null, n.__e(l6, u5, i4);
  }
  return u5.__e;
}
function T(l5, u5) {
  n.__c && n.__c(u5, l5), l5.some(function(u6) {
    try {
      l5 = u6.__h, u6.__h = [], l5.some(function(n4) {
        n4.call(u6);
      });
    } catch (l6) {
      n.__e(l6, u6.__v);
    }
  });
}
function $(n4, l5, u5, i4, t5, r5, o4, f5) {
  var s4, a4, v5, h5, p5, y5 = u5.props, d4 = l5.props;
  if (t5 = "svg" === l5.type || t5, null != r5) {
    for (s4 = 0; s4 < r5.length; s4++)
      if (null != (a4 = r5[s4]) && ((null === l5.type ? 3 === a4.nodeType : a4.localName === l5.type) || n4 == a4)) {
        n4 = a4, r5[s4] = null;
        break;
      }
  }
  if (null == n4) {
    if (null === l5.type)
      return document.createTextNode(d4);
    n4 = t5 ? document.createElementNS("http://www.w3.org/2000/svg", l5.type) : document.createElement(l5.type, d4.is && { is: d4.is }), r5 = null, f5 = false;
  }
  if (null === l5.type)
    y5 !== d4 && n4.data != d4 && (n4.data = d4);
  else {
    if (null != r5 && (r5 = c.slice.call(n4.childNodes)), v5 = (y5 = u5.props || e).dangerouslySetInnerHTML, h5 = d4.dangerouslySetInnerHTML, !f5) {
      if (y5 === e)
        for (y5 = {}, p5 = 0; p5 < n4.attributes.length; p5++)
          y5[n4.attributes[p5].name] = n4.attributes[p5].value;
      (h5 || v5) && (h5 && v5 && h5.__html == v5.__html || (n4.innerHTML = h5 && h5.__html || ""));
    }
    P(n4, d4, y5, t5, f5), h5 ? l5.__k = [] : (l5.__k = l5.props.children, b(n4, l5, u5, i4, "foreignObject" !== l5.type && t5, r5, o4, e, f5)), f5 || ("value" in d4 && void 0 !== (s4 = d4.value) && s4 !== n4.value && N(n4, "value", s4, y5.value, false), "checked" in d4 && void 0 !== (s4 = d4.checked) && s4 !== n4.checked && N(n4, "checked", s4, y5.checked, false));
  }
  return n4;
}
function j(l5, u5, i4) {
  try {
    "function" == typeof l5 ? l5(u5) : l5.current = u5;
  } catch (l6) {
    n.__e(l6, i4);
  }
}
function D(l5, u5, i4) {
  var t5, r5, o4;
  if (n.unmount && n.unmount(l5), (t5 = l5.ref) && (t5.current && t5.current !== l5.__e || j(t5, null, u5)), i4 || "function" == typeof l5.type || (i4 = null != (r5 = l5.__e)), l5.__e = l5.__d = void 0, null != (t5 = l5.__c)) {
    if (t5.componentWillUnmount)
      try {
        t5.componentWillUnmount();
      } catch (l6) {
        n.__e(l6, u5);
      }
    t5.base = t5.__P = null;
  }
  if (t5 = l5.__k)
    for (o4 = 0; o4 < t5.length; o4++)
      t5[o4] && D(t5[o4], u5, i4);
  null != r5 && v(r5);
}
function E(n4, l5, u5) {
  return this.constructor(n4, u5);
}
function H(l5, u5, i4) {
  var t5, r5, f5;
  n.__ && n.__(l5, u5), r5 = (t5 = i4 === o) ? null : i4 && i4.__k || u5.__k, l5 = h(d, null, [l5]), f5 = [], A(u5, (t5 ? u5 : i4 || u5).__k = l5, r5 || e, e, void 0 !== u5.ownerSVGElement, i4 && !t5 ? [i4] : r5 ? null : c.slice.call(u5.childNodes), f5, i4 || e, t5), T(f5, l5);
}
function I(n4, l5) {
  H(n4, l5, o);
}
function L(n4, l5) {
  var u5, i4;
  for (i4 in l5 = a(a({}, n4.props), l5), arguments.length > 2 && (l5.children = c.slice.call(arguments, 2)), u5 = {}, l5)
    "key" !== i4 && "ref" !== i4 && (u5[i4] = l5[i4]);
  return p(n4.type, u5, l5.key || n4.key, l5.ref || n4.ref, null);
}
function M(n4) {
  var l5 = {}, u5 = { __c: "__cC" + f++, __: n4, Consumer: function(n5, l6) {
    return n5.children(l6);
  }, Provider: function(n5) {
    var i4, t5 = this;
    return this.getChildContext || (i4 = [], this.getChildContext = function() {
      return l5[u5.__c] = t5, l5;
    }, this.shouldComponentUpdate = function(n6) {
      t5.props.value !== n6.value && i4.some(function(l6) {
        l6.context = n6.value, g(l6);
      });
    }, this.sub = function(n6) {
      i4.push(n6);
      var l6 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        i4.splice(i4.indexOf(n6), 1), l6 && l6.call(n6);
      };
    }), n5.children;
  } };
  return u5.Consumer.contextType = u5, u5.Provider.__ = u5, u5;
}
var n, l, u, i, t, r, o, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n = { __e: function(n4, l5) {
      for (var u5, i4; l5 = l5.__; )
        if ((u5 = l5.__c) && !u5.__)
          try {
            if (u5.constructor && null != u5.constructor.getDerivedStateFromError && (i4 = true, u5.setState(u5.constructor.getDerivedStateFromError(n4))), null != u5.componentDidCatch && (i4 = true, u5.componentDidCatch(n4)), i4)
              return g(u5.__E = u5);
          } catch (l6) {
            n4 = l6;
          }
      throw n4;
    } }, l = function(n4) {
      return null != n4 && void 0 === n4.constructor;
    }, m.prototype.setState = function(n4, l5) {
      var u5;
      u5 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n4 && (n4 = n4(u5, this.props)), n4 && a(u5, n4), null != n4 && this.__v && (l5 && this.__h.push(l5), g(this));
    }, m.prototype.forceUpdate = function(n4) {
      this.__v && (this.__e = true, n4 && this.__h.push(n4), g(this));
    }, m.prototype.render = d, u = [], i = 0, t = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function v2(t5, r5) {
  n.__h && n.__h(u2, t5, i2 || r5), i2 = 0;
  var o4 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t5 >= o4.__.length && o4.__.push({}), o4.__[t5];
}
function m2(n4) {
  return i2 = 1, p2(E2, n4);
}
function p2(n4, r5, i4) {
  var o4 = v2(t2++, 2);
  return o4.__c || (o4.__c = u2, o4.__ = [i4 ? i4(r5) : E2(void 0, r5), function(t5) {
    var u5 = n4(o4.__[0], t5);
    o4.__[0] !== u5 && (o4.__[0] = u5, o4.__c.setState({}));
  }]), o4.__;
}
function l2(r5, i4) {
  var o4 = v2(t2++, 3);
  !n.__s && x2(o4.__H, i4) && (o4.__ = r5, o4.__H = i4, u2.__H.__h.push(o4));
}
function y2(r5, i4) {
  var o4 = v2(t2++, 4);
  !n.__s && x2(o4.__H, i4) && (o4.__ = r5, o4.__H = i4, u2.__h.push(o4));
}
function d2(n4) {
  return i2 = 5, h2(function() {
    return { current: n4 };
  }, []);
}
function s2(n4, t5, u5) {
  i2 = 6, y2(function() {
    "function" == typeof n4 ? n4(t5()) : n4 && (n4.current = t5());
  }, null == u5 ? u5 : u5.concat(n4));
}
function h2(n4, u5) {
  var r5 = v2(t2++, 7);
  return x2(r5.__H, u5) ? (r5.__H = u5, r5.__h = n4, r5.__ = n4()) : r5.__;
}
function T2(n4, t5) {
  return i2 = 8, h2(function() {
    return n4;
  }, t5);
}
function w2(n4) {
  var r5 = u2.context[n4.__c], i4 = v2(t2++, 9);
  return i4.__c = n4, r5 ? (null == i4.__ && (i4.__ = true, r5.sub(u2)), r5.props.value) : n4.__;
}
function A2(t5, u5) {
  n.useDebugValue && n.useDebugValue(u5 ? u5(t5) : t5);
}
function F(n4) {
  var r5 = v2(t2++, 10), i4 = m2();
  return r5.__ = n4, u2.componentDidCatch || (u2.componentDidCatch = function(n5) {
    r5.__ && r5.__(n5), i4[1](n5);
  }), [i4[0], function() {
    i4[1](void 0);
  }];
}
function _2() {
  o2.some(function(t5) {
    if (t5.__P)
      try {
        t5.__H.__h.forEach(g2), t5.__H.__h.forEach(q), t5.__H.__h = [];
      } catch (u5) {
        return t5.__H.__h = [], n.__e(u5, t5.__v), true;
      }
  }), o2 = [];
}
function g2(n4) {
  n4.t && n4.t();
}
function q(n4) {
  var t5 = n4.__();
  "function" == typeof t5 && (n4.t = t5);
}
function x2(n4, t5) {
  return !n4 || t5.some(function(t6, u5) {
    return t6 !== n4[u5];
  });
}
function E2(n4, t5) {
  return "function" == typeof t5 ? t5(n4) : t5;
}
var t2, u2, r2, i2, o2, c2, f2, e2, a2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_preact_module();
    i2 = 0;
    o2 = [];
    c2 = n.__r;
    f2 = n.diffed;
    e2 = n.__c;
    a2 = n.unmount;
    n.__r = function(n4) {
      c2 && c2(n4), t2 = 0, (u2 = n4.__c).__H && (u2.__H.__h.forEach(g2), u2.__H.__h.forEach(q), u2.__H.__h = []);
    }, n.diffed = function(t5) {
      f2 && f2(t5);
      var u5 = t5.__c;
      if (u5) {
        var i4 = u5.__H;
        i4 && i4.__h.length && (1 !== o2.push(u5) && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n4) {
          var t6, u6 = function() {
            clearTimeout(r5), cancelAnimationFrame(t6), setTimeout(n4);
          }, r5 = setTimeout(u6, 100);
          "undefined" != typeof window && (t6 = requestAnimationFrame(u6));
        })(_2));
      }
    }, n.__c = function(t5, u5) {
      u5.some(function(t6) {
        try {
          t6.__h.forEach(g2), t6.__h = t6.__h.filter(function(n4) {
            return !n4.__ || q(n4);
          });
        } catch (r5) {
          u5.some(function(n4) {
            n4.__h && (n4.__h = []);
          }), u5 = [], n.__e(r5, t6.__v);
        }
      }), e2 && e2(t5, u5);
    }, n.unmount = function(t5) {
      a2 && a2(t5);
      var u5 = t5.__c;
      if (u5) {
        var r5 = u5.__H;
        if (r5)
          try {
            r5.__.forEach(function(n4) {
              return n4.t && n4.t();
            });
          } catch (t6) {
            n.__e(t6, u5.__v);
          }
      }
    };
  }
});

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R,
  Component: () => m,
  Fragment: () => d,
  PureComponent: () => C2,
  Suspense: () => U,
  SuspenseList: () => O,
  cloneElement: () => K,
  createContext: () => M,
  createElement: () => h,
  createFactory: () => G,
  createPortal: () => z2,
  createRef: () => y,
  default: () => compat_module_default,
  findDOMNode: () => X,
  forwardRef: () => S,
  hydrate: () => V,
  isValidElement: () => J,
  lazy: () => L2,
  memo: () => _3,
  render: () => T3,
  unmountComponentAtNode: () => Q,
  unstable_batchedUpdates: () => Y,
  useCallback: () => T2,
  useContext: () => w2,
  useDebugValue: () => A2,
  useEffect: () => l2,
  useErrorBoundary: () => F,
  useImperativeHandle: () => s2,
  useLayoutEffect: () => y2,
  useMemo: () => h2,
  useReducer: () => p2,
  useRef: () => d2,
  useState: () => m2,
  version: () => B
});
function E3(n4, t5) {
  for (var e5 in t5)
    n4[e5] = t5[e5];
  return n4;
}
function w3(n4, t5) {
  for (var e5 in n4)
    if ("__source" !== e5 && !(e5 in t5))
      return true;
  for (var r5 in t5)
    if ("__source" !== r5 && n4[r5] !== t5[r5])
      return true;
  return false;
}
function _3(n4, t5) {
  function e5(n5) {
    var e6 = this.props.ref, r6 = e6 == n5.ref;
    return !r6 && e6 && (e6.call ? e6(null) : e6.current = null), t5 ? !t5(this.props, n5) || !r6 : w3(this.props, n5);
  }
  function r5(t6) {
    return this.shouldComponentUpdate = e5, h(n4, E3({}, t6));
  }
  return r5.prototype.isReactComponent = true, r5.displayName = "Memo(" + (n4.displayName || n4.name) + ")", r5.t = true, r5;
}
function S(n4) {
  function t5(t6) {
    var e5 = E3({}, t6);
    return delete e5.ref, n4(e5, t6.ref);
  }
  return t5.prototype.isReactComponent = t5.t = true, t5.displayName = "ForwardRef(" + (n4.displayName || n4.name) + ")", t5;
}
function N2(n4) {
  return n4 && ((n4 = E3({}, n4)).__c = null, n4.__k = n4.__k && n4.__k.map(N2)), n4;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M2(n4) {
  var t5 = n4.__.__c;
  return t5 && t5.u && t5.u(n4);
}
function L2(n4) {
  var t5, e5, r5;
  function o4(o5) {
    if (t5 || (t5 = n4()).then(function(n5) {
      e5 = n5.default || n5;
    }, function(n5) {
      r5 = n5;
    }), r5)
      throw r5;
    if (!e5)
      throw t5;
    return h(e5, o5);
  }
  return o4.displayName = "Lazy", o4.t = true, o4;
}
function O() {
  this.i = null, this.l = null;
}
function j2(n4) {
  var t5 = this, e5 = n4.container, r5 = h(W, { context: t5.context }, n4.vnode);
  return t5.s && t5.s !== e5 && (t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h), t5.p = false), n4.vnode ? t5.p ? (e5.__k = t5.__k, H(r5, e5), t5.__k = e5.__k) : (t5.v = document.createTextNode(""), I("", e5), e5.appendChild(t5.v), t5.p = true, t5.s = e5, H(r5, e5, t5.v), t5.__k = t5.v.__k) : t5.p && (t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h)), t5.h = r5, t5.componentWillUnmount = function() {
    t5.v.parentNode && t5.s.removeChild(t5.v), D(t5.h);
  }, null;
}
function z2(n4, t5) {
  return h(j2, { vnode: n4, container: t5 });
}
function T3(n4, t5, e5) {
  if (null == t5.__k)
    for (; t5.firstChild; )
      t5.removeChild(t5.firstChild);
  return H(n4, t5), "function" == typeof e5 && e5(), n4 ? n4.__c : null;
}
function V(n4, t5, e5) {
  return I(n4, t5), "function" == typeof e5 && e5(), n4 ? n4.__c : null;
}
function I2(n4, t5) {
  n4["UNSAFE_" + t5] && !n4[t5] && Object.defineProperty(n4, t5, { configurable: false, get: function() {
    return this["UNSAFE_" + t5];
  }, set: function(n5) {
    this["UNSAFE_" + t5] = n5;
  } });
}
function G(n4) {
  return h.bind(null, n4);
}
function J(n4) {
  return !!n4 && n4.$$typeof === H2;
}
function K(n4) {
  return J(n4) ? L.apply(null, arguments) : n4;
}
function Q(n4) {
  return !!n4.__k && (H(null, n4), true);
}
function X(n4) {
  return n4 && (n4.base || 1 === n4.nodeType && n4) || null;
}
var C2, A3, k2, R, F2, P2, W, D2, H2, Z, $2, q2, B, Y, compat_module_default;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_hooks_module();
    init_hooks_module();
    init_preact_module();
    init_preact_module();
    C2 = function(n4) {
      var t5, e5;
      function r5(t6) {
        var e6;
        return (e6 = n4.call(this, t6) || this).isPureReactComponent = true, e6;
      }
      return e5 = n4, (t5 = r5).prototype = Object.create(e5.prototype), t5.prototype.constructor = t5, t5.__proto__ = e5, r5.prototype.shouldComponentUpdate = function(n5, t6) {
        return w3(this.props, n5) || w3(this.state, t6);
      }, r5;
    }(m);
    A3 = n.__b;
    n.__b = function(n4) {
      n4.type && n4.type.t && n4.ref && (n4.props.ref = n4.ref, n4.ref = null), A3 && A3(n4);
    };
    k2 = function(n4, t5) {
      return n4 ? x(n4).reduce(function(n5, e5, r5) {
        return n5.concat(t5(e5, r5));
      }, []) : null;
    };
    R = { map: k2, forEach: k2, count: function(n4) {
      return n4 ? x(n4).length : 0;
    }, only: function(n4) {
      if (1 !== (n4 = x(n4)).length)
        throw new Error("Children.only() expects only one child.");
      return n4[0];
    }, toArray: x };
    F2 = n.__e;
    n.__e = function(n4, t5, e5) {
      if (n4.then) {
        for (var r5, o4 = t5; o4 = o4.__; )
          if ((r5 = o4.__c) && r5.__c)
            return r5.__c(n4, t5.__c);
      }
      F2(n4, t5, e5);
    }, (U.prototype = new m()).__c = function(n4, t5) {
      var e5 = this;
      null == e5.o && (e5.o = []), e5.o.push(t5);
      var r5 = M2(e5.__v), o4 = false, u5 = function() {
        o4 || (o4 = true, r5 ? r5(i4) : i4());
      };
      t5.__c = t5.componentWillUnmount, t5.componentWillUnmount = function() {
        u5(), t5.__c && t5.__c();
      };
      var i4 = function() {
        var n5;
        if (!--e5.__u)
          for (e5.__v.__k[0] = e5.state.u, e5.setState({ u: e5.__b = null }); n5 = e5.o.pop(); )
            n5.forceUpdate();
      };
      e5.__u++ || e5.setState({ u: e5.__b = e5.__v.__k[0] }), n4.then(u5, u5);
    }, U.prototype.render = function(n4, t5) {
      return this.__b && (this.__v.__k[0] = N2(this.__b), this.__b = null), [h(m, null, t5.u ? null : n4.children), t5.u && n4.fallback];
    };
    P2 = function(n4, t5, e5) {
      if (++e5[1] === e5[0] && n4.l.delete(t5), n4.props.revealOrder && ("t" !== n4.props.revealOrder[0] || !n4.l.size))
        for (e5 = n4.i; e5; ) {
          for (; e5.length > 3; )
            e5.pop()();
          if (e5[1] < e5[0])
            break;
          n4.i = e5 = e5[2];
        }
    };
    (O.prototype = new m()).u = function(n4) {
      var t5 = this, e5 = M2(t5.__v), r5 = t5.l.get(n4);
      return r5[0]++, function(o4) {
        var u5 = function() {
          t5.props.revealOrder ? (r5.push(o4), P2(t5, n4, r5)) : o4();
        };
        e5 ? e5(u5) : u5();
      };
    }, O.prototype.render = function(n4) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var t5 = x(n4.children);
      n4.revealOrder && "b" === n4.revealOrder[0] && t5.reverse();
      for (var e5 = t5.length; e5--; )
        this.l.set(t5[e5], this.i = [1, 0, this.i]);
      return n4.children;
    }, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
      var n4 = this;
      n4.l.forEach(function(t5, e5) {
        P2(n4, e5, t5);
      });
    };
    W = function() {
      function n4() {
      }
      var t5 = n4.prototype;
      return t5.getChildContext = function() {
        return this.props.context;
      }, t5.render = function(n5) {
        return n5.children;
      }, n4;
    }();
    D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m.prototype.isReactComponent = {};
    H2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    Z = n.event;
    n.event = function(n4) {
      Z && (n4 = Z(n4)), n4.persist = function() {
      };
      var t5 = false, e5 = false, r5 = n4.stopPropagation;
      n4.stopPropagation = function() {
        r5.call(n4), t5 = true;
      };
      var o4 = n4.preventDefault;
      return n4.preventDefault = function() {
        o4.call(n4), e5 = true;
      }, n4.isPropagationStopped = function() {
        return t5;
      }, n4.isDefaultPrevented = function() {
        return e5;
      }, n4.nativeEvent = n4;
    };
    $2 = { configurable: true, get: function() {
      return this.class;
    } };
    q2 = n.vnode;
    n.vnode = function(n4) {
      n4.$$typeof = H2;
      var t5 = n4.type, e5 = n4.props;
      if (t5) {
        if (e5.class != e5.className && ($2.enumerable = "className" in e5, null != e5.className && (e5.class = e5.className), Object.defineProperty(e5, "className", $2)), "function" != typeof t5) {
          var r5, o4, u5;
          for (u5 in e5.defaultValue && void 0 !== e5.value && (e5.value || 0 === e5.value || (e5.value = e5.defaultValue), delete e5.defaultValue), Array.isArray(e5.value) && e5.multiple && "select" === t5 && (x(e5.children).forEach(function(n5) {
            -1 != e5.value.indexOf(n5.props.value) && (n5.props.selected = true);
          }), delete e5.value), e5)
            if (r5 = D2.test(u5))
              break;
          if (r5)
            for (u5 in o4 = n4.props = {}, e5)
              o4[D2.test(u5) ? u5.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u5] = e5[u5];
        }
        !function(t6) {
          var e6 = n4.type, r6 = n4.props;
          if (r6 && "string" == typeof e6) {
            var o5 = {};
            for (var u6 in r6)
              /^on(Ani|Tra|Tou)/.test(u6) && (r6[u6.toLowerCase()] = r6[u6], delete r6[u6]), o5[u6.toLowerCase()] = u6;
            if (o5.ondoubleclick && (r6.ondblclick = r6[o5.ondoubleclick], delete r6[o5.ondoubleclick]), o5.onbeforeinput && (r6.onbeforeinput = r6[o5.onbeforeinput], delete r6[o5.onbeforeinput]), o5.onchange && ("textarea" === e6 || "input" === e6.toLowerCase() && !/^fil|che|ra/i.test(r6.type))) {
              var i4 = o5.oninput || "oninput";
              r6[i4] || (r6[i4] = r6[o5.onchange], delete r6[o5.onchange]);
            }
          }
        }(), "function" == typeof t5 && !t5.m && t5.prototype && (I2(t5.prototype, "componentWillMount"), I2(t5.prototype, "componentWillReceiveProps"), I2(t5.prototype, "componentWillUpdate"), t5.m = true);
      }
      q2 && q2(n4);
    };
    B = "16.8.0";
    Y = function(n4, t5) {
      return n4(t5);
    };
    compat_module_default = { useState: m2, useReducer: p2, useEffect: l2, useLayoutEffect: y2, useRef: d2, useImperativeHandle: s2, useMemo: h2, useCallback: T2, useContext: w2, useDebugValue: A2, version: "16.8.0", Children: R, render: T3, hydrate: T3, unmountComponentAtNode: Q, createPortal: z2, createElement: h, createContext: M, createFactory: G, cloneElement: K, createRef: y, Fragment: d, isValidElement: J, findDOMNode: X, Component: m, PureComponent: C2, memo: _3, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L2 };
  }
});

// node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), __toCommonJS(esm_exports2));
    var QRCode = _interopDefault(require_browser2());
    var copy3 = _interopDefault(require_copy_to_clipboard());
    var React8 = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e5) {
        return recover(e5);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props2) {
      return React8.createElement("div", {
        className: "walletconnect-modal__header"
      }, React8.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React8.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React8.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props2.onClose
      }, React8.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React8.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React8.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props2) {
      return React8.createElement("a", {
        className: "walletconnect-connect__button",
        href: props2.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props2.name,
        onClick: props2.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props2.color
        },
        target: "_blank"
      }, props2.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props2) {
      var color = props2.color;
      var href = props2.href;
      var name = props2.name;
      var logo = props2.logo;
      var onClick = props2.onClick;
      return React8.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React8.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name), React8.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React8.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React8.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props2) {
      var color = props2.color;
      var href = props2.href;
      var name = props2.name;
      var logo = props2.logo;
      var onClick = props2.onClick;
      var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React8.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React8.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React8.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props2) {
      var android = browserUtils.isAndroid();
      var ref = React8.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React8.useState("");
      var filter = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React8.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter ? props2.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter.toLowerCase());
      }) : props2.links;
      var errorMessage = props2.errorMessage;
      var grid = filter || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_5, index2) {
        return index2 + 1 >= range[0] && index2 + 1 <= range[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e5) {
        setInput(e5.target.value);
        clearTimeout(filterTimeout);
        if (e5.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e5.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React8.createElement("div", null, React8.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props2.text.connect_mobile_wallet : props2.text.choose_preferred_wallet), !android && React8.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React8.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props2.uri, entry);
        var handleClickIOS = React8.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name,
            href
          });
        }, [pageLinks]);
        return !grid ? React8.createElement(WalletButton, {
          color,
          href,
          name,
          logo,
          onClick: handleClickIOS
        }) : React8.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name,
          logo,
          onClick: handleClickIOS
        });
      }) : React8.createElement(React8.Fragment, null, React8.createElement("p", null, errorMessage.length ? props2.errorMessage : !!props2.links.length && !links.length ? props2.text.no_wallets_found : props2.text.loading)) : React8.createElement(ConnectButton, {
        name: props2.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props2.uri,
        onClick: React8.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props2.uri
          });
        }, [])
      })), hasPaging && React8.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_5, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React8.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification(props2) {
      var show = !!props2.message.trim();
      return React8.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props2.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e5) {
        return Promise.reject(e5);
      }
    };
    function QRCodeDisplay(props2) {
      var ref = React8.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React8.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React8.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props2.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e5) {
          Promise.reject(e5);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy3(props2.uri);
        if (success) {
          setNotification(props2.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React8.createElement("div", null, React8.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props2.text.scan_qrcode_with_wallet), React8.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React8.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React8.createElement("a", {
        onClick: copyToClipboard
      }, props2.text.copy_to_clipboard)), React8.createElement(Notification, {
        message: notification
      }));
    }
    function Modal3(props2) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props2.qrcodeModalOptions && props2.qrcodeModalOptions.mobileLinks ? props2.qrcodeModalOptions.mobileLinks : void 0 : props2.qrcodeModalOptions && props2.qrcodeModalOptions.desktopLinks ? props2.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React8.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React8.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React8.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props2.text,
        uri: props2.uri,
        qrcodeModalOptions: props2.qrcodeModalOptions
      };
      var ref$3 = React8.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React8.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React8.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React8.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React8.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props2.qrcodeModalOptions && props2.qrcodeModalOptions.registryUrl ? props2.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform4 = mobile ? "mobile" : "desktop";
                    var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform4), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props2.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(browserUtils.formatIOSMobile(props2.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e5) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props2.text.something_went_wrong);
                console.error(e5);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e5) {
              return Promise.reject(e5);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React8.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React8.createElement("div", {
        className: "walletconnect-modal__base"
      }, React8.createElement(Header, {
        onClose: props2.onClose
      }), hasSingleLink && displayQRCode ? React8.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React8.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props2.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React8.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React8.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React8.createElement(React8.Fragment, null, React8.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props2.text.mobile), React8.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props2.text.qrcode)) : React8.createElement(React8.Fragment, null, React8.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props2.text.qrcode), React8.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props2.text.desktop))) : null, React8.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React8.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React8.createElement(LinkDisplay, Object.assign(
        {},
        displayProps,
        {
          links,
          errorMessage
        }
      )))));
    }
    var de2 = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en2 = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr2 = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko2 = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa2 = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de: de2,
      en: en2,
      es,
      fr: fr2,
      ko: ko2,
      pt,
      zh,
      fa: fa2
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React8.render(React8.createElement(Modal3, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// node_modules/@walletconnect/http-connection/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@walletconnect/http-connection/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn2, context2, once4) {
      this.fn = fn2;
      this.context = context2;
      this.once = once4 || false;
    }
    function addListener4(emitter, event, fn2, context2, once4) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context2 || emitter, once4), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames2() {
      var names = [], events2, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners3(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i4 = 0, l5 = handlers.length, ee3 = new Array(l5); i4 < l5; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount3(event) {
      var evt = prefix ? prefix + event : event, listeners3 = this._events[evt];
      if (!listeners3)
        return 0;
      if (listeners3.fn)
        return 1;
      return listeners3.length;
    };
    EventEmitter3.prototype.emit = function emit4(event, a12, a22, a32, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners3 = this._events[evt], len = arguments.length, args, i4;
      if (listeners3.fn) {
        if (listeners3.once)
          this.removeListener(event, listeners3.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners3.fn.call(listeners3.context), true;
          case 2:
            return listeners3.fn.call(listeners3.context, a12), true;
          case 3:
            return listeners3.fn.call(listeners3.context, a12, a22), true;
          case 4:
            return listeners3.fn.call(listeners3.context, a12, a22, a32), true;
          case 5:
            return listeners3.fn.call(listeners3.context, a12, a22, a32, a4), true;
          case 6:
            return listeners3.fn.call(listeners3.context, a12, a22, a32, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners3.fn.apply(listeners3.context, args);
      } else {
        var length = listeners3.length, j4;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners3[i4].once)
            this.removeListener(event, listeners3[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners3[i4].fn.call(listeners3[i4].context);
              break;
            case 2:
              listeners3[i4].fn.call(listeners3[i4].context, a12);
              break;
            case 3:
              listeners3[i4].fn.call(listeners3[i4].context, a12, a22);
              break;
            case 4:
              listeners3[i4].fn.call(listeners3[i4].context, a12, a22, a32);
              break;
            default:
              if (!args)
                for (j4 = 1, args = new Array(len - 1); j4 < len; j4++) {
                  args[j4 - 1] = arguments[j4];
                }
              listeners3[i4].fn.apply(listeners3[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on4(event, fn2, context2) {
      return addListener4(this, event, fn2, context2, false);
    };
    EventEmitter3.prototype.once = function once4(event, fn2, context2) {
      return addListener4(this, event, fn2, context2, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener4(event, fn2, context2, once4) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners3 = this._events[evt];
      if (listeners3.fn) {
        if (listeners3.fn === fn2 && (!once4 || listeners3.once) && (!context2 || listeners3.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events2 = [], length = listeners3.length; i4 < length; i4++) {
          if (listeners3[i4].fn !== fn2 || once4 && !listeners3[i4].once || context2 && listeners3[i4].context !== context2) {
            events2.push(listeners3[i4]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js
function blobConstructor() {
  if (typeof _blobConstructor !== "undefined") {
    return _blobConstructor;
  }
  try {
    new window.Blob([new ArrayBuffer(1)]);
    _blobConstructor = true;
  } catch (e5) {
    _blobConstructor = false;
  }
  return _blobConstructor;
}
function checkTypeSupport(type2) {
  if (!xhr) {
    xhr = new window.XMLHttpRequest();
    xhr.open("GET", window.location.host ? "/" : "https://example.com");
  }
  try {
    xhr.responseType = type2;
    return xhr.responseType === type2;
  } catch (e5) {
    return false;
  }
}
function isFunction(value) {
  return typeof value === "function";
}
var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray;
var init_capability = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    hasFetch = isFunction(window.fetch) && isFunction(window.ReadableStream);
    haveArrayBuffer = typeof window.ArrayBuffer !== "undefined";
    haveSlice = haveArrayBuffer && isFunction(window.ArrayBuffer.prototype.slice);
    arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer");
    msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream");
    mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
    overrideMimeType = isFunction(xhr.overrideMimeType);
    vbArray = isFunction(window.VBArray);
    xhr = null;
  }
});

// node-modules-polyfills:process
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e5) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e6) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e5) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e6) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout2 = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout2);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      args[i4 - 1] = arguments[i4];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop2() {
}
function binding2(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance3) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime2() {
  var currentTime = new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var cachedSetTimeout2, cachedClearTimeout2, queue2, draining2, currentQueue2, queueIndex2, title2, platform2, browser2, env4, argv2, version2, versions2, release2, config2, on2, addListener2, once2, off2, removeListener2, removeAllListeners2, emit2, performance3, performanceNow2, startTime2, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_virtual_process_polyfill();
    init_buffer();
    cachedSetTimeout2 = defaultSetTimout2;
    cachedClearTimeout2 = defaultClearTimeout2;
    if (typeof window.setTimeout === "function") {
      cachedSetTimeout2 = setTimeout;
    }
    if (typeof window.clearTimeout === "function") {
      cachedClearTimeout2 = clearTimeout;
    }
    queue2 = [];
    draining2 = false;
    queueIndex2 = -1;
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title2 = "browser";
    platform2 = "browser";
    browser2 = true;
    env4 = {};
    argv2 = [];
    version2 = "";
    versions2 = {};
    release2 = {};
    config2 = {};
    on2 = noop2;
    addListener2 = noop2;
    once2 = noop2;
    off2 = noop2;
    removeListener2 = noop2;
    removeAllListeners2 = noop2;
    emit2 = noop2;
    performance3 = window.performance || {};
    performanceNow2 = performance3.now || performance3.mozNow || performance3.msNow || performance3.oNow || performance3.webkitNow || function() {
      return new Date().getTime();
    };
    startTime2 = new Date();
    browser$1 = {
      nextTick: nextTick2,
      title: title2,
      browser: browser2,
      env: env4,
      argv: argv2,
      version: version2,
      versions: versions2,
      on: on2,
      addListener: addListener2,
      once: once2,
      off: off2,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding: binding2,
      cwd: cwd2,
      chdir: chdir2,
      umask: umask2,
      hrtime: hrtime2,
      platform: platform2,
      release: release2,
      config: config2,
      uptime: uptime2
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
var util_exports = {};
__export(util_exports, {
  _extend: () => _extend,
  debuglog: () => debuglog,
  default: () => util_default,
  deprecate: () => deprecate,
  format: () => format,
  inherits: () => inherits_default,
  inspect: () => inspect2,
  isArray: () => isArray2,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer4,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log
});
function format(f5) {
  if (!isString(f5)) {
    var objects = [];
    for (var i4 = 0; i4 < arguments.length; i4++) {
      objects.push(inspect2(arguments[i4]));
    }
    return objects.join(" ");
  }
  var i4 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f5).replace(formatRegExp, function(x6) {
    if (x6 === "%%")
      return "%";
    if (i4 >= len)
      return x6;
    switch (x6) {
      case "%s":
        return String(args[i4++]);
      case "%d":
        return Number(args[i4++]);
      case "%j":
        try {
          return JSON.stringify(args[i4++]);
        } catch (_5) {
          return "[Circular]";
        }
      default:
        return x6;
    }
  });
  for (var x5 = args[i4]; i4 < len; x5 = args[++i4]) {
    if (isNull(x5) || !isObject(x5)) {
      str += " " + x5;
    } else {
      str += " " + inspect2(x5);
    }
  }
  return str;
}
function deprecate(fn2, msg) {
  if (isUndefined(window.process)) {
    return function() {
      return deprecate(fn2, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn2;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn2.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction2(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base2 = "", array = false, braces = ["{", "}"];
  if (isArray2(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value)) {
    var n4 = value.name ? ": " + value.name : "";
    base2 = " [Function" + n4 + "]";
  }
  if (isRegExp(value)) {
    base2 = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base2 = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base2 = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base2 + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key2) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base2, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i4 = 0, l5 = value.length; i4 < l5; ++i4) {
    if (hasOwnProperty(value, String(i4))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i4),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key2) {
    if (!key2.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key2,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key2)) {
    name = "[" + key2 + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key2.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key2);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base2, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar2) {
  return Array.isArray(ar2);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re3) {
  return isObject(re3) && objectToString(re3) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d4) {
  return isObject(d4) && objectToString(d4) === "[object Date]";
}
function isError(e5) {
  return isObject(e5) && (objectToString(e5) === "[object Error]" || e5 instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
}
function isBuffer4(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o4) {
  return Object.prototype.toString.call(o4);
}
function pad(n4) {
  return n4 < 10 ? "0" + n4.toString(10) : n4.toString(10);
}
function timestamp() {
  var d4 = new Date();
  var time = [
    pad(d4.getHours()),
    pad(d4.getMinutes()),
    pad(d4.getSeconds())
  ].join(":");
  return [d4.getDate(), months[d4.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i4 = keys2.length;
  while (i4--) {
    origin[keys2[i4]] = add[keys2[i4]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, months, util_default;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    util_default = {
      inherits: inherits_default,
      _extend,
      log,
      isBuffer: isBuffer4,
      isPrimitive,
      isFunction: isFunction2,
      isError,
      isDate,
      isObject,
      isRegExp,
      isUndefined,
      isSymbol,
      isString,
      isNumber,
      isNullOrUndefined,
      isNull,
      isBoolean,
      isArray: isArray2,
      inspect: inspect2,
      deprecate,
      format,
      debuglog
    };
  }
});

// node-modules-polyfills:events
var events_exports = {};
__export(events_exports, {
  EventEmitter: () => EventEmitter,
  default: () => events_default2
});
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i4 = 0; i4 < len; ++i4)
      listeners3[i4].apply(self2, args);
  }
}
function _addListener(target, type2, listener, prepend) {
  var m5;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (!existing) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m5 = $getMaxListeners(target);
      if (m5 && m5 > 0 && existing.length > m5) {
        existing.warned = true;
        var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w6.name = "MaxListenersExceededWarning";
        w6.emitter = target;
        w6.type = type2;
        w6.count = existing.length;
        emitWarning(w6);
      }
    }
  }
  return target;
}
function emitWarning(e5) {
  typeof console.warn === "function" ? console.warn(e5) : console.log(e5);
}
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g4() {
    target.removeListener(type2, g4);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g4.listener = listener;
  return g4;
}
function listenerCount(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i4 = index, k5 = i4 + 1, n4 = list.length; k5 < n4; i4 += 1, k5 += 1)
    list[i4] = list[k5];
  list.pop();
}
function arrayClone(arr, i4) {
  var copy3 = new Array(i4);
  while (i4--)
    copy3[i4] = arr[i4];
  return copy3;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i4 = 0; i4 < ret.length; ++i4) {
    ret[i4] = arr[i4].listener || arr[i4];
  }
  return ret;
}
var domain2, events_default2;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default2 = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain2.active && !(this instanceof domain2.Domain)) {
          this.domain = domain2.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n4) {
      if (typeof n4 !== "number" || n4 < 0 || isNaN(n4))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n4;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit3(type2) {
      var er2, handler, len, args, i4, events2, domain3;
      var needDomainExit = false;
      var doError = type2 === "error";
      events2 = this._events;
      if (events2)
        doError = doError && events2.error == null;
      else if (!doError)
        return false;
      domain3 = this.domain;
      if (doError) {
        er2 = arguments[1];
        if (domain3) {
          if (!er2)
            er2 = new Error('Uncaught, unspecified "error" event');
          er2.domainEmitter = this;
          er2.domain = domain3;
          er2.domainThrown = false;
          domain3.emit("error", er2);
        } else if (er2 instanceof Error) {
          throw er2;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er2 + ")");
          err.context = er2;
          throw err;
        }
        return false;
      }
      handler = events2[type2];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i4 = 1; i4 < len; i4++)
            args[i4 - 1] = arguments[i4];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain3.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener3(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    EventEmitter.prototype.once = function once3(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener3(type2, listener) {
      var list, events2, position, i4, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events2 = this._events;
      if (!events2)
        return this;
      list = events2[type2];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events2[type2];
          if (events2.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i4 = list.length; i4-- > 0; ) {
          if (list[i4] === listener || list[i4].listener && list[i4].listener === listener) {
            originalListener = list[i4].listener;
            position = i4;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events2[type2];
          }
        } else {
          spliceOne(list, position);
        }
        if (events2.removeListener)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners3(type2) {
      var listeners3, events2;
      events2 = this._events;
      if (!events2)
        return this;
      if (!events2.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events2[type2]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events2[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events2);
        for (var i4 = 0, key2; i4 < keys2.length; ++i4) {
          key2 = keys2[i4];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners3 = events2[type2];
      if (typeof listeners3 === "function") {
        this.removeListener(type2, listeners3);
      } else if (listeners3) {
        do {
          this.removeListener(type2, listeners3[listeners3.length - 1]);
        } while (listeners3[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type2) {
      var evlistener;
      var ret;
      var events2 = this._events;
      if (!events2)
        ret = [];
      else {
        evlistener = events2[type2];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount.call(emitter, type2);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v5) {
      var entry = { data: v5, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v5) {
      var entry = { data: v5, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s4) {
      if (this.length === 0)
        return "";
      var p5 = this.head;
      var ret = "" + p5.data;
      while (p5 = p5.next) {
        ret += s4 + p5.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n4) {
      if (this.length === 0)
        return Buffer3.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer3.allocUnsafe(n4 >>> 0);
      var p5 = this.head;
      var i4 = 0;
      while (p5) {
        p5.data.copy(ret, i4);
        i4 += p5.data.length;
        p5 = p5.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer3(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    isBufferEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i4 = buffer.length >= 3 ? 3 : buffer.length;
      for (; i4 > 0; i4--) {
        var c4 = buffer[buffer.length - i4];
        if (i4 == 1 && c4 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i4 <= 2 && c4 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i4 <= 3 && c4 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i4;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr2 = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr2).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn2) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn2);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn2);
    else
      emitter._events[event] = [fn2, emitter._events[event]];
  }
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default2.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er2 = chunkInvalid(state, chunk);
  if (er2) {
    stream.emit("error", er2);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e5 = new Error("stream.push() after EOF");
      stream.emit("error", e5);
    } else if (state.endEmitted && addToFront) {
      var _e2 = new Error("stream.unshift() after end event");
      stream.emit("error", _e2);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n4) {
  if (n4 >= MAX_HWM) {
    n4 = MAX_HWM;
  } else {
    n4--;
    n4 |= n4 >>> 1;
    n4 |= n4 >>> 2;
    n4 |= n4 >>> 4;
    n4 |= n4 >>> 8;
    n4 |= n4 >>> 16;
    n4++;
  }
  return n4;
}
function howMuchToRead(n4, state) {
  if (n4 <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n4 !== n4) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n4 > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n4);
  if (n4 <= state.length)
    return n4;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er2 = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  return er2;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick2(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n4, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n4 || n4 >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n4, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n4, list, hasStrings) {
  var ret;
  if (n4 < list.head.data.length) {
    ret = list.head.data.slice(0, n4);
    list.head.data = list.head.data.slice(n4);
  } else if (n4 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n4, list) : copyFromBuffer(n4, list);
  }
  return ret;
}
function copyFromBufferString(n4, list) {
  var p5 = list.head;
  var c4 = 1;
  var ret = p5.data;
  n4 -= ret.length;
  while (p5 = p5.next) {
    var str = p5.data;
    var nb = n4 > str.length ? str.length : n4;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n4);
    n4 -= nb;
    if (n4 === 0) {
      if (nb === str.length) {
        ++c4;
        if (p5.next)
          list.head = p5.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p5;
        p5.data = str.slice(nb);
      }
      break;
    }
    ++c4;
  }
  list.length -= c4;
  return ret;
}
function copyFromBuffer(n4, list) {
  var ret = Buffer2.allocUnsafe(n4);
  var p5 = list.head;
  var c4 = 1;
  p5.data.copy(ret);
  n4 -= p5.data.length;
  while (p5 = p5.next) {
    var buf = p5.data;
    var nb = n4 > buf.length ? buf.length : n4;
    buf.copy(ret, ret.length - n4, 0, nb);
    n4 -= nb;
    if (n4 === 0) {
      if (nb === buf.length) {
        ++c4;
        if (p5.next)
          list.head = p5.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p5;
        p5.data = buf.slice(nb);
      }
      break;
    }
    ++c4;
  }
  list.length -= c4;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs2, f5) {
  for (var i4 = 0, l5 = xs2.length; i4 < l5; i4++) {
    f5(xs2[i4], i4);
  }
}
function indexOf3(xs2, x5) {
  for (var i4 = 0, l5 = xs2.length; i4 < l5; i4++) {
    if (xs2[i4] === x5)
      return i4;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default2);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n4) {
      debug("read", n4);
      n4 = parseInt(n4, 10);
      var state = this._readableState;
      var nOrig = n4;
      if (n4 !== 0)
        state.emittedReadable = false;
      if (n4 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n4 = howMuchToRead(n4, state);
      if (n4 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n4 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n4 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n4 > 0)
        ret = fromList(n4, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n4 = 0;
      } else {
        state.length -= n4;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n4 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n4) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick2(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er2);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i2 = 0; _i2 < len; _i2++) {
          dests[_i2].emit("unpipe", this);
        }
        return this;
      }
      var i4 = indexOf3(state.pipes, dest);
      if (i4 === -1)
        return this;
      state.pipes.splice(i4, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn2) {
      var res = events_default2.prototype.on.call(this, ev, fn2);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick2(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      var events2 = ["error", "close", "destroy", "pause", "resume"];
      forEach(events2, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n4) {
        debug("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er2) {
    onwrite(stream, er2);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er2 = new Error("write after end");
  stream.emit("error", er2);
  nextTick2(cb, er2);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er2 = false;
  if (chunk === null) {
    er2 = new TypeError("May not write null values to stream");
  } else if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er2) {
    stream.emit("error", er2);
    nextTick2(cb, er2);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer3.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er2, cb) {
  --state.pendingcb;
  if (sync)
    nextTick2(cb, er2);
  else
    cb(er2);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er2);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er2) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er2)
    onwriteError(stream, state, sync, er2, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick2(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l5 = state.bufferedRequestCount;
    var buffer = new Array(l5);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick2(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_util();
    init_buffer2();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer3.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick2(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v5;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v5 = 0; v5 < keys.length; v5++) {
      method = keys[v5];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er2, data) {
    return afterTransform(stream, er2, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er2, data) {
  var ts2 = stream._transformState;
  ts2.transforming = false;
  var cb = ts2.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts2.writechunk = null;
  ts2.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er2);
  var rs2 = stream._readableState;
  rs2.reading = false;
  if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
    stream._read(rs2.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er2) {
        done(stream, er2);
      });
    else
      done(stream);
  });
}
function done(stream, er2) {
  if (er2)
    return stream.emit("error", er2);
  var ws2 = stream._writableState;
  var ts2 = stream._transformState;
  if (ws2.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts2.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n4) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && ts2.writecb && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default2.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default2);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er2) {
        cleanup();
        if (events_default2.listenerCount(this, "error") === 0) {
          throw er2;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js
function IncomingMessage(xhr2, response, mode) {
  var self2 = this;
  Readable.call(self2);
  self2._mode = mode;
  self2.headers = {};
  self2.rawHeaders = [];
  self2.trailers = {};
  self2.rawTrailers = [];
  self2.on("end", function() {
    process.nextTick(function() {
      self2.emit("close");
    });
  });
  var read2;
  if (mode === "fetch") {
    self2._fetchResponse = response;
    self2.url = response.url;
    self2.statusCode = response.status;
    self2.statusMessage = response.statusText;
    for (var header, _i2, _it = response.headers[Symbol.iterator](); header = (_i2 = _it.next()).value, !_i2.done; ) {
      self2.headers[header[0].toLowerCase()] = header[1];
      self2.rawHeaders.push(header[0], header[1]);
    }
    var reader = response.body.getReader();
    read2 = function() {
      reader.read().then(function(result) {
        if (self2._destroyed)
          return;
        if (result.done) {
          self2.push(null);
          return;
        }
        self2.push(new Buffer2(result.value));
        read2();
      });
    };
    read2();
  } else {
    self2._xhr = xhr2;
    self2._pos = 0;
    self2.url = xhr2.responseURL;
    self2.statusCode = xhr2.status;
    self2.statusMessage = xhr2.statusText;
    var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function(header2) {
      var matches = header2.match(/^([^:]+):\s*(.*)/);
      if (matches) {
        var key2 = matches[1].toLowerCase();
        if (key2 === "set-cookie") {
          if (self2.headers[key2] === void 0) {
            self2.headers[key2] = [];
          }
          self2.headers[key2].push(matches[2]);
        } else if (self2.headers[key2] !== void 0) {
          self2.headers[key2] += ", " + matches[2];
        } else {
          self2.headers[key2] = matches[2];
        }
        self2.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self2._charset = "x-user-defined";
    if (!overrideMimeType) {
      var mimeType = self2.rawHeaders["mime-type"];
      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
        if (charsetMatch) {
          self2._charset = charsetMatch[1].toLowerCase();
        }
      }
      if (!self2._charset)
        self2._charset = "utf-8";
    }
  }
}
var rStates;
var init_response = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_capability();
    init_util();
    init_stream();
    rStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    inherits_default(IncomingMessage, Readable);
    IncomingMessage.prototype._read = function() {
    };
    IncomingMessage.prototype._onXHRProgress = function() {
      var self2 = this;
      var xhr2 = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text:vbarray":
          if (xhr2.readyState !== rStates.DONE)
            break;
          try {
            response = new window.VBArray(xhr2.responseBody).toArray();
          } catch (e5) {
          }
          if (response !== null) {
            self2.push(new Buffer2(response));
            break;
          }
        case "text":
          try {
            response = xhr2.responseText;
          } catch (e5) {
            self2._mode = "text:vbarray";
            break;
          }
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = new Buffer2(newData.length);
              for (var i4 = 0; i4 < newData.length; i4++)
                buffer[i4] = newData.charCodeAt(i4) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr2.readyState !== rStates.DONE || !xhr2.response)
            break;
          response = xhr2.response;
          self2.push(new Buffer2(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING || !response)
            break;
          self2.push(new Buffer2(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr2.response;
          if (xhr2.readyState !== rStates.LOADING)
            break;
          var reader = new window.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(new Buffer2(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        self2.push(null);
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js
function to_arraybuffer_default(buf) {
  if (buf instanceof Uint8Array) {
    if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
      return buf.buffer;
    } else if (typeof buf.buffer.slice === "function") {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }
  if (isBuffer2(buf)) {
    var arrayCopy = new Uint8Array(buf.length);
    var len = buf.length;
    for (var i4 = 0; i4 < len; i4++) {
      arrayCopy[i4] = buf[i4];
    }
    return arrayCopy.buffer;
  } else {
    throw new Error("Argument must be a Buffer");
  }
}
var init_to_arraybuffer = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js
function decideMode(preferBinary, useFetch) {
  if (hasFetch && useFetch) {
    return "fetch";
  } else if (mozchunkedarraybuffer) {
    return "moz-chunked-arraybuffer";
  } else if (msstream) {
    return "ms-stream";
  } else if (arraybuffer && preferBinary) {
    return "arraybuffer";
  } else if (vbArray && preferBinary) {
    return "text:vbarray";
  } else {
    return "text";
  }
}
function ClientRequest(opts) {
  var self2 = this;
  Writable.call(self2);
  self2._opts = opts;
  self2._body = [];
  self2._headers = {};
  if (opts.auth)
    self2.setHeader("Authorization", "Basic " + new Buffer2(opts.auth).toString("base64"));
  Object.keys(opts.headers).forEach(function(name) {
    self2.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;
  if (opts.mode === "disable-fetch") {
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === "prefer-streaming") {
    preferBinary = false;
  } else if (opts.mode === "allow-wrong-content-type") {
    preferBinary = !overrideMimeType;
  } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
    preferBinary = true;
  } else {
    throw new Error("Invalid value for opts.mode");
  }
  self2._mode = decideMode(preferBinary, useFetch);
  self2.on("finish", function() {
    self2._onFinish();
  });
}
function statusValid(xhr2) {
  try {
    var status = xhr2.status;
    return status !== null && status !== 0;
  } catch (e5) {
    return false;
  }
}
var request_default, unsafeHeaders;
var init_request = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_capability();
    init_util();
    init_response();
    init_stream();
    init_to_arraybuffer();
    request_default = ClientRequest;
    inherits_default(ClientRequest, Writable);
    unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "user-agent",
      "via"
    ];
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var self2 = this;
      return self2._headers[name.toLowerCase()].value;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      var headersObj = self2._headers;
      var body;
      if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
        if (blobConstructor()) {
          body = new window.Blob(self2._body.map(function(buffer) {
            return to_arraybuffer_default(buffer);
          }), {
            type: (headersObj["content-type"] || {}).value || ""
          });
        } else {
          body = Buffer2.concat(self2._body).toString();
        }
      }
      if (self2._mode === "fetch") {
        var headers = Object.keys(headersObj).map(function(name) {
          return [headersObj[name].name, headersObj[name].value];
        });
        window.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers,
          body,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin"
        }).then(function(response) {
          self2._fetchResponse = response;
          self2._connect();
        }, function(reason) {
          self2.emit("error", reason);
        });
      } else {
        var xhr2 = self2._xhr = new window.XMLHttpRequest();
        try {
          xhr2.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr2)
          xhr2.responseType = self2._mode.split(":")[0];
        if ("withCredentials" in xhr2)
          xhr2.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr2)
          xhr2.overrideMimeType("text/plain; charset=x-user-defined");
        Object.keys(headersObj).forEach(function(name) {
          xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value);
        });
        self2._response = null;
        xhr2.onreadystatechange = function() {
          switch (xhr2.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr2.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr2.onerror = function() {
          if (self2._destroyed)
            return;
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr2.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress();
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode);
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
      var self2 = this;
      self2._destroyed = true;
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setTimeout = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
  }
});

// node-modules-polyfills:punycode
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map(array, fn2) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn2(array[length]);
  }
  return result;
}
function mapDomain(string, fn2) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map(labels, fn2).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter = 0, length = string.length, value, extra;
  while (counter < length) {
    value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k5 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k5 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k5 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(input) {
  var n4, delta, handledCPCount, basicLength, bias, j4, m5, q5, k5, t5, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n4 = initialN;
  delta = 0;
  bias = initialBias;
  for (j4 = 0; j4 < inputLength; ++j4) {
    currentValue = input[j4];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m5 = maxInt, j4 = 0; j4 < inputLength; ++j4) {
      currentValue = input[j4];
      if (currentValue >= n4 && currentValue < m5) {
        m5 = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m5 - n4 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m5 - n4) * handledCPCountPlusOne;
    n4 = m5;
    for (j4 = 0; j4 < inputLength; ++j4) {
      currentValue = input[j4];
      if (currentValue < n4 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n4) {
        for (q5 = delta, k5 = base; ; k5 += base) {
          t5 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
          if (q5 < t5) {
            break;
          }
          qMinusT = q5 - t5;
          baseMinusT = base - t5;
          output.push(
            stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0))
          );
          q5 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q5, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n4;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode;
var init_punycode = __esm({
  "node-modules-polyfills:punycode"() {
    init_virtual_process_polyfill();
    init_buffer();
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexNonASCII = /[^\x20-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
  }
});

// node-modules-polyfills:querystring
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function stringifyPrimitive(v5) {
  switch (typeof v5) {
    case "string":
      return v5;
    case "boolean":
      return v5 ? "true" : "false";
    case "number":
      return isFinite(v5) ? v5 : "";
    default:
      return "";
  }
}
function stringify4(obj, sep, eq, name) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map2(objectKeys(obj), function(k5) {
      var ks2 = encodeURIComponent(stringifyPrimitive(k5)) + eq;
      if (isArray3(obj[k5])) {
        return map2(obj[k5], function(v5) {
          return ks2 + encodeURIComponent(stringifyPrimitive(v5));
        }).join(sep);
      } else {
        return ks2 + encodeURIComponent(stringifyPrimitive(obj[k5]));
      }
    }).join(sep);
  }
  if (!name)
    return "";
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map2(xs2, f5) {
  if (xs2.map)
    return xs2.map(f5);
  var res = [];
  for (var i4 = 0; i4 < xs2.length; i4++) {
    res.push(f5(xs2[i4], i4));
  }
  return res;
}
function parse4(qs2, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs2 !== "string" || qs2.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs2 = qs2.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs2.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i4 = 0; i4 < len; ++i4) {
    var x5 = qs2[i4].replace(regexp, "%20"), idx = x5.indexOf(eq), kstr, vstr, k5, v5;
    if (idx >= 0) {
      kstr = x5.substr(0, idx);
      vstr = x5.substr(idx + 1);
    } else {
      kstr = x5;
      vstr = "";
    }
    k5 = decodeURIComponent(kstr);
    v5 = decodeURIComponent(vstr);
    if (!hasOwnProperty2(obj, k5)) {
      obj[k5] = v5;
    } else if (isArray3(obj[k5])) {
      obj[k5].push(v5);
    } else {
      obj[k5] = [obj[k5], v5];
    }
  }
  return obj;
}
var isArray3, objectKeys;
var init_querystring = __esm({
  "node-modules-polyfills:querystring"() {
    init_virtual_process_polyfill();
    init_buffer();
    isArray3 = Array.isArray || function(xs2) {
      return Object.prototype.toString.call(xs2) === "[object Array]";
    };
    objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key2 in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key2))
          res.push(key2);
      }
      return res;
    };
  }
});

// node-modules-polyfills:url
var url_exports = {};
__export(url_exports, {
  Url: () => Url,
  default: () => url_default,
  format: () => urlFormat,
  parse: () => urlParse,
  resolve: () => urlResolve,
  resolveObject: () => urlResolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString6, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url)
    return url;
  var u5 = new Url();
  u5.parse(url, parseQueryString6, slashesDenoteHost);
  return u5;
}
function parse5(self2, url, parseQueryString6, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString6) {
          self2.query = parse4(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString6) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i4, hec, l5, p5;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i4 = 0; i4 < hostEndingChars.length; i4++) {
      hec = rest.indexOf(hostEndingChars[i4]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i4 = 0; i4 < nonHostChars.length; i4++) {
      hec = rest.indexOf(nonHostChars[i4]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i4 = 0, l5 = hostparts.length; i4 < l5; i4++) {
        var part = hostparts[i4];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j4 = 0, k5 = part.length; j4 < k5; j4++) {
            if (part.charCodeAt(j4) > 127) {
              newpart += "x";
            } else {
              newpart += part[j4];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i4);
            var notHost = hostparts.slice(i4 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p5 = self2.port ? ":" + self2.port : "";
    var h5 = self2.hostname || "";
    self2.host = h5 + p5;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i4 = 0, l5 = autoEscape.length; i4 < l5; i4++) {
      var ae = autoEscape[i4];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString6) {
      self2.query = parse4(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString6) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p5 = self2.pathname || "";
    var s4 = self2.search || "";
    self2.path = p5 + s4;
  }
  self2.href = format2(self2);
  return self2;
}
function urlFormat(obj) {
  if (isString(obj))
    obj = parse5({}, obj);
  return format2(obj);
}
function format2(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
    query = stringify4(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function parseHost(self2) {
  var host = self2.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      self2.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    self2.hostname = host;
}
var url_default, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
var init_url = __esm({
  "node-modules-polyfills:url"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_punycode();
    init_util();
    init_querystring();
    url_default = {
      parse: urlParse,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      Url
    };
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    Url.prototype.parse = function(url, parseQueryString6, slashesDenoteHost) {
      return parse5(this, url, parseQueryString6, slashesDenoteHost);
    };
    Url.prototype.format = function() {
      return format2(this);
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v5 = 0; v5 < keys2.length; v5++) {
            var k5 = keys2[v5];
            result[k5] = relative[k5];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p5 = result.pathname || "";
          var s4 = result.search || "";
          result.path = p5 + s4;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split("/") || [];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      var authInHost;
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i4 = srcPath.length; i4 >= 0; i4--) {
        last = srcPath[i4];
        if (last === ".") {
          srcPath.splice(i4, 1);
        } else if (last === "..") {
          srcPath.splice(i4, 1);
          up++;
        } else if (up) {
          srcPath.splice(i4, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      return parseHost(this);
    };
  }
});

// node-modules-polyfills:http
var http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  default: () => http_default,
  get: () => get,
  request: () => request
});
function request(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts);
  var defaultProtocol = window.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path2 = opts.path || "/";
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]";
  opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path2;
  opts.method = (opts.method || "GET").toUpperCase();
  opts.headers = opts.headers || {};
  var req = new request_default(opts);
  if (cb)
    req.on("response", cb);
  return req;
}
function get(opts, cb) {
  var req = request(opts, cb);
  req.end();
  return req;
}
function Agent() {
}
var METHODS, STATUS_CODES, http_default;
var init_http = __esm({
  "node-modules-polyfills:http"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_request();
    init_url();
    Agent.defaultMaxSockets = 4;
    METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    http_default = {
      request,
      get,
      Agent,
      METHODS,
      STATUS_CODES
    };
  }
});

// node-modules-polyfills-commonjs:http
var require_http = __commonJS({
  "node-modules-polyfills-commonjs:http"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_http(), __toCommonJS(http_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:https
var https_exports = {};
__export(https_exports, {
  Agent: () => Agent2,
  METHODS: () => METHODS2,
  STATUS_CODES: () => STATUS_CODES2,
  default: () => https_default,
  get: () => get2,
  request: () => request2
});
function request2(opts, cb) {
  if (typeof opts === "string")
    opts = urlParse(opts);
  var defaultProtocol = window.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path2 = opts.path || "/";
  if (host && host.indexOf(":") !== -1)
    host = "[" + host + "]";
  opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path2;
  opts.method = (opts.method || "GET").toUpperCase();
  opts.headers = opts.headers || {};
  var req = new request_default(opts);
  if (cb)
    req.on("response", cb);
  return req;
}
function get2(opts, cb) {
  var req = request2(opts, cb);
  req.end();
  return req;
}
function Agent2() {
}
var METHODS2, STATUS_CODES2, https_default;
var init_https = __esm({
  "node-modules-polyfills:https"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_request();
    init_url();
    Agent2.defaultMaxSockets = 4;
    METHODS2 = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES2 = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Moved Temporarily",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Time-out",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Large",
      414: "Request-URI Too Large",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Time-out",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    https_default = {
      request: request2,
      get: get2,
      Agent: Agent2,
      METHODS: METHODS2,
      STATUS_CODES: STATUS_CODES2
    };
  }
});

// node-modules-polyfills-commonjs:https
var require_https = __commonJS({
  "node-modules-polyfills-commonjs:https"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_https(), __toCommonJS(https_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:os
var os_exports = {};
__export(os_exports, {
  EOL: () => EOL,
  arch: () => arch,
  cpus: () => cpus,
  default: () => os_default,
  endianness: () => endianness,
  freemem: () => freemem,
  getNetworkInterfaces: () => getNetworkInterfaces,
  hostname: () => hostname,
  loadavg: () => loadavg,
  networkInterfaces: () => networkInterfaces,
  platform: () => platform3,
  release: () => release3,
  tmpDir: () => tmpDir,
  tmpdir: () => tmpdir,
  totalmem: () => totalmem,
  type: () => type,
  uptime: () => uptime3
});
function endianness() {
  if (typeof _endianness === "undefined") {
    var a4 = new ArrayBuffer(2);
    var b3 = new Uint8Array(a4);
    var c4 = new Uint16Array(a4);
    b3[0] = 1;
    b3[1] = 2;
    if (c4[0] === 258) {
      _endianness = "BE";
    } else if (c4[0] === 513) {
      _endianness = "LE";
    } else {
      throw new Error("unable to figure out endianess");
    }
  }
  return _endianness;
}
function hostname() {
  if (typeof window.location !== "undefined") {
    return window.location.hostname;
  } else
    return "";
}
function loadavg() {
  return [];
}
function uptime3() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type() {
  return "Browser";
}
function release3() {
  if (typeof window.navigator !== "undefined") {
    return window.navigator.appVersion;
  }
  return "";
}
function networkInterfaces() {
}
function getNetworkInterfaces() {
}
function arch() {
  return "javascript";
}
function platform3() {
  return "browser";
}
function tmpDir() {
  return "/tmp";
}
var _endianness, tmpdir, EOL, os_default;
var init_os = __esm({
  "node-modules-polyfills:os"() {
    init_virtual_process_polyfill();
    init_buffer();
    tmpdir = tmpDir;
    EOL = "\n";
    os_default = {
      EOL,
      tmpdir,
      tmpDir,
      networkInterfaces,
      getNetworkInterfaces,
      release: release3,
      type,
      cpus,
      totalmem,
      freemem,
      uptime: uptime3,
      loadavg,
      hostname,
      endianness
    };
  }
});

// node-modules-polyfills-commonjs:os
var require_os = __commonJS({
  "node-modules-polyfills-commonjs:os"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_os(), __toCommonJS(os_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:url
var require_url = __commonJS({
  "node-modules-polyfills-commonjs:url"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_url(), __toCommonJS(url_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/xhr2-cookies/dist/progress-event.js
var require_progress_event = __commonJS({
  "node_modules/xhr2-cookies/dist/progress-event.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressEvent = function() {
      function ProgressEvent2(type2) {
        this.type = type2;
        this.bubbles = false;
        this.cancelable = false;
        this.loaded = 0;
        this.lengthComputable = false;
        this.total = 0;
      }
      return ProgressEvent2;
    }();
    exports.ProgressEvent = ProgressEvent;
  }
});

// node_modules/xhr2-cookies/dist/errors.js
var require_errors = __commonJS({
  "node_modules/xhr2-cookies/dist/errors.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
        d4.__proto__ = b3;
      } || function(d4, b3) {
        for (var p5 in b3)
          if (b3.hasOwnProperty(p5))
            d4[p5] = b3[p5];
      };
      return function(d4, b3) {
        extendStatics(d4, b3);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SecurityError = function(_super) {
      __extends(SecurityError2, _super);
      function SecurityError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SecurityError2;
    }(Error);
    exports.SecurityError = SecurityError;
    var InvalidStateError = function(_super) {
      __extends(InvalidStateError2, _super);
      function InvalidStateError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return InvalidStateError2;
    }(Error);
    exports.InvalidStateError = InvalidStateError;
    var NetworkError = function(_super) {
      __extends(NetworkError2, _super);
      function NetworkError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NetworkError2;
    }(Error);
    exports.NetworkError = NetworkError;
    var SyntaxError = function(_super) {
      __extends(SyntaxError2, _super);
      function SyntaxError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SyntaxError2;
    }(Error);
    exports.SyntaxError = SyntaxError;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-event-target.js
var require_xml_http_request_event_target = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-event-target.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var XMLHttpRequestEventTarget = function() {
      function XMLHttpRequestEventTarget2() {
        this.listeners = {};
      }
      XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(listener.handleEvent || listener);
      };
      XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        if (!this.listeners[eventType]) {
          return;
        }
        var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
        if (index < 0) {
          return;
        }
        this.listeners[eventType].splice(index, 1);
      };
      XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
        var eventType = event.type.toLowerCase();
        event.target = this;
        if (this.listeners[eventType]) {
          for (var _i2 = 0, _a2 = this.listeners[eventType]; _i2 < _a2.length; _i2++) {
            var listener_1 = _a2[_i2];
            listener_1.call(this, event);
          }
        }
        var listener = this["on" + eventType];
        if (listener) {
          listener.call(this, event);
        }
        return true;
      };
      return XMLHttpRequestEventTarget2;
    }();
    exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-upload.js
var require_xml_http_request_upload = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-upload.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
        d4.__proto__ = b3;
      } || function(d4, b3) {
        for (var p5 in b3)
          if (b3.hasOwnProperty(p5))
            d4[p5] = b3[p5];
      };
      return function(d4, b3) {
        extendStatics(d4, b3);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var XMLHttpRequestUpload = function(_super) {
      __extends(XMLHttpRequestUpload2, _super);
      function XMLHttpRequestUpload2() {
        var _this = _super.call(this) || this;
        _this._contentType = null;
        _this._body = null;
        _this._reset();
        return _this;
      }
      XMLHttpRequestUpload2.prototype._reset = function() {
        this._contentType = null;
        this._body = null;
      };
      XMLHttpRequestUpload2.prototype._setData = function(data) {
        if (data == null) {
          return;
        }
        if (typeof data === "string") {
          if (data.length !== 0) {
            this._contentType = "text/plain;charset=UTF-8";
          }
          this._body = new Buffer2(data, "utf-8");
        } else if (Buffer2.isBuffer(data)) {
          this._body = data;
        } else if (data instanceof ArrayBuffer) {
          var body = new Buffer2(data.byteLength);
          var view = new Uint8Array(data);
          for (var i4 = 0; i4 < data.byteLength; i4++) {
            body[i4] = view[i4];
          }
          this._body = body;
        } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
          var body = new Buffer2(data.byteLength);
          var offset = data.byteOffset;
          var view = new Uint8Array(data.buffer);
          for (var i4 = 0; i4 < data.byteLength; i4++) {
            body[i4] = view[i4 + offset];
          }
          this._body = body;
        } else {
          throw new Error("Unsupported send() data " + data);
        }
      };
      XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
        if (this._contentType && !loweredHeaders["content-type"]) {
          headers["Content-Type"] = this._contentType;
        }
        if (this._body) {
          headers["Content-Length"] = this._body.length.toString();
        }
      };
      XMLHttpRequestUpload2.prototype._startUpload = function(request3) {
        if (this._body) {
          request3.write(this._body);
        }
        request3.end();
      };
      return XMLHttpRequestUpload2;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    (function() {
      "use strict";
      function CookieAccessInfo(domain3, path2, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain3 || void 0;
          this.path = path2 || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain3, path2, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports.Cookie = Cookie;
      Cookie.prototype.toString = function toString4() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse8(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i4;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key2 = pair[1];
          var value = pair[2];
          if (typeof key2 !== "string" || key2.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key2;
          this.value = value;
          for (i4 = 1; i4 < parts.length; i4 += 1) {
            pair = parts[i4].match(/([^=]+)(?:=([\s\S]*))?/);
            key2 = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key2) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i4;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i4 = 0; i4 < cookies_list.length; i4 += 1) {
                collidable_cookie = cookies_list[i4];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i4, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i4] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i4;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i4 = 0; i4 < cookies_list.length; i4 += 1) {
              cookie = cookies_list[i4];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString4() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c4) {
                return c4.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i4, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i4 = 0; i4 < cookies.length; i4 += 1) {
          cookie = cookies[i4];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request.js
var require_xml_http_request = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
        d4.__proto__ = b3;
      } || function(d4, b3) {
        for (var p5 in b3)
          if (b3.hasOwnProperty(p5))
            d4[p5] = b3[p5];
      };
      return function(d4, b3) {
        extendStatics(d4, b3);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || Object.assign || function(t5) {
      for (var s4, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
        s4 = arguments[i4];
        for (var p5 in s4)
          if (Object.prototype.hasOwnProperty.call(s4, p5))
            t5[p5] = s4[p5];
      }
      return t5;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = require_http();
    var https = require_https();
    var os2 = require_os();
    var url = require_url();
    var progress_event_1 = require_progress_event();
    var errors_1 = require_errors();
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var xml_http_request_upload_1 = require_xml_http_request_upload();
    var Cookie = require_cookiejar();
    var XMLHttpRequest2 = function(_super) {
      __extends(XMLHttpRequest3, _super);
      function XMLHttpRequest3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.UNSENT = XMLHttpRequest3.UNSENT;
        _this.OPENED = XMLHttpRequest3.OPENED;
        _this.HEADERS_RECEIVED = XMLHttpRequest3.HEADERS_RECEIVED;
        _this.LOADING = XMLHttpRequest3.LOADING;
        _this.DONE = XMLHttpRequest3.DONE;
        _this.onreadystatechange = null;
        _this.readyState = XMLHttpRequest3.UNSENT;
        _this.response = null;
        _this.responseText = "";
        _this.responseType = "";
        _this.status = 0;
        _this.statusText = "";
        _this.timeout = 0;
        _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
        _this.responseUrl = "";
        _this.withCredentials = false;
        _this._method = null;
        _this._url = null;
        _this._sync = false;
        _this._headers = {};
        _this._loweredHeaders = {};
        _this._mimeOverride = null;
        _this._request = null;
        _this._response = null;
        _this._responseParts = null;
        _this._responseHeaders = null;
        _this._aborting = null;
        _this._error = null;
        _this._loadedBytes = 0;
        _this._totalBytes = 0;
        _this._lengthComputable = false;
        _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
        _this._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          "user-agent": true,
          via: true
        };
        _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
        _this._userAgent = "Mozilla/5.0 (" + os2.type() + " " + os2.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
        _this._anonymous = options.anon || false;
        return _this;
      }
      XMLHttpRequest3.prototype.open = function(method, url2, async, user, password) {
        if (async === void 0) {
          async = true;
        }
        method = method.toUpperCase();
        if (this._restrictedMethods[method]) {
          throw new XMLHttpRequest3.SecurityError("HTTP method " + method + " is not allowed in XHR");
        }
        ;
        var xhrUrl = this._parseUrl(url2, user, password);
        if (this.readyState === XMLHttpRequest3.HEADERS_RECEIVED || this.readyState === XMLHttpRequest3.LOADING) {
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest3.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = "";
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
      };
      XMLHttpRequest3.prototype.setRequestHeader = function(name, value) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        var loweredName = name.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
          console.warn('Refused to set unsafe header "' + name + '"');
          return;
        }
        value = value.toString();
        if (this._loweredHeaders[loweredName] != null) {
          name = this._loweredHeaders[loweredName];
          this._headers[name] = this._headers[name] + ", " + value;
        } else {
          this._loweredHeaders[loweredName] = name;
          this._headers[name] = value;
        }
      };
      XMLHttpRequest3.prototype.send = function(data) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        if (this._request) {
          throw new XMLHttpRequest3.InvalidStateError("send() already called");
        }
        switch (this._url.protocol) {
          case "file:":
            return this._sendFile(data);
          case "http:":
          case "https:":
            return this._sendHttp(data);
          default:
            throw new XMLHttpRequest3.NetworkError("Unsupported protocol " + this._url.protocol);
        }
      };
      XMLHttpRequest3.prototype.abort = function() {
        if (this._request == null) {
          return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress("abort");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype.getResponseHeader = function(name) {
        if (this._responseHeaders == null || name == null) {
          return null;
        }
        var loweredName = name.toLowerCase();
        return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name.toLowerCase()] : null;
      };
      XMLHttpRequest3.prototype.getAllResponseHeaders = function() {
        var _this = this;
        if (this._responseHeaders == null) {
          return "";
        }
        return Object.keys(this._responseHeaders).map(function(key2) {
          return key2 + ": " + _this._responseHeaders[key2];
        }).join("\r\n");
      };
      XMLHttpRequest3.prototype.overrideMimeType = function(mimeType) {
        if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
          throw new XMLHttpRequest3.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
        }
        this._mimeOverride = mimeType.toLowerCase();
      };
      XMLHttpRequest3.prototype.nodejsSet = function(options) {
        this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
        this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
        if (options.hasOwnProperty("baseUrl")) {
          if (options.baseUrl != null) {
            var parsedUrl = url.parse(options.baseUrl, false, true);
            if (!parsedUrl.protocol) {
              throw new XMLHttpRequest3.SyntaxError("baseUrl must be an absolute URL");
            }
          }
          this.nodejsBaseUrl = options.baseUrl;
        }
      };
      XMLHttpRequest3.nodejsSet = function(options) {
        XMLHttpRequest3.prototype.nodejsSet(options);
      };
      XMLHttpRequest3.prototype._setReadyState = function(readyState) {
        this.readyState = readyState;
        this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
      };
      XMLHttpRequest3.prototype._sendFile = function(data) {
        throw new Error("Protocol file: not implemented");
      };
      XMLHttpRequest3.prototype._sendHttp = function(data) {
        if (this._sync) {
          throw new Error("Synchronous XHR processing not implemented");
        }
        if (data && (this._method === "GET" || this._method === "HEAD")) {
          console.warn("Discarding entity body for " + this._method + " requests");
          data = null;
        } else {
          data = data || "";
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
      };
      XMLHttpRequest3.prototype._sendHxxpRequest = function() {
        var _this = this;
        if (this.withCredentials) {
          var cookie = XMLHttpRequest3.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
          this._headers.cookie = this._headers.cookie2 = cookie;
        }
        var _a2 = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a2[0], agent = _a2[1];
        var requestMethod = hxxp.request.bind(hxxp);
        var request3 = requestMethod({
          hostname: this._url.hostname,
          port: +this._url.port,
          path: this._url.path,
          auth: this._url.auth,
          method: this._method,
          headers: this._headers,
          agent
        });
        this._request = request3;
        if (this.timeout) {
          request3.setTimeout(this.timeout, function() {
            return _this._onHttpTimeout(request3);
          });
        }
        request3.on("response", function(response) {
          return _this._onHttpResponse(request3, response);
        });
        request3.on("error", function(error2) {
          return _this._onHttpRequestError(request3, error2);
        });
        this.upload._startUpload(request3);
        if (this._request === request3) {
          this._dispatchProgress("loadstart");
        }
      };
      XMLHttpRequest3.prototype._finalizeHeaders = function() {
        this._headers = __assign({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      };
      XMLHttpRequest3.prototype._onHttpResponse = function(request3, response) {
        var _this = this;
        if (this._request !== request3) {
          return;
        }
        if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
          XMLHttpRequest3.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
        }
        if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
          this._url = this._parseUrl(response.headers.location);
          this._method = "GET";
          if (this._loweredHeaders["content-type"]) {
            delete this._headers[this._loweredHeaders["content-type"]];
            delete this._loweredHeaders["content-type"];
          }
          if (this._headers["Content-Type"] != null) {
            delete this._headers["Content-Type"];
          }
          delete this._headers["Content-Length"];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
        }
        this._response = response;
        this._response.on("data", function(data) {
          return _this._onHttpResponseData(response, data);
        });
        this._response.on("end", function() {
          return _this._onHttpResponseEnd(response);
        });
        this._response.on("close", function() {
          return _this._onHttpResponseClose(response);
        });
        this.responseUrl = this._url.href.split("#")[0];
        this.status = response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        var lengthString = this._responseHeaders["content-length"] || "";
        this._totalBytes = +lengthString;
        this._lengthComputable = !!lengthString;
        this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
      };
      XMLHttpRequest3.prototype._onHttpResponseData = function(response, data) {
        if (this._response !== response) {
          return;
        }
        this._responseParts.push(new Buffer2(data));
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest3.LOADING) {
          this._setReadyState(XMLHttpRequest3.LOADING);
        }
        this._dispatchProgress("progress");
      };
      XMLHttpRequest3.prototype._onHttpResponseEnd = function(response) {
        if (this._response !== response) {
          return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("load");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpResponseClose = function(response) {
        if (this._response !== response) {
          return;
        }
        var request3 = this._request;
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpTimeout = function(request3) {
        if (this._request !== request3) {
          return;
        }
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("timeout");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpRequestError = function(request3, error2) {
        if (this._request !== request3) {
          return;
        }
        this._setError();
        request3.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._dispatchProgress = function(eventType) {
        var event = new XMLHttpRequest3.ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
      };
      XMLHttpRequest3.prototype._setError = function() {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
      };
      XMLHttpRequest3.prototype._parseUrl = function(urlString, user, password) {
        var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
        var xhrUrl = url.parse(absoluteUrl, false, true);
        xhrUrl.hash = null;
        var _a2 = (xhrUrl.auth || "").split(":"), xhrUser = _a2[0], xhrPassword = _a2[1];
        if (xhrUser || xhrPassword || user || password) {
          xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
        }
        return xhrUrl;
      };
      XMLHttpRequest3.prototype._parseResponseHeaders = function(response) {
        this._responseHeaders = {};
        for (var name_1 in response.headers) {
          var loweredName = name_1.toLowerCase();
          if (this._privateHeaders[loweredName]) {
            continue;
          }
          this._responseHeaders[loweredName] = response.headers[name_1];
        }
        if (this._mimeOverride != null) {
          this._responseHeaders["content-type"] = this._mimeOverride;
        }
      };
      XMLHttpRequest3.prototype._parseResponse = function() {
        var buffer = Buffer2.concat(this._responseParts);
        this._responseParts = null;
        switch (this.responseType) {
          case "json":
            this.responseText = null;
            try {
              this.response = JSON.parse(buffer.toString("utf-8"));
            } catch (_a2) {
              this.response = null;
            }
            return;
          case "buffer":
            this.responseText = null;
            this.response = buffer;
            return;
          case "arraybuffer":
            this.responseText = null;
            var arrayBuffer = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(arrayBuffer);
            for (var i4 = 0; i4 < buffer.length; i4++) {
              view[i4] = buffer[i4];
            }
            this.response = arrayBuffer;
            return;
          case "text":
          default:
            try {
              this.responseText = buffer.toString(this._parseResponseEncoding());
            } catch (_b) {
              this.responseText = buffer.toString("binary");
            }
            this.response = this.responseText;
        }
      };
      XMLHttpRequest3.prototype._parseResponseEncoding = function() {
        return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
      };
      XMLHttpRequest3.ProgressEvent = progress_event_1.ProgressEvent;
      XMLHttpRequest3.InvalidStateError = errors_1.InvalidStateError;
      XMLHttpRequest3.NetworkError = errors_1.NetworkError;
      XMLHttpRequest3.SecurityError = errors_1.SecurityError;
      XMLHttpRequest3.SyntaxError = errors_1.SyntaxError;
      XMLHttpRequest3.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
      XMLHttpRequest3.UNSENT = 0;
      XMLHttpRequest3.OPENED = 1;
      XMLHttpRequest3.HEADERS_RECEIVED = 2;
      XMLHttpRequest3.LOADING = 3;
      XMLHttpRequest3.DONE = 4;
      XMLHttpRequest3.cookieJar = Cookie.CookieJar();
      return XMLHttpRequest3;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequest = XMLHttpRequest2;
    XMLHttpRequest2.prototype.nodejsHttpAgent = http.globalAgent;
    XMLHttpRequest2.prototype.nodejsHttpsAgent = https.globalAgent;
    XMLHttpRequest2.prototype.nodejsBaseUrl = null;
  }
});

// node_modules/xhr2-cookies/dist/index.js
var require_dist = __commonJS({
  "node_modules/xhr2-cookies/dist/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_xml_http_request());
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
  }
});

// node_modules/@walletconnect/http-connection/node_modules/bn.js/lib/bn.js
var require_bn4 = __commonJS({
  "node_modules/@walletconnect/http-connection/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 <<= 4;
          if (c4 >= 49 && c4 <= 54) {
            r5 |= c4 - 49 + 10;
          } else if (c4 >= 17 && c4 <= 22) {
            r5 |= c4 - 17 + 10;
          } else {
            r5 |= c4 & 15;
          }
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        for (i4 = number.length - 6, j4 = 0; i4 >= start; i4 -= 6) {
          w6 = parseHex(number, i4, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j4++;
          }
        }
        if (i4 + 6 !== start) {
          w6 = parseHex(number, start, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          r5.strip();
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/web3-provider/node_modules/bn.js/lib/bn.js
var require_bn5 = __commonJS({
  "node_modules/@walletconnect/web3-provider/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        Buffer4 = require_buffer().Buffer;
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base2 === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base2, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 <<= 4;
          if (c4 >= 49 && c4 <= 54) {
            r5 |= c4 - 49 + 10;
          } else if (c4 >= 17 && c4 <= 22) {
            r5 |= c4 - 17 + 10;
          } else {
            r5 |= c4 & 15;
          }
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        for (i4 = number.length - 6, j4 = 0; i4 >= start; i4 -= 6) {
          w6 = parseHex(number, i4, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
          off3 += 24;
          if (off3 >= 26) {
            off3 -= 26;
            j4++;
          }
        }
        if (i4 + 6 !== start) {
          w6 = parseHex(number, start, i4 + 6);
          this.words[j4] |= w6 << off3 & 67108863;
          this.words[j4 + 1] |= w6 >>> 26 - off3 & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          r5.strip();
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node-modules-polyfills-commonjs:events
var require_events = __commonJS({
  "node-modules-polyfills-commonjs:events"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_events(), __toCommonJS(events_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:util
var require_util = __commonJS({
  "node-modules-polyfills-commonjs:util"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_util(), __toCommonJS(util_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer2.from(hash.digest());
      };
    }
    exports.createHashFunction = createHashFunction;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    function ownKeys2(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4] != null ? arguments[i4] : {};
        if (i4 % 2) {
          ownKeys2(Object(source), true).forEach(function(key2) {
            _defineProperty2(target, key2, source[key2]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys2(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props2) {
      for (var i4 = 0; i4 < props2.length; i4++) {
        var descriptor = props2[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer4 = _require.Buffer;
    var _require2 = require_util();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList2, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s4) {
          if (this.length === 0)
            return "";
          var p5 = this.head;
          var ret = "" + p5.data;
          while (p5 = p5.next) {
            ret += s4 + p5.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat4(n4) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n4 >>> 0);
          var p5 = this.head;
          var i4 = 0;
          while (p5) {
            copyBuffer(p5.data, ret, i4);
            i4 += p5.data.length;
            p5 = p5.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n4, hasStrings) {
          var ret;
          if (n4 < this.head.data.length) {
            ret = this.head.data.slice(0, n4);
            this.head.data = this.head.data.slice(n4);
          } else if (n4 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n4) : this._getBuffer(n4);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n4) {
          var p5 = this.head;
          var c4 = 1;
          var ret = p5.data;
          n4 -= ret.length;
          while (p5 = p5.next) {
            var str = p5.data;
            var nb = n4 > str.length ? str.length : n4;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n4);
            n4 -= nb;
            if (n4 === 0) {
              if (nb === str.length) {
                ++c4;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = str.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n4) {
          var ret = Buffer4.allocUnsafe(n4);
          var p5 = this.head;
          var c4 = 1;
          p5.data.copy(ret);
          n4 -= p5.data.length;
          while (p5 = p5.next) {
            var buf = p5.data;
            var nb = n4 > buf.length ? buf.length : n4;
            buf.copy(ret, ret.length - n4, 0, nb);
            n4 -= nb;
            if (n4 === 0) {
              if (nb === buf.length) {
                ++c4;
                if (p5.next)
                  this.head = p5.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p5;
                p5.data = buf.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_5, options) {
          return inspect4(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList2;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage2(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i4) {
          return String(i4);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes3(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes3(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    if (typeof Object.create === "function") {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util-deprecate/browser.js
var require_browser3 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = deprecate2;
    function deprecate2(fn2, msg) {
      if (config3("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config3("throwDeprecation")) {
            throw new Error(msg);
          } else if (config3("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    }
    function config3(name) {
      try {
        if (!window.localStorage)
          return false;
      } catch (_5) {
        return false;
      }
      var val = window.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Writable2;
    function CorkedRequest2(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState2;
    var internalUtil = {
      deprecate: require_browser3()
    };
    var Stream2 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = window.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop2() {
    }
    function WritableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite2(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest2(this);
    }
    WritableState2.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState2.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_5) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState2;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState2(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd2(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process.nextTick(cb, er2);
    }
    function validChunk2(stream, state, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop2;
      if (state.ending)
        writeAfterEnd2(this, cb);
      else if (isBuf || validChunk2(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer2(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk2(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk2(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite2(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError2(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er2);
        process.nextTick(finishMaybe2, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe2(stream, state);
      }
    }
    function onwriteStateUpdate2(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite2(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate2(state);
      if (er2)
        onwriteError2(stream, state, sync, er2, cb);
      else {
        var finished = needFinish2(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer2(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite2, stream, state, finished, cb);
        } else {
          afterWrite2(stream, state, finished, cb);
        }
      }
    }
    function afterWrite2(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain2(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe2(stream, state);
    }
    function onwriteDrain2(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer2(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l5 = state.bufferedRequestCount;
        var buffer = new Array(l5);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest2(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite2(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable2(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish2(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe2(stream, state);
      });
    }
    function prefinish2(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe2(stream, state) {
      var need = needFinish2(state);
      if (need) {
        prefinish2(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable2(stream, state, cb) {
      state.ending = true;
      finishMaybe2(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var objectKeys3 = Object.keys || function(obj) {
      var keys3 = [];
      for (var key2 in obj) {
        keys3.push(key2);
      }
      return keys3;
    };
    module.exports = Duplex2;
    var Readable2 = require_stream_readable();
    var Writable2 = require_stream_writable();
    require_inherits_browser()(Duplex2, Readable2);
    {
      keys2 = objectKeys3(Writable2.prototype);
      for (v5 = 0; v5 < keys2.length; v5++) {
        method = keys2[v5];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys2;
    var method;
    var v5;
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend2);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend2() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT2, this);
    }
    function onEndNT2(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var buffer = require_buffer();
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill3, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill3 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill3, encoding);
        } else {
          buf.fill(fill3);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var isEncoding3 = Buffer4.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding3 || !isEncoding3(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer4.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r5;
      var i4;
      if (this.lastNeed) {
        r5 = this.fillLast(buf);
        if (r5 === void 0)
          return "";
        i4 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i4 = 0;
      }
      if (i4 < buf.length)
        return r5 ? r5 + this.text(buf, i4) : this.text(buf, i4);
      return r5 || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j4 = buf.length - 1;
      if (j4 < i4)
        return 0;
      var nb = utf8CheckByte(buf[j4]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j4 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j4]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j4 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j4]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p5) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p5 = this.lastTotal - this.lastNeed;
      var r5 = utf8CheckExtraBytes(this, buf, p5);
      if (r5 !== void 0)
        return r5;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p5, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p5, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r5 + "\uFFFD";
      return r5;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r5 = buf.toString("utf16le", i4);
        if (r5) {
          var c4 = r5.charCodeAt(r5.length - 1);
          if (c4 >= 55296 && c4 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r5.slice(0, -1);
          }
        }
        return r5;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r5 + this.lastChar.toString("utf16le", 0, end);
      }
      return r5;
    }
    function base64Text(buf, i4) {
      var n4 = (buf.length - i4) % 3;
      if (n4 === 0)
        return buf.toString("base64", i4);
      this.lastNeed = 3 - n4;
      this.lastTotal = 3;
      if (n4 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i4, buf.length - n4);
    }
    function base64End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r5;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once4(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend2 = function onend3() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend2);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend2);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var _Object$setPrototypeO;
    function _defineProperty2(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done2) {
      return {
        value,
        done: done2
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error2 = this[kError];
        if (error2 !== null) {
          return Promise.reject(error2);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty2(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState2;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = window.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList2 = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder2;
    var createReadableStreamAsyncIterator;
    var from3;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener3(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState2(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList2();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder2(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState2(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk2(this, chunk, null, true, false);
    };
    function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk2(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid2(state, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore2(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore2(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable2(stream);
      }
      maybeReadMore2(stream, state);
    }
    function chunkInvalid2(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder2)
        StringDecoder2 = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p5 = this._readableState.buffer.head;
      var content = "";
      while (p5 !== null) {
        content += decoder.write(p5.data);
        p5 = p5.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM2 = 1073741824;
    function computeNewHighWaterMark2(n4) {
      if (n4 >= MAX_HWM2) {
        n4 = MAX_HWM2;
      } else {
        n4--;
        n4 |= n4 >>> 1;
        n4 |= n4 >>> 2;
        n4 |= n4 >>> 4;
        n4 |= n4 >>> 8;
        n4 |= n4 >>> 16;
        n4++;
      }
      return n4;
    }
    function howMuchToRead2(n4, state) {
      if (n4 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n4 !== n4) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n4 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark2(n4);
      if (n4 <= state.length)
        return n4;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n4) {
      debug2("read", n4);
      n4 = parseInt(n4, 10);
      var state = this._readableState;
      var nOrig = n4;
      if (n4 !== 0)
        state.emittedReadable = false;
      if (n4 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable2(this);
        else
          emitReadable2(this);
        return null;
      }
      n4 = howMuchToRead2(n4, state);
      if (n4 === 0 && state.ended) {
        if (state.length === 0)
          endReadable2(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n4 < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n4 = howMuchToRead2(nOrig, state);
      }
      var ret;
      if (n4 > 0)
        ret = fromList2(n4, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n4 = 0;
      } else {
        state.length -= n4;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n4 && state.ended)
          endReadable2(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk2(stream, state) {
      debug2("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable2(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_2(stream);
        }
      }
    }
    function emitReadable2(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_2, stream);
      }
    }
    function emitReadable_2(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow2(stream);
    }
    function maybeReadMore2(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_2, stream, state);
      }
    }
    function maybeReadMore_2(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n4) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend2 : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend2() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain2(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf4(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug2("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener3(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain2(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow2(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i4 = 0; i4 < len; i4++) {
          dests[i4].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf4(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn2) {
      var res = Stream2.prototype.on.call(this, ev, fn2);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable2(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick2, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn2) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn2);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick2(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_2, stream, state);
      }
    }
    function resume_2(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow2(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow2(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      for (var n4 = 0; n4 < kProxyEvents.length; n4++) {
        stream.on(kProxyEvents[n4], this.emit.bind(this, kProxyEvents[n4]));
      }
      this._read = function(n5) {
        debug2("wrapped _read", n5);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList2;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList2(n4, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n4 || n4 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n4, state.decoder);
      }
      return ret;
    }
    function endReadable2(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT2, state, stream);
      }
    }
    function endReadableNT2(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from3 === void 0) {
          from3 = require_from_browser();
        }
        return from3(Readable2, iterable, opts);
      };
    }
    function indexOf4(xs2, x5) {
      for (var i4 = 0, l5 = xs2.length; i4 < l5; i4++) {
        if (xs2[i4] === x5)
          return i4;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = Transform2;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex();
    require_inherits_browser()(Transform2, Duplex2);
    function afterTransform2(er2, data) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform2.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish2);
    }
    function prefinish2() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done2(_this, er2, data);
        });
      } else {
        done2(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n4) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done2(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = PassThrough2;
    var Transform2 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var eos;
    function once4(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once4(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe(from3, to2) {
      return from3.pipe(to2);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error2;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var { Transform: Transform2 } = require_readable_browser();
    module.exports = (KeccakState) => class Keccak extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error2 = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      _flush(callback) {
        let error2 = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      update(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var { Transform: Transform2 } = require_readable_browser();
    module.exports = (KeccakState) => class Shake extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error2 = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      }
      _flush() {
      }
      _read(size) {
        this.push(this.squeeze(size));
      }
      update(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s4) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s4[0] ^ s4[10] ^ s4[20] ^ s4[30] ^ s4[40];
        const hi0 = s4[1] ^ s4[11] ^ s4[21] ^ s4[31] ^ s4[41];
        const lo1 = s4[2] ^ s4[12] ^ s4[22] ^ s4[32] ^ s4[42];
        const hi1 = s4[3] ^ s4[13] ^ s4[23] ^ s4[33] ^ s4[43];
        const lo2 = s4[4] ^ s4[14] ^ s4[24] ^ s4[34] ^ s4[44];
        const hi2 = s4[5] ^ s4[15] ^ s4[25] ^ s4[35] ^ s4[45];
        const lo3 = s4[6] ^ s4[16] ^ s4[26] ^ s4[36] ^ s4[46];
        const hi3 = s4[7] ^ s4[17] ^ s4[27] ^ s4[37] ^ s4[47];
        const lo4 = s4[8] ^ s4[18] ^ s4[28] ^ s4[38] ^ s4[48];
        const hi4 = s4[9] ^ s4[19] ^ s4[29] ^ s4[39] ^ s4[49];
        let lo5 = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s4[0] ^ lo5;
        const t1shi0 = s4[1] ^ hi;
        const t1slo5 = s4[10] ^ lo5;
        const t1shi5 = s4[11] ^ hi;
        const t1slo10 = s4[20] ^ lo5;
        const t1shi10 = s4[21] ^ hi;
        const t1slo15 = s4[30] ^ lo5;
        const t1shi15 = s4[31] ^ hi;
        const t1slo20 = s4[40] ^ lo5;
        const t1shi20 = s4[41] ^ hi;
        lo5 = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s4[2] ^ lo5;
        const t1shi1 = s4[3] ^ hi;
        const t1slo6 = s4[12] ^ lo5;
        const t1shi6 = s4[13] ^ hi;
        const t1slo11 = s4[22] ^ lo5;
        const t1shi11 = s4[23] ^ hi;
        const t1slo16 = s4[32] ^ lo5;
        const t1shi16 = s4[33] ^ hi;
        const t1slo21 = s4[42] ^ lo5;
        const t1shi21 = s4[43] ^ hi;
        lo5 = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s4[4] ^ lo5;
        const t1shi2 = s4[5] ^ hi;
        const t1slo7 = s4[14] ^ lo5;
        const t1shi7 = s4[15] ^ hi;
        const t1slo12 = s4[24] ^ lo5;
        const t1shi12 = s4[25] ^ hi;
        const t1slo17 = s4[34] ^ lo5;
        const t1shi17 = s4[35] ^ hi;
        const t1slo22 = s4[44] ^ lo5;
        const t1shi22 = s4[45] ^ hi;
        lo5 = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s4[6] ^ lo5;
        const t1shi3 = s4[7] ^ hi;
        const t1slo8 = s4[16] ^ lo5;
        const t1shi8 = s4[17] ^ hi;
        const t1slo13 = s4[26] ^ lo5;
        const t1shi13 = s4[27] ^ hi;
        const t1slo18 = s4[36] ^ lo5;
        const t1shi18 = s4[37] ^ hi;
        const t1slo23 = s4[46] ^ lo5;
        const t1shi23 = s4[47] ^ hi;
        lo5 = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s4[8] ^ lo5;
        const t1shi4 = s4[9] ^ hi;
        const t1slo9 = s4[18] ^ lo5;
        const t1shi9 = s4[19] ^ hi;
        const t1slo14 = s4[28] ^ lo5;
        const t1shi14 = s4[29] ^ hi;
        const t1slo19 = s4[38] ^ lo5;
        const t1shi19 = s4[39] ^ hi;
        const t1slo24 = s4[48] ^ lo5;
        const t1shi24 = s4[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s4[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s4[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s4[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s4[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s4[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s4[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s4[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s4[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s4[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s4[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s4[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s4[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s4[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s4[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s4[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s4[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s4[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s4[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s4[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s4[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s4[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s4[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s4[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s4[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s4[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s4[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s4[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s4[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s4[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s4[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s4[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s4[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s4[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s4[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s4[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s4[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s4[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s4[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s4[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s4[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s4[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s4[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s4[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s4[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s4[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s4[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s4[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s4[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s4[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s4[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s4[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s4[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i4 = 0; i4 < 50; ++i4)
        this.state[i4] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i4 = 0; i4 < data.length; ++i4) {
        this.state[~~(this.count / 4)] ^= data[i4] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer2.alloc(length);
      for (let i4 = 0; i4 < length; ++i4) {
        output[i4] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i4 = 0; i4 < 50; ++i4)
        dest.state[i4] = this.state[i4];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_api()(require_keccak2());
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js();
    exports.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var errors2 = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert3(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name, value, length) {
      assert3(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
          assert3(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
          assert3(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert3(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function")
        output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert3(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors2.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SECKEY_INVALID);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert3(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert3(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors2.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert3(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert3(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors2.SIGN);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert3(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.RECOVER);
            case 3:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert3(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert3(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn6 = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c4 = string.charCodeAt(index);
        if (c4 >= 65 && c4 <= 70) {
          return c4 - 55;
        } else if (c4 >= 97 && c4 <= 102) {
          return c4 - 87;
        } else {
          return c4 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r5 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r5 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off3 = 0;
        var j4 = 0;
        var w6;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w6 = parseHexByte(number, start, i4) << off3;
            this.words[j4] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j4 += 1;
              this.words[j4] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w6 = parseHexByte(number, start, i4) << off3;
            this.words[j4] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j4 += 1;
              this.words[j4] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            r5 += c4 - 49 + 10;
          } else if (c4 >= 17) {
            r5 += c4 - 17 + 10;
          } else {
            r5 += c4;
          }
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN6.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16);
      };
      BN6.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer4 !== "undefined");
        return this.toArrayLike(Buffer4, endian, length);
      };
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b3, i4;
        var q5 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength3; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[reqLength - i4 - 1] = b3;
          }
        } else {
          for (i4 = 0; !q5.isZero(); i4++) {
            b3 = q5.andln(255);
            q5.iushrn(8);
            res[i4] = b3;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off3] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this.strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out.strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this.strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN6.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          if (r5.strip !== void 0) {
            r5.strip();
          } else {
            r5._strip();
          }
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual(l5, r5, msg) {
      if (l5 != r5)
        throw new Error(msg || "Assertion failed: " + l5 + " != " + r5);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i4 = 0; i4 < msg.length; i4++)
          res[i4] = msg[i4] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i4 = 0; i4 < msg.length; i4 += 2)
          res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
      } else {
        for (var i4 = 0; i4 < msg.length; i4++) {
          var c4 = msg.charCodeAt(i4);
          var hi = c4 >> 8;
          var lo2 = c4 & 255;
          if (hi)
            res.push(hi, lo2);
          else
            res.push(lo2);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++)
        res += zero2(msg[i4].toString(16));
      return res;
    }
    utils.toHex = toHex3;
    utils.encode = function encode2(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = exports;
    var BN6 = require_bn6();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils3();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w6, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws2 = 1 << w6 + 1;
      var k5 = num.clone();
      for (var i4 = 0; i4 < naf.length; i4++) {
        var z4;
        var mod = k5.andln(ws2 - 1);
        if (k5.isOdd()) {
          if (mod > (ws2 >> 1) - 1)
            z4 = (ws2 >> 1) - mod;
          else
            z4 = mod;
          k5.isubn(z4);
        } else {
          z4 = 0;
        }
        naf[i4] = z4;
        k5.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k12, k22) {
      var jsf = [
        [],
        []
      ];
      k12 = k12.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k12.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k12.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u12;
        if ((m14 & 1) === 0) {
          u12 = 0;
        } else {
          m8 = k12.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u12 = -m14;
          else
            u12 = m14;
        }
        jsf[0].push(u12);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u12 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k12.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key2 = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN6(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node-modules-polyfills:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "node-modules-polyfills:crypto"() {
    init_virtual_process_polyfill();
    init_buffer();
    crypto_default = {};
  }
});

// node-modules-polyfills-commonjs:crypto
var require_crypto2 = __commonJS({
  "node-modules-polyfills-commonjs:crypto"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var r5;
    module.exports = function rand(len) {
      if (!r5)
        r5 = new Rand(null);
      return r5.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n4) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n4);
      var res = new Uint8Array(n4);
      for (var i4 = 0; i4 < res.length; i4++)
        res[i4] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n4) {
          var arr = new Uint8Array(n4);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n4) {
          var arr = new Uint8Array(n4);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require_crypto2();
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n4) {
          return crypto.randomBytes(n4);
        };
      } catch (e5) {
      }
    }
    var crypto;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert3 = utils.assert;
    function BaseCurve(type2, conf) {
      this.type = type2;
      this.p = new BN6(conf.p, 16);
      this.red = conf.prime ? BN6.red(conf.prime) : BN6.mont(this.p);
      this.zero = new BN6(0).toRed(this.red);
      this.one = new BN6(1).toRed(this.red);
      this.two = new BN6(2).toRed(this.red);
      this.n = conf.n && new BN6(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k5) {
      assert3(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF(k5, 1, this._bitLength);
      var I4 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I4 /= 3;
      var repr = [];
      var j4;
      var nafW;
      for (j4 = 0; j4 < naf.length; j4 += doubles.step) {
        nafW = 0;
        for (var l5 = j4 + doubles.step - 1; l5 >= j4; l5--)
          nafW = (nafW << 1) + naf[l5];
        repr.push(nafW);
      }
      var a4 = this.jpoint(null, null, null);
      var b3 = this.jpoint(null, null, null);
      for (var i4 = I4; i4 > 0; i4--) {
        for (j4 = 0; j4 < repr.length; j4++) {
          nafW = repr[j4];
          if (nafW === i4)
            b3 = b3.mixedAdd(doubles.points[j4]);
          else if (nafW === -i4)
            b3 = b3.mixedAdd(doubles.points[j4].neg());
        }
        a4 = a4.add(b3);
      }
      return a4.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p5, k5) {
      var w6 = 4;
      var nafPoints = p5._getNAFPoints(w6);
      w6 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k5, w6, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i4 = naf.length - 1; i4 >= 0; i4--) {
        for (var l5 = 0; i4 >= 0 && naf[i4] === 0; i4--)
          l5++;
        if (i4 >= 0)
          l5++;
        acc = acc.dblp(l5);
        if (i4 < 0)
          break;
        var z4 = naf[i4];
        assert3(z4 !== 0);
        if (p5.type === "affine") {
          if (z4 > 0)
            acc = acc.mixedAdd(wnd[z4 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z4 - 1 >> 1].neg());
        } else {
          if (z4 > 0)
            acc = acc.add(wnd[z4 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z4 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i4;
      var j4;
      var p5;
      for (i4 = 0; i4 < len; i4++) {
        p5 = points[i4];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i4] = nafPoints.wnd;
        wnd[i4] = nafPoints.points;
      }
      for (i4 = len - 1; i4 >= 1; i4 -= 2) {
        var a4 = i4 - 1;
        var b3 = i4;
        if (wndWidth[a4] !== 1 || wndWidth[b3] !== 1) {
          naf[a4] = getNAF(coeffs[a4], wndWidth[a4], this._bitLength);
          naf[b3] = getNAF(coeffs[b3], wndWidth[b3], this._bitLength);
          max = Math.max(naf[a4].length, max);
          max = Math.max(naf[b3].length, max);
          continue;
        }
        var comb = [
          points[a4],
          null,
          null,
          points[b3]
        ];
        if (points[a4].y.cmp(points[b3].y) === 0) {
          comb[1] = points[a4].add(points[b3]);
          comb[2] = points[a4].toJ().mixedAdd(points[b3].neg());
        } else if (points[a4].y.cmp(points[b3].y.redNeg()) === 0) {
          comb[1] = points[a4].toJ().mixedAdd(points[b3]);
          comb[2] = points[a4].add(points[b3].neg());
        } else {
          comb[1] = points[a4].toJ().mixedAdd(points[b3]);
          comb[2] = points[a4].toJ().mixedAdd(points[b3].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a4], coeffs[b3]);
        max = Math.max(jsf[0].length, max);
        naf[a4] = new Array(max);
        naf[b3] = new Array(max);
        for (j4 = 0; j4 < max; j4++) {
          var ja2 = jsf[0][j4] | 0;
          var jb = jsf[1][j4] | 0;
          naf[a4][j4] = index[(ja2 + 1) * 3 + (jb + 1)];
          naf[b3][j4] = 0;
          wnd[a4] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i4 = max; i4 >= 0; i4--) {
        var k5 = 0;
        while (i4 >= 0) {
          var zero = true;
          for (j4 = 0; j4 < len; j4++) {
            tmp[j4] = naf[j4][i4] | 0;
            if (tmp[j4] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i4--;
        }
        if (i4 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i4 < 0)
          break;
        for (j4 = 0; j4 < len; j4++) {
          var z4 = tmp[j4];
          p5;
          if (z4 === 0)
            continue;
          else if (z4 > 0)
            p5 = wnd[j4][z4 - 1 >> 1];
          else if (z4 < 0)
            p5 = wnd[j4][-z4 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i4 = 0; i4 < len; i4++)
        wnd[i4] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type2) {
      this.curve = curve;
      this.type = type2;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert3(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert3(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x5 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x5);
      return [4].concat(x5, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode2(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i4 = 0; i4 < power; i4 += step) {
        for (var j4 = 0; j4 < step; j4++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i4 = 1; i4 < max; i4++)
        res[i4] = res[i4 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k5) {
      var r5 = this;
      for (var i4 = 0; i4 < k5; i4++)
        r5 = r5.dbl();
      return r5;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var BN6 = require_bn6();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN6(conf.a, 16).toRed(this.red);
      this.b = new BN6(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN6(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN6(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert3(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN6(vec.a, 16),
            b: new BN6(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN6.mont(num);
      var tinv = new BN6(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s4 = new BN6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s4).fromRed();
      var l22 = ntinv.redSub(s4).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u5 = lambda;
      var v5 = this.n.clone();
      var x12 = new BN6(1);
      var y12 = new BN6(0);
      var x22 = new BN6(0);
      var y22 = new BN6(1);
      var a02;
      var b02;
      var a12;
      var b12;
      var a22;
      var b22;
      var prevR;
      var i4 = 0;
      var r5;
      var x5;
      while (u5.cmpn(0) !== 0) {
        var q5 = v5.div(u5);
        r5 = v5.sub(q5.mul(u5));
        x5 = x22.sub(q5.mul(x12));
        var y5 = y22.sub(q5.mul(y12));
        if (!a12 && r5.cmp(aprxSqrt) < 0) {
          a02 = prevR.neg();
          b02 = x12;
          a12 = r5.neg();
          b12 = x5;
        } else if (a12 && ++i4 === 2) {
          break;
        }
        prevR = r5;
        v5 = u5;
        u5 = r5;
        x22 = x12;
        x12 = x5;
        y22 = y12;
        y12 = y5;
      }
      a22 = r5.neg();
      b22 = x5;
      var len1 = a12.sqr().add(b12.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a02;
        b22 = b02;
      }
      if (a12.negative) {
        a12 = a12.neg();
        b12 = b12.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a12, b: b12 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
      var basis = this.endo.basis;
      var v12 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k5).divRound(this.n);
      var c22 = v12.b.neg().mul(k5).divRound(this.n);
      var p12 = c1.mul(v12.a);
      var p22 = c22.mul(v22.a);
      var q12 = c1.mul(v12.b);
      var q22 = c22.mul(v22.b);
      var k12 = k5.sub(p12).sub(p22);
      var k22 = q12.add(q22).neg();
      return { k1: k12, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x5, odd) {
      x5 = new BN6(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var y22 = x5.redSqr().redMul(x5).redIAdd(x5.redMul(this.a)).redIAdd(this.b);
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x5 = point.x;
      var y5 = point.y;
      var ax = this.a.redMul(x5);
      var rhs = x5.redSqr().redMul(x5).redIAdd(ax).redIAdd(this.b);
      return y5.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i4 = 0; i4 < points.length; i4++) {
        var split = this._endoSplit(coeffs[i4]);
        var p5 = points[i4];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i4 * 2] = p5;
        npoints[i4 * 2 + 1] = beta;
        ncoeffs[i4 * 2] = split.k1;
        ncoeffs[i4 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
      for (var j4 = 0; j4 < i4 * 2; j4++) {
        npoints[j4] = null;
        ncoeffs[j4] = null;
      }
      return res;
    };
    function Point(curve, x5, y5, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x5 === null && y5 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x5, y5, isRed) {
      return new Point(this, x5, y5, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON3() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c4 = this.y.redSub(p5.y);
      if (c4.cmpn(0) !== 0)
        c4 = c4.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c4.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c4.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a4 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c4 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
      var nx = c4.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c4.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k5) {
      k5 = new BN6(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k12, p22, k22) {
      var points = [this, p22];
      var coeffs = [k12, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k12, p22, k22) {
      var points = [this, p22];
      var coeffs = [k12, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x5, y5, z4) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x5 === null && y5 === null && z4 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN6(0);
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        this.z = new BN6(z4, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x5, y5, z4) {
      return new JPoint(this, x5, y5, z4);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u12 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s12 = this.y.redMul(pz2.redMul(p5.z));
      var s22 = p5.y.redMul(z22.redMul(this.z));
      var h5 = u12.redSub(u22);
      var r5 = s12.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r5.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v5 = u12.redMul(h22);
      var nx = r5.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
      var ny = r5.redMul(v5.redISub(nx)).redISub(s12.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u12 = this.x;
      var u22 = p5.x.redMul(z22);
      var s12 = this.y;
      var s22 = p5.y.redMul(z22).redMul(this.z);
      var h5 = u12.redSub(u22);
      var r5 = s12.redSub(s22);
      if (h5.cmpn(0) === 0) {
        if (r5.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h5.redSqr();
      var h32 = h22.redMul(h5);
      var v5 = u12.redMul(h22);
      var nx = r5.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
      var ny = r5.redMul(v5.redISub(nx)).redISub(s12.redMul(h32));
      var nz = this.z.redMul(h5);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r5 = this;
        for (i4 = 0; i4 < pow; i4++)
          r5 = r5.dbl();
        return r5;
      }
      var a4 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i4 = 0; i4 < pow; i4++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c4 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
        var t12 = jx.redMul(jyd2);
        var nx = c4.redSqr().redISub(t12.redAdd(t12));
        var t22 = t12.redISub(nx);
        var dny = c4.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i4 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s4 = s4.redIAdd(s4);
        var m5 = xx.redAdd(xx).redIAdd(xx);
        var t5 = m5.redSqr().redISub(s4).redISub(s4);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t5;
        ny = m5.redMul(s4.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a4 = this.x.redSqr();
        var b3 = this.y.redSqr();
        var c4 = b3.redSqr();
        var d4 = this.x.redAdd(b3).redSqr().redISub(a4).redISub(c4);
        d4 = d4.redIAdd(d4);
        var e5 = a4.redAdd(a4).redIAdd(a4);
        var f5 = e5.redSqr();
        var c8 = c4.redIAdd(c4);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d4).redISub(d4);
        ny = e5.redMul(d4.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s4 = s4.redIAdd(s4);
        var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t5 = m5.redSqr().redISub(s4).redISub(s4);
        nx = t5;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m5.redMul(s4.redISub(t5)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a4 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c4 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t12 = jxd4.redMul(jy2);
      var nx = c4.redSqr().redISub(t12.redAdd(t12));
      var t22 = t12.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c4.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m5 = xx.redAdd(xx).redIAdd(xx);
      var mm = m5.redSqr();
      var e5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e5 = e5.redIAdd(e5);
      e5 = e5.redAdd(e5).redIAdd(e5);
      e5 = e5.redISub(mm);
      var ee3 = e5.redSqr();
      var t5 = yyyy.redIAdd(yyyy);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      t5 = t5.redIAdd(t5);
      var u5 = m5.redIAdd(e5).redSqr().redISub(mm).redISub(ee3).redISub(t5);
      var yyu4 = yy.redMul(u5);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee3).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u5.redMul(t5.redISub(u5)).redISub(e5.redMul(ee3)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e5).redSqr().redISub(zz).redISub(ee3);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k5, kbase) {
      k5 = new BN6(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint.prototype.eq = function eq(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x5) {
      var zs2 = this.z.redSqr();
      var rx = x5.toRed(this.curve.red).redMul(zs2);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(zs2);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN6(conf.a, 16).toRed(this.red);
      this.b = new BN6(conf.b, 16).toRed(this.red);
      this.i4 = new BN6(4).toRed(this.red).redInvm();
      this.two = new BN6(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x5 = point.normalize().x;
      var x22 = x5.redSqr();
      var rhs = x22.redMul(x5).redAdd(x22.redMul(this.a)).redAdd(x5);
      var y5 = rhs.redSqrt();
      return y5.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x5, z4) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && z4 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN6(x5, 16);
        this.z = new BN6(z4, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x5, z4) {
      return new Point(this, x5, z4);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a4 = this.x.redAdd(this.z);
      var aa2 = a4.redSqr();
      var b3 = this.x.redSub(this.z);
      var bb = b3.redSqr();
      var c4 = aa2.redSub(bb);
      var nx = aa2.redMul(bb);
      var nz = c4.redMul(bb.redAdd(this.curve.a24.redMul(c4)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p5, diff) {
      var a4 = this.x.redAdd(this.z);
      var b3 = this.x.redSub(this.z);
      var c4 = p5.x.redAdd(p5.z);
      var d4 = p5.x.redSub(p5.z);
      var da2 = d4.redMul(a4);
      var cb = c4.redMul(b3);
      var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da2.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k5) {
      var t5 = k5.clone();
      var a4 = this;
      var b3 = this.curve.point(null, null);
      var c4 = this;
      for (var bits = []; t5.cmpn(0) !== 0; t5.iushrn(1))
        bits.push(t5.andln(1));
      for (var i4 = bits.length - 1; i4 >= 0; i4--) {
        if (bits[i4] === 0) {
          a4 = a4.diffAdd(b3, c4);
          b3 = b3.dbl();
        } else {
          b3 = a4.diffAdd(b3, c4);
          a4 = a4.dbl();
        }
      }
      return b3;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var BN6 = require_bn6();
    var inherits2 = require_inherits_browser();
    var Base = require_base();
    var assert3 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN6(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN6(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN6(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert3(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x5, y5, z4, t5) {
      return this.point(x5, y5, z4, t5);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x5, odd) {
      x5 = new BN6(x5, 16);
      if (!x5.red)
        x5 = x5.toRed(this.red);
      var x22 = x5.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y5 = y22.redSqrt();
      if (y5.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y5.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y5 = y5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y5, odd) {
      y5 = new BN6(y5, 16);
      if (!y5.red)
        y5 = y5.toRed(this.red);
      var y22 = y5.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y5);
      }
      var x5 = x22.redSqrt();
      if (x5.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x5.fromRed().isOdd() !== odd)
        x5 = x5.redNeg();
      return this.point(x5, y5);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x5, y5, z4, t5) {
      Base.BasePoint.call(this, curve, "projective");
      if (x5 === null && y5 === null && z4 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN6(x5, 16);
        this.y = new BN6(y5, 16);
        this.z = z4 ? new BN6(z4, 16) : this.curve.one;
        this.t = t5 && new BN6(t5, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x5, y5, z4, t5) {
      return new Point(this, x5, y5, z4, t5);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a4 = this.x.redSqr();
      var b3 = this.y.redSqr();
      var c4 = this.z.redSqr();
      c4 = c4.redIAdd(c4);
      var d4 = this.curve._mulA(a4);
      var e5 = this.x.redAdd(this.y).redSqr().redISub(a4).redISub(b3);
      var g4 = d4.redAdd(b3);
      var f5 = g4.redSub(c4);
      var h5 = d4.redSub(b3);
      var nx = e5.redMul(f5);
      var ny = g4.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f5.redMul(g4);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b3 = this.x.redAdd(this.y).redSqr();
      var c4 = this.x.redSqr();
      var d4 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e5;
      var h5;
      var j4;
      if (this.curve.twisted) {
        e5 = this.curve._mulA(c4);
        var f5 = e5.redAdd(d4);
        if (this.zOne) {
          nx = b3.redSub(c4).redSub(d4).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e5.redSub(d4));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h5 = this.z.redSqr();
          j4 = f5.redSub(h5).redISub(h5);
          nx = b3.redSub(c4).redISub(d4).redMul(j4);
          ny = f5.redMul(e5.redSub(d4));
          nz = f5.redMul(j4);
        }
      } else {
        e5 = c4.redAdd(d4);
        h5 = this.curve._mulC(this.z).redSqr();
        j4 = e5.redSub(h5).redSub(h5);
        nx = this.curve._mulC(b3.redISub(e5)).redMul(j4);
        ny = this.curve._mulC(e5).redMul(c4.redISub(d4));
        nz = e5.redMul(j4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p5) {
      var a4 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b3 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c4 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d4 = this.z.redMul(p5.z.redAdd(p5.z));
      var e5 = b3.redSub(a4);
      var f5 = d4.redSub(c4);
      var g4 = d4.redAdd(c4);
      var h5 = b3.redAdd(a4);
      var nx = e5.redMul(f5);
      var ny = g4.redMul(h5);
      var nt = e5.redMul(h5);
      var nz = f5.redMul(g4);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p5) {
      var a4 = this.z.redMul(p5.z);
      var b3 = a4.redSqr();
      var c4 = this.x.redMul(p5.x);
      var d4 = this.y.redMul(p5.y);
      var e5 = this.curve.d.redMul(c4).redMul(d4);
      var f5 = b3.redSub(e5);
      var g4 = b3.redAdd(e5);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c4).redISub(d4);
      var nx = a4.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a4.redMul(g4).redMul(d4.redSub(this.curve._mulA(c4)));
        nz = f5.redMul(g4);
      } else {
        ny = a4.redMul(g4).redMul(d4.redSub(c4));
        nz = this.curve._mulC(f5).redMul(g4);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point.prototype.mul = function mul(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k12, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k12, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k12, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k12, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x5) {
      var rx = x5.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x5.clone();
      var t5 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t5);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils5 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var assert3 = require_minimalistic_assert();
    var inherits2 = require_inherits_browser();
    exports.inherits = inherits2;
    function isSurrogatePair(msg, i4) {
      if ((msg.charCodeAt(i4) & 64512) !== 55296) {
        return false;
      }
      if (i4 < 0 || i4 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i4 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p5 = 0;
          for (var i4 = 0; i4 < msg.length; i4++) {
            var c4 = msg.charCodeAt(i4);
            if (c4 < 128) {
              res[p5++] = c4;
            } else if (c4 < 2048) {
              res[p5++] = c4 >> 6 | 192;
              res[p5++] = c4 & 63 | 128;
            } else if (isSurrogatePair(msg, i4)) {
              c4 = 65536 + ((c4 & 1023) << 10) + (msg.charCodeAt(++i4) & 1023);
              res[p5++] = c4 >> 18 | 240;
              res[p5++] = c4 >> 12 & 63 | 128;
              res[p5++] = c4 >> 6 & 63 | 128;
              res[p5++] = c4 & 63 | 128;
            } else {
              res[p5++] = c4 >> 12 | 224;
              res[p5++] = c4 >> 6 & 63 | 128;
              res[p5++] = c4 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i4 = 0; i4 < msg.length; i4 += 2)
            res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
        }
      } else {
        for (i4 = 0; i4 < msg.length; i4++)
          res[i4] = msg[i4] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex3(msg) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++)
        res += zero2(msg[i4].toString(16));
      return res;
    }
    exports.toHex = toHex3;
    function htonl(w6) {
      var res = w6 >>> 24 | w6 >>> 8 & 65280 | w6 << 8 & 16711680 | (w6 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++) {
        var w6 = msg[i4];
        if (endian === "little")
          w6 = htonl(w6);
        res += zero8(w6.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i4 = 0, k5 = start; i4 < res.length; i4++, k5 += 4) {
        var w6;
        if (endian === "big")
          w6 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
        else
          w6 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
        res[i4] = w6 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i4 = 0, k5 = 0; i4 < msg.length; i4++, k5 += 4) {
        var m5 = msg[i4];
        if (endian === "big") {
          res[k5] = m5 >>> 24;
          res[k5 + 1] = m5 >>> 16 & 255;
          res[k5 + 2] = m5 >>> 8 & 255;
          res[k5 + 3] = m5 & 255;
        } else {
          res[k5 + 3] = m5 >>> 24;
          res[k5 + 2] = m5 >>> 16 & 255;
          res[k5 + 1] = m5 >>> 8 & 255;
          res[k5] = m5 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w6, b3) {
      return w6 >>> b3 | w6 << 32 - b3;
    }
    exports.rotr32 = rotr32;
    function rotl32(w6, b3) {
      return w6 << b3 | w6 >>> 32 - b3;
    }
    exports.rotl32 = rotl32;
    function sum32(a4, b3) {
      return a4 + b3 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a4, b3, c4) {
      return a4 + b3 + c4 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a4, b3, c4, d4) {
      return a4 + b3 + c4 + d4 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a4, b3, c4, d4, e5) {
      return a4 + b3 + c4 + d4 + e5 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo2 = al + bl >>> 0;
      var hi = (lo2 < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo2;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo2 = al + bl >>> 0;
      var hi = (lo2 < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo2 = al + bl;
      return lo2 >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo2 = al + bl + cl + dl;
      return lo2 >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      lo2 = lo2 + el >>> 0;
      carry += lo2 < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo2 = al + bl + cl + dl + el;
      return lo2 >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r5 = al << 32 - num | ah >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r5 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r5, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r5, this.endian);
        for (var i4 = 0; i4 < msg.length; i4 += this._delta32)
          this._update(msg, i4, i4 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k5 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k5 + this.padLength);
      res[0] = 128;
      for (var i4 = 1; i4 < k5; i4++)
        res[i4] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t5 = 8; t5 < this.padLength; t5++)
          res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = len >>> 24 & 255;
        res[i4++] = len >>> 16 & 255;
        res[i4++] = len >>> 8 & 255;
        res[i4++] = len & 255;
      } else {
        res[i4++] = len & 255;
        res[i4++] = len >>> 8 & 255;
        res[i4++] = len >>> 16 & 255;
        res[i4++] = len >>> 24 & 255;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        for (t5 = 8; t5 < this.padLength; t5++)
          res[i4++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var rotr32 = utils.rotr32;
    function ft_1(s4, x5, y5, z4) {
      if (s4 === 0)
        return ch32(x5, y5, z4);
      if (s4 === 1 || s4 === 3)
        return p32(x5, y5, z4);
      if (s4 === 2)
        return maj32(x5, y5, z4);
    }
    exports.ft_1 = ft_1;
    function ch32(x5, y5, z4) {
      return x5 & y5 ^ ~x5 & z4;
    }
    exports.ch32 = ch32;
    function maj32(x5, y5, z4) {
      return x5 & y5 ^ x5 & z4 ^ y5 & z4;
    }
    exports.maj32 = maj32;
    function p32(x5, y5, z4) {
      return x5 ^ y5 ^ z4;
    }
    exports.p32 = p32;
    function s0_256(x5) {
      return rotr32(x5, 2) ^ rotr32(x5, 13) ^ rotr32(x5, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x5) {
      return rotr32(x5, 6) ^ rotr32(x5, 11) ^ rotr32(x5, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x5) {
      return rotr32(x5, 7) ^ rotr32(x5, 18) ^ x5 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x5) {
      return rotr32(x5, 17) ^ rotr32(x5, 19) ^ x5 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i4 = 0; i4 < 16; i4++)
        W3[i4] = msg[start + i4];
      for (; i4 < W3.length; i4++)
        W3[i4] = rotl32(W3[i4 - 3] ^ W3[i4 - 8] ^ W3[i4 - 14] ^ W3[i4 - 16], 1);
      var a4 = this.h[0];
      var b3 = this.h[1];
      var c4 = this.h[2];
      var d4 = this.h[3];
      var e5 = this.h[4];
      for (i4 = 0; i4 < W3.length; i4++) {
        var s4 = ~~(i4 / 20);
        var t5 = sum32_5(rotl32(a4, 5), ft_1(s4, b3, c4, d4), e5, W3[i4], sha1_K[s4]);
        e5 = d4;
        d4 = c4;
        c4 = rotl32(b3, 30);
        b3 = a4;
        a4 = t5;
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b3);
      this.h[2] = sum32(this.h[2], c4);
      this.h[3] = sum32(this.h[3], d4);
      this.h[4] = sum32(this.h[4], e5);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W3 = this.W;
      for (var i4 = 0; i4 < 16; i4++)
        W3[i4] = msg[start + i4];
      for (; i4 < W3.length; i4++)
        W3[i4] = sum32_4(g1_256(W3[i4 - 2]), W3[i4 - 7], g0_256(W3[i4 - 15]), W3[i4 - 16]);
      var a4 = this.h[0];
      var b3 = this.h[1];
      var c4 = this.h[2];
      var d4 = this.h[3];
      var e5 = this.h[4];
      var f5 = this.h[5];
      var g4 = this.h[6];
      var h5 = this.h[7];
      assert3(this.k.length === W3.length);
      for (i4 = 0; i4 < W3.length; i4++) {
        var T12 = sum32_5(h5, s1_256(e5), ch32(e5, f5, g4), this.k[i4], W3[i4]);
        var T22 = sum32(s0_256(a4), maj32(a4, b3, c4));
        h5 = g4;
        g4 = f5;
        f5 = e5;
        e5 = sum32(d4, T12);
        d4 = c4;
        c4 = b3;
        b3 = a4;
        a4 = sum32(T12, T22);
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b3);
      this.h[2] = sum32(this.h[2], c4);
      this.h[3] = sum32(this.h[3], d4);
      this.h[4] = sum32(this.h[4], e5);
      this.h[5] = sum32(this.h[5], f5);
      this.h[6] = sum32(this.h[6], g4);
      this.h[7] = sum32(this.h[7], h5);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W3 = this.W;
      for (var i4 = 0; i4 < 32; i4++)
        W3[i4] = msg[start + i4];
      for (; i4 < W3.length; i4 += 2) {
        var c0_hi = g1_512_hi(W3[i4 - 4], W3[i4 - 3]);
        var c0_lo = g1_512_lo(W3[i4 - 4], W3[i4 - 3]);
        var c1_hi = W3[i4 - 14];
        var c1_lo = W3[i4 - 13];
        var c2_hi = g0_512_hi(W3[i4 - 30], W3[i4 - 29]);
        var c2_lo = g0_512_lo(W3[i4 - 30], W3[i4 - 29]);
        var c3_hi = W3[i4 - 32];
        var c3_lo = W3[i4 - 31];
        W3[i4] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W3[i4 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W3 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W3.length);
      for (var i4 = 0; i4 < W3.length; i4 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i4];
        var c3_lo = this.k[i4 + 1];
        var c4_hi = W3[i4];
        var c4_lo = W3[i4 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ ~xh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ ~xl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ xh & zh ^ yh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ xl & zl ^ yl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A5 = this.h[0];
      var B3 = this.h[1];
      var C4 = this.h[2];
      var D4 = this.h[3];
      var E6 = this.h[4];
      var Ah = A5;
      var Bh = B3;
      var Ch = C4;
      var Dh = D4;
      var Eh = E6;
      for (var j4 = 0; j4 < 80; j4++) {
        var T5 = sum32(
          rotl32(
            sum32_4(A5, f5(j4, B3, C4, D4), msg[r5[j4] + start], K3(j4)),
            s4[j4]
          ),
          E6
        );
        A5 = E6;
        E6 = D4;
        D4 = rotl32(C4, 10);
        C4 = B3;
        B3 = T5;
        T5 = sum32(
          rotl32(
            sum32_4(Ah, f5(79 - j4, Bh, Ch, Dh), msg[rh[j4] + start], Kh(j4)),
            sh[j4]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T5;
      }
      T5 = sum32_3(this.h[1], C4, Dh);
      this.h[1] = sum32_3(this.h[2], D4, Eh);
      this.h[2] = sum32_3(this.h[3], E6, Ah);
      this.h[3] = sum32_3(this.h[4], A5, Bh);
      this.h[4] = sum32_3(this.h[0], B3, Ch);
      this.h[0] = T5;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f5(j4, x5, y5, z4) {
      if (j4 <= 15)
        return x5 ^ y5 ^ z4;
      else if (j4 <= 31)
        return x5 & y5 | ~x5 & z4;
      else if (j4 <= 47)
        return (x5 | ~y5) ^ z4;
      else if (j4 <= 63)
        return x5 & z4 | y5 & ~z4;
      else
        return x5 ^ (y5 | ~z4);
    }
    function K3(j4) {
      if (j4 <= 15)
        return 0;
      else if (j4 <= 31)
        return 1518500249;
      else if (j4 <= 47)
        return 1859775393;
      else if (j4 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j4) {
      if (j4 <= 15)
        return 1352829926;
      else if (j4 <= 31)
        return 1548603684;
      else if (j4 <= 47)
        return 1836072691;
      else if (j4 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r5 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s4 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils5();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key2, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init3(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert3(key2.length <= this.blockSize);
      for (var i4 = key2.length; i4 < this.blockSize; i4++)
        key2.push(0);
      for (i4 = 0; i4 < key2.length; i4++)
        key2[i4] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i4 = 0; i4 < key2.length; i4++)
        key2[i4] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    var hash = exports;
    hash.utils = require_utils5();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils4();
    var assert3 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e5) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var hash = require_hash();
    var utils = require_utils3();
    var assert3 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init3(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i4 = 0; i4 < this.V.length; i4++) {
        this.K[i4] = 0;
        this.V[i4] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert3(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var utils = require_utils4();
    var assert3 = utils.assert;
    function KeyPair(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new BN6(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert3(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert3(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var utils = require_utils4();
    var assert3 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert3(options.r && options.s, "Signature without r or s");
      this.r = new BN6(options.r, 16);
      this.s = new BN6(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i4 = 0, off3 = p5.place; i4 < octetLen; i4++, off3++) {
        val <<= 8;
        val |= buf[off3];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off3;
      return val;
    }
    function rmPadding(buf) {
      var i4 = 0;
      var len = buf.length - 1;
      while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
        i4++;
      }
      if (i4 === 0) {
        return buf;
      }
      return buf.slice(i4);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p5 = new Position();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p5);
      if (rlen === false) {
        return false;
      }
      var r5 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      var s4 = data.slice(p5.place, slen + p5.place);
      if (r5[0] === 0) {
        if (r5[1] & 128) {
          r5 = r5.slice(1);
        } else {
          return false;
        }
      }
      if (s4[0] === 0) {
        if (s4[1] & 128) {
          s4 = s4.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN6(r5);
      this.s = new BN6(s4);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r5 = this.r.toArray();
      var s4 = this.s.toArray();
      if (r5[0] & 128)
        r5 = [0].concat(r5);
      if (s4[0] & 128)
        s4 = [0].concat(s4);
      r5 = rmPadding(r5);
      s4 = rmPadding(s4);
      while (!s4[0] && !(s4[1] & 128)) {
        s4 = s4.slice(1);
      }
      var arr = [2];
      constructLength(arr, r5.length);
      arr = arr.concat(r5);
      arr.push(2);
      constructLength(arr, s4.length);
      var backHalf = arr.concat(s4);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves();
    var rand = require_brorand();
    var assert3 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert3(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN6(2));
      for (; ; ) {
        var priv = new BN6(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new BN6(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN6(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN6(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r5 = kpX.umod(this.n);
        if (r5.cmpn(0) === 0)
          continue;
        var s4 = k5.invm(this.n).mul(r5.mul(key2.getPrivate()).iadd(msg));
        s4 = s4.umod(this.n);
        if (s4.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r5) !== 0 ? 2 : 0);
        if (options.canonical && s4.cmp(this.nh) > 0) {
          s4 = this.n.sub(s4);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r5, s: s4, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key2, enc) {
      msg = this._truncateToN(new BN6(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature = new Signature(signature, "hex");
      var r5 = signature.r;
      var s4 = signature.s;
      if (r5.cmpn(1) < 0 || r5.cmp(this.n) >= 0)
        return false;
      if (s4.cmpn(1) < 0 || s4.cmp(this.n) >= 0)
        return false;
      var sinv = s4.invm(this.n);
      var u12 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r5).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u12, key2.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r5) === 0;
      }
      p5 = this.g.jmulAdd(u12, key2.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r5);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j4, enc) {
      assert3((3 & j4) === j4, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e5 = new BN6(msg);
      var r5 = signature.r;
      var s4 = signature.s;
      var isYOdd = j4 & 1;
      var isSecondKey = j4 >> 1;
      if (r5.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r5 = this.curve.pointFromX(r5.add(this.curve.n), isYOdd);
      else
        r5 = this.curve.pointFromX(r5, isYOdd);
      var rInv = signature.r.invm(n4);
      var s12 = n4.sub(e5).mul(rInv).umod(n4);
      var s22 = s4.mul(rInv).umod(n4);
      return this.g.mulAdd(s12, r5, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e5, signature, Q3, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i4 = 0; i4 < 4; i4++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e5, signature, i4);
        } catch (e6) {
          continue;
        }
        if (Qprime.eq(Q3))
          return i4;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_utils4();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a4 = hash.slice(0, eddsa.encodingLength);
      a4[0] &= 248;
      a4[lastIx] &= 127;
      a4[lastIx] |= 64;
      return a4;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert3(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert3(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var utils = require_utils4();
    var assert3 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert3(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN6)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S3() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R3() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex3() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils4();
    var assert3 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert3(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key2 = this.keyFromSecret(secret);
      var r5 = this.hashInt(key2.messagePrefix(), message);
      var R3 = this.g.mul(r5);
      var Rencoded = this.encodePoint(R3);
      var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
      var S3 = r5.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R3, S: S3, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key2 = this.keyFromPublic(pub);
      var h5 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key2.pub().mul(h5));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i4 = 0; i4 < arguments.length; i4++)
        hash2.update(arguments[i4]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y5 = utils.intFromLE(normed);
      return this.curve.pointFromY(y5, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var ecparams = ec2.curve;
    var BN6 = ecparams.n.constructor;
    function loadCompressedPublicKey(first, xbuf) {
      let x5 = new BN6(xbuf);
      if (x5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      let y5 = x5.redSqr().redIMul(x5).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y5.isOdd())
        y5 = y5.redNeg();
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadUncompressedPublicKey(first, xbuf, ybuf) {
      let x5 = new BN6(xbuf);
      let y5 = new BN6(ybuf);
      if (x5.cmp(ecparams.p) >= 0 || y5.cmp(ecparams.p) >= 0)
        return null;
      x5 = x5.toRed(ecparams.red);
      y5 = y5.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y5.isOdd() !== (first === 7))
        return null;
      const x32 = x5.redSqr().redIMul(x5);
      if (!y5.redSqr().redISub(x32.redIAdd(ecparams.b)).isZero())
        return null;
      return ec2.keyPair({ pub: { x: x5, y: y5 } });
    }
    function loadPublicKey(pubkey) {
      const first = pubkey[0];
      switch (first) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i4 = 0; i4 < output.length; ++i4)
        output[i4] = pubkey[i4];
    }
    module.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn2 = new BN6(seckey);
        return bn2.cmp(ecparams.n) < 0 && !bn2.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn2 = new BN6(seckey);
        const negate = ecparams.n.sub(bn2).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn2 = new BN6(tweak);
        if (bn2.cmp(ecparams.n) >= 0)
          return 1;
        bn2.iadd(new BN6(seckey));
        if (bn2.cmp(ecparams.n) >= 0)
          bn2.isub(ecparams.n);
        if (bn2.isZero())
          return 1;
        const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn2 = new BN6(tweak);
        if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
          return 1;
        bn2.imul(new BN6(seckey));
        if (bn2.cmp(ecparams.n) >= 0)
          bn2 = bn2.umod(ecparams.n);
        const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn2 = new BN6(seckey);
        if (bn2.cmp(ecparams.n) >= 0 || bn2.isZero())
          return 1;
        const point = ec2.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i4 = 0; i4 < pubkeys.length; ++i4) {
          pairs[i4] = loadPublicKey(pubkeys[i4]);
          if (pairs[i4] === null)
            return 1;
        }
        let point = pairs[0].getPublic();
        for (let i4 = 1; i4 < pairs.length; ++i4)
          point = point.add(pairs[i4].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN6(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN6(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r5 = new BN6(sig.subarray(0, 32));
        const s4 = new BN6(sig.subarray(32, 64));
        if (r5.cmp(ecparams.n) >= 0 || s4.cmp(ecparams.n) >= 0)
          return 1;
        if (s4.cmp(ec2.nh) === 1) {
          sig.set(ecparams.n.sub(s4).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN6(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN6(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r5 = output.subarray(4, 4 + 33);
        r5[0] = 0;
        r5.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r5[posR] === 0 && !(r5[posR + 1] & 128); --lenR, ++posR)
          ;
        r5 = r5.subarray(posR);
        if (r5[0] & 128)
          return 1;
        if (lenR > 1 && r5[0] === 0 && !(r5[1] & 128))
          return 1;
        let s4 = output.subarray(6 + 33, 6 + 33 + 33);
        s4[0] = 0;
        s4.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s4[posS] === 0 && !(s4[posS + 1] & 128); --lenS, ++posS)
          ;
        s4 = s4.subarray(posS);
        if (s4[0] & 128)
          return 1;
        if (lenS > 1 && s4[0] === 0 && !(s4[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r5.length;
        output.set(r5, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s4.length;
        output.set(s4, 6 + lenR);
        return 0;
      },
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r5 = new BN6(sigR);
        if (r5.cmp(ecparams.n) >= 0)
          r5 = new BN6(0);
        let s4 = new BN6(sig.subarray(6 + lenR));
        if (s4.cmp(ecparams.n) >= 0)
          s4 = new BN6(0);
        output.set(r5.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s4.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN6(nonce);
          };
        }
        const d4 = new BN6(seckey);
        if (d4.cmp(ecparams.n) >= 0 || d4.isZero())
          return 1;
        let sig;
        try {
          sig = ec2.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN6(sigObj.r);
        const sigs = new BN6(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec2.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec2.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN6(sigObj.r);
        const sigs = new BN6(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec2.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN6(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha2562 = ec2.hash().update(data2).digest();
          for (let i4 = 0; i4 < 32; ++i4)
            output[i4] = sha2562[i4];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x5 = point.getX().toArray("be", 32);
          for (let i4 = 0; i4 < 32; ++i4)
            xbuf[i4] = x5[i4];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y5 = point.getY().toArray("be", 32);
          for (let i4 = 0; i4 < 32; ++i4)
            ybuf[i4] = y5[i4];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_lib()(require_elliptic2());
  }
});

// node_modules/randombytes/browser.js
var require_browser4 = __commonJS({
  "node_modules/randombytes/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer4 = require_safe_buffer().Buffer;
    var crypto = window.crypto || window.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes2;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes2(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer4.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var randombytes = require_browser4();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve(resp);
        });
      });
    }
    exports.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _5 = { label: 0, sent: function() {
        if (t5[0] & 1)
          throw t5[1];
        return t5[1];
      }, trys: [], ops: [] }, f5, y5, t5, g4;
      return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
        return this;
      }), g4;
      function verb(n4) {
        return function(v5) {
          return step([n4, v5]);
        };
      }
      function step(op) {
        if (f5)
          throw new TypeError("Generator is already executing.");
        while (_5)
          try {
            if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
              return t5;
            if (y5 = 0, t5)
              op = [op[0] & 2, t5.value];
            switch (op[0]) {
              case 0:
              case 1:
                t5 = op;
                break;
              case 4:
                _5.label++;
                return { value: op[1], done: false };
              case 5:
                _5.label++;
                y5 = op[1];
                op = [0];
                continue;
              case 7:
                op = _5.ops.pop();
                _5.trys.pop();
                continue;
              default:
                if (!(t5 = _5.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _5 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                  _5.label = op[1];
                  break;
                }
                if (op[0] === 6 && _5.label < t5[1]) {
                  _5.label = t5[1];
                  t5 = op;
                  break;
                }
                if (t5 && _5.label < t5[2]) {
                  _5.label = t5[2];
                  _5.ops.push(op);
                  break;
                }
                if (t5[2])
                  _5.ops.pop();
                _5.trys.pop();
                continue;
            }
            op = body.call(thisArg, _5);
          } catch (e5) {
            op = [6, e5];
            y5 = 0;
          } finally {
            f5 = t5 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export2(m5) {
      for (var p5 in m5)
        if (!exports.hasOwnProperty(p5))
          exports[p5] = m5[p5];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter(this, void 0, void 0, function() {
        var pk;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (false)
                return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a2.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [2];
          }
        });
      });
    }
    exports.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports.createPrivateKeySync = createPrivateKeySync;
    __export2(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var BN6 = require_bn6();
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var ecparams = ec2.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d4 = new BN6(privateKey);
      if (d4.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec2.g.mul(d4);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn2 = new BN6(privateKey);
      if (bn2.ucmp(ecparams.n) >= 0 || bn2.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn2.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r5 = new BN6(sigObj.r);
      if (r5.ucmp(ecparams.n) >= 0) {
        r5 = new BN6(0);
      }
      var s4 = new BN6(sigObj.s);
      if (s4.ucmp(ecparams.n) >= 0) {
        s4 = new BN6(0);
      }
      return Buffer2.concat([r5.toArrayLike(Buffer2, "be", 32), s4.toArrayLike(Buffer2, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var point = ec2.keyFromPublic(publicKey);
      var scalar = new BN6(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x5, y5, compressed) {
      var publicKey = void 0;
      if (compressed) {
        publicKey = Buffer2.alloc(33);
        publicKey[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer2.alloc(65);
        publicKey[0] = 4;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
        y5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r5 = Buffer2.alloc(32, 0);
      var s4 = Buffer2.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r5, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s4, 32 - svalue.length);
      return { r: r5, s: s4 };
    };
  }
});

// node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter = __commonJS({
  "node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var secp256k1 = require_secp256k12();
    var secp256k1v3 = require_secp256k1_lib();
    var der = require_der();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer2.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys2 = [];
      publicKeys.forEach(function(publicKey) {
        keys2.push(Uint8Array.from(publicKey));
      });
      return Buffer2.from(secp256k1.publicKeyCombine(keys2, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature) {
      return Buffer2.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    var signatureExport = function signatureExport2(signature) {
      return Buffer2.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    var signatureImport = function signatureImport2(signature) {
      return Buffer2.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    var signatureImportLax = function signatureImportLax2(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign = function sign2(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer2.from(algo) : null;
            var bufferData = data != null ? Buffer2.from(data) : null;
            var buffer = Buffer2.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer2.from(message2), Buffer2.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer2.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify = function verify2(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    var recover = function recover2(message, signature, recid, compressed) {
      return Buffer2.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey, privateKey) {
      return Buffer2.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign,
      verify,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node-modules-polyfills:assert
var assert_exports = {};
__export(assert_exports, {
  AssertionError: () => AssertionError,
  assert: () => ok,
  deepEqual: () => deepEqual,
  deepStrictEqual: () => deepStrictEqual,
  default: () => assert_default,
  doesNotThrow: () => doesNotThrow,
  equal: () => equal,
  fail: () => fail,
  ifError: () => ifError,
  notDeepEqual: () => notDeepEqual,
  notDeepStrictEqual: () => notDeepStrictEqual,
  notEqual: () => notEqual,
  notStrictEqual: () => notStrictEqual,
  ok: () => ok,
  strictEqual: () => strictEqual,
  throws: () => throws
});
function compare5(a4, b3) {
  if (a4 === b3) {
    return 0;
  }
  var x5 = a4.length;
  var y5 = b3.length;
  for (var i4 = 0, len = Math.min(x5, y5); i4 < len; ++i4) {
    if (a4[i4] !== b3[i4]) {
      x5 = a4[i4];
      y5 = b3[i4];
      break;
    }
  }
  if (x5 < y5) {
    return -1;
  }
  if (y5 < x5) {
    return 1;
  }
  return 0;
}
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return function foo() {
    }.name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer2(arrbuf)) {
    return false;
  }
  if (typeof window.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert2(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function getName(func) {
  if (!isFunction2(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
function truncate(s4, n4) {
  if (typeof s4 === "string") {
    return s4.length < n4 ? s4 : s4.slice(0, n4);
  } else {
    return s4;
  }
}
function inspect3(something) {
  if (functionsHaveNames() || !isFunction2(something)) {
    return inspect2(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate(inspect3(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect3(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
function ok(value, message) {
  if (!value)
    fail(value, true, message, "==", ok);
}
function equal(actual, expected, message) {
  if (actual != expected)
    fail(actual, expected, message, "==", equal);
}
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer2(actual) && isBuffer2(expected)) {
    return compare5(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare5(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer2(actual) !== isBuffer2(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a4, b3, strict, actualVisitedObjects) {
  if (a4 === null || a4 === void 0 || b3 === null || b3 === void 0)
    return false;
  if (isPrimitive(a4) || isPrimitive(b3))
    return a4 === b3;
  if (strict && Object.getPrototypeOf(a4) !== Object.getPrototypeOf(b3))
    return false;
  var aIsArgs = isArguments(a4);
  var bIsArgs = isArguments(b3);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a4 = pSlice.call(a4);
    b3 = pSlice.call(b3);
    return _deepEqual(a4, b3, strict);
  }
  var ka = objectKeys2(a4);
  var kb = objectKeys2(b3);
  var key2, i4;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    if (ka[i4] !== kb[i4])
      return false;
  }
  for (i4 = ka.length - 1; i4 >= 0; i4--) {
    key2 = ka[i4];
    if (!_deepEqual(a4[key2], b3[key2], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e5) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error2;
  try {
    block();
  } catch (e5) {
    error2 = e5;
  }
  return error2;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
function throws(block, error2, message) {
  _throws(true, block, error2, message);
}
function doesNotThrow(block, error2, message) {
  _throws(false, block, error2, message);
}
function ifError(err) {
  if (err)
    throw err;
}
var hasOwn, objectKeys2, pSlice, _functionsHaveNames, assert_default, regex;
var init_assert = __esm({
  "node-modules-polyfills:assert"() {
    init_virtual_process_polyfill();
    init_buffer();
    init_buffer2();
    init_util();
    hasOwn = Object.prototype.hasOwnProperty;
    objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key2 in obj) {
        if (hasOwn.call(obj, key2))
          keys2.push(key2);
      }
      return keys2;
    };
    pSlice = Array.prototype.slice;
    assert_default = assert2;
    regex = /\s*function\s+([^\(\s]*)\s*/;
    assert2.AssertionError = AssertionError;
    inherits_default(AssertionError, Error);
    assert2.fail = fail;
    assert2.ok = ok;
    assert2.equal = equal;
    assert2.notEqual = notEqual;
    assert2.deepEqual = deepEqual;
    assert2.deepStrictEqual = deepStrictEqual;
    assert2.notDeepEqual = notDeepEqual;
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    assert2.strictEqual = strictEqual;
    assert2.notStrictEqual = notStrictEqual;
    assert2.throws = throws;
    assert2.doesNotThrow = doesNotThrow;
    assert2.ifError = ifError;
  }
});

// node-modules-polyfills-commonjs:assert
var require_assert = __commonJS({
  "node-modules-polyfills-commonjs:assert"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_assert(), __toCommonJS(assert_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/rlp/node_modules/bn.js/lib/bn.js
var require_bn7 = __commonJS({
  "node_modules/rlp/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN6(number, base2, endian) {
        if (BN6.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN6;
      } else {
        exports2.BN = BN6;
      }
      BN6.BN = BN6;
      BN6.wordSize = 26;
      var Buffer4;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer4 = window.Buffer;
        } else {
          Buffer4 = require_buffer().Buffer;
        }
      } catch (e5) {
      }
      BN6.isBN = function isBN(num) {
        if (num instanceof BN6) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN6.wordSize && Array.isArray(num.words);
      };
      BN6.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN6.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN6.prototype._init = function init3(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN6.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN6.prototype._initArray = function _initArray(number, base2, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j4, w6;
        var off3 = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j4 = 0; i4 >= 0; i4 -= 3) {
            w6 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j4 = 0; i4 < number.length; i4 += 3) {
            w6 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j4] |= w6 << off3 & 67108863;
            this.words[j4 + 1] = w6 >>> 26 - off3 & 67108863;
            off3 += 24;
            if (off3 >= 26) {
              off3 -= 26;
              j4++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c4 = string.charCodeAt(index);
        if (c4 >= 48 && c4 <= 57) {
          return c4 - 48;
        } else if (c4 >= 65 && c4 <= 70) {
          return c4 - 55;
        } else if (c4 >= 97 && c4 <= 102) {
          return c4 - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r5 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r5 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r5;
      }
      BN6.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off3 = 0;
        var j4 = 0;
        var w6;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w6 = parseHexByte(number, start, i4) << off3;
            this.words[j4] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j4 += 1;
              this.words[j4] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w6 = parseHexByte(number, start, i4) << off3;
            this.words[j4] |= w6 & 67108863;
            if (off3 >= 18) {
              off3 -= 18;
              j4 += 1;
              this.words[j4] |= w6 >>> 26;
            } else {
              off3 += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r5 = 0;
        var b3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c4 = str.charCodeAt(i4) - 48;
          r5 *= mul;
          if (c4 >= 49) {
            b3 = c4 - 49 + 10;
          } else if (c4 >= 17) {
            b3 = c4 - 17 + 10;
          } else {
            b3 = c4;
          }
          assert3(c4 >= 0 && b3 < mul, "Invalid character");
          r5 += b3;
        }
        return r5;
      }
      BN6.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base2);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN6.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN6.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN6.prototype.clone = function clone() {
        var r5 = new BN6(null);
        this.copy(r5);
        return r5;
      };
      BN6.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN6.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN6.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN6.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e5) {
          BN6.prototype.inspect = inspect4;
        }
      } else {
        BN6.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN6.prototype.toString = function toString4(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off3 = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w6 = this.words[i4];
            var word = ((w6 << off3 | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off3 & 16777215;
            off3 += 2;
            if (off3 >= 26) {
              off3 -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c4 = this.clone();
          c4.negative = 0;
          while (!c4.isZero()) {
            var r5 = c4.modrn(groupBase).toString(base2);
            c4 = c4.idivn(groupBase);
            if (!c4.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN6.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN6.prototype.toJSON = function toJSON3() {
        return this.toString(16, 2);
      };
      if (Buffer4) {
        BN6.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer4, endian, length);
        };
      }
      BN6.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN6.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength3 = this.byteLength();
        var reqLength = length || Math.max(1, byteLength3);
        assert3(byteLength3 <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength3);
        return res;
      };
      BN6.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
        var position = 0;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN6.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
        var position = res.length - 1;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN6.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN6.prototype._countBits = function _countBits(w6) {
          var t5 = w6;
          var r5 = 0;
          if (t5 >= 4096) {
            r5 += 13;
            t5 >>>= 13;
          }
          if (t5 >= 64) {
            r5 += 7;
            t5 >>>= 7;
          }
          if (t5 >= 8) {
            r5 += 4;
            t5 >>>= 4;
          }
          if (t5 >= 2) {
            r5 += 2;
            t5 >>>= 2;
          }
          return r5 + t5;
        };
      }
      BN6.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t5 = w6;
        var r5 = 0;
        if ((t5 & 8191) === 0) {
          r5 += 13;
          t5 >>>= 13;
        }
        if ((t5 & 127) === 0) {
          r5 += 7;
          t5 >>>= 7;
        }
        if ((t5 & 15) === 0) {
          r5 += 4;
          t5 >>>= 4;
        }
        if ((t5 & 3) === 0) {
          r5 += 2;
          t5 >>>= 2;
        }
        if ((t5 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN6.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off3 = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = num.words[off3] >>> wbit & 1;
        }
        return w6;
      }
      BN6.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b3 = this._zeroBits(this.words[i4]);
          r5 += b3;
          if (b3 !== 26)
            break;
        }
        return r5;
      };
      BN6.prototype.byteLength = function byteLength3() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN6.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN6.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN6.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN6.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN6.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN6.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this._strip();
      };
      BN6.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN6.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN6.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN6.prototype.iuand = function iuand(num) {
        var b3;
        if (this.length > num.length) {
          b3 = num;
        } else {
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b3.length;
        return this._strip();
      };
      BN6.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN6.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN6.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN6.prototype.iuxor = function iuxor(num) {
        var a4;
        var b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        for (var i4 = 0; i4 < b3.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b3.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this._strip();
      };
      BN6.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN6.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN6.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN6.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN6.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN6.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off3 = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off3 + 1);
        if (val) {
          this.words[off3] = this.words[off3] | 1 << wbit;
        } else {
          this.words[off3] = this.words[off3] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN6.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b3;
        if (this.length > num.length) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b3.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN6.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN6.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b3;
        if (cmp > 0) {
          a4 = this;
          b3 = num;
        } else {
          a4 = num;
          b3 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b3.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b3.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN6.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b3 = num.words[0] | 0;
        var r5 = a4 * b3;
        var lo2 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4 | 0;
            a4 = self2.words[i4] | 0;
            b3 = num.words[j4] | 0;
            r5 = a4 * b3 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b3 = num.words;
        var o4 = out.words;
        var c4 = 0;
        var lo2;
        var mid;
        var hi;
        var a02 = a4[0] | 0;
        var al0 = a02 & 8191;
        var ah0 = a02 >>> 13;
        var a12 = a4[1] | 0;
        var al1 = a12 & 8191;
        var ah1 = a12 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b3[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b12 = b3[1] | 0;
        var bl1 = b12 & 8191;
        var bh1 = b12 >>> 13;
        var b22 = b3[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b3[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b4 = b3[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b3[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b3[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b3[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b3[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b3[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w12 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w122 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
        w122 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c4 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c4 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w02;
        o4[1] = w12;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w42;
        o4[5] = w52;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w122;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c4 !== 0) {
          o4[19] = c4;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j4 = Math.max(0, k5 - self2.length + 1); j4 <= maxJ; j4++) {
            var i4 = k5 - j4;
            var a4 = self2.words[i4] | 0;
            var b3 = num.words[j4] | 0;
            var r5 = a4 * b3;
            var lo2 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN6.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y5) {
        this.x = x5;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t5 = new Array(N4);
        var l5 = BN6.prototype._countBits(N4) - 1;
        for (var i4 = 0; i4 < N4; i4++) {
          t5[i4] = this.revBin(i4, l5, N4);
        }
        return t5;
      };
      FFTM.prototype.revBin = function revBin(x5, l5, N4) {
        if (x5 === 0 || x5 === N4 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l5; i4++) {
          rb |= (x5 & 1) << l5 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i4 = 0; i4 < N4; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s4 = 1; s4 < N4; s4 <<= 1) {
          var l5 = s4 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l5);
          var itwdf = Math.sin(2 * Math.PI / l5);
          for (var p5 = 0; p5 < N4; p5 += l5) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j4 = 0; j4 < s4; j4++) {
              var re3 = rtws[p5 + j4];
              var ie2 = itws[p5 + j4];
              var ro2 = rtws[p5 + j4 + s4];
              var io2 = itws[p5 + j4 + s4];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p5 + j4] = re3 + ro2;
              itws[p5 + j4] = ie2 + io2;
              rtws[p5 + j4 + s4] = re3 - ro2;
              itws[p5 + j4 + s4] = ie2 - io2;
              if (j4 !== l5) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
        var N4 = Math.max(m5, n4) | 1;
        var odd = N4 & 1;
        var i4 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var t5 = rws[i4];
          rws[i4] = rws[N4 - i4 - 1];
          rws[N4 - i4 - 1] = t5;
          t5 = iws[i4];
          iws[i4] = -iws[N4 - i4 - 1];
          iws[N4 - i4 - 1] = -t5;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < N4 / 2; i4++) {
          var w6 = Math.round(ws2[2 * i4 + 1] / N4) * 8192 + Math.round(ws2[2 * i4] / N4) + carry;
          ws2[i4] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N4) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N4; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i4 = 0; i4 < N4; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y5, out) {
        var N4 = 2 * this.guessLen13b(x5.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _5 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x5.words, x5.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _5, rwst, iwst, N4, rbt);
        this.transform(nrws, _5, nrwst, niwst, N4, rbt);
        for (var i4 = 0; i4 < N4; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _5, N4, rbt);
        this.conjugate(rmws, _5, N4);
        this.normalize13b(rmws, N4);
        out.negative = x5.negative ^ y5.negative;
        out.length = x5.length + y5.length;
        return out._strip();
      };
      BN6.prototype.mul = function mul(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN6.prototype.mulf = function mulf(num) {
        var out = new BN6(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN6.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN6.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w6 = (this.words[i4] | 0) * num;
          var lo2 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN6.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN6.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN6.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN6(1);
        var res = this;
        for (var i4 = 0; i4 < w6.length; i4++, res = res.sqr()) {
          if (w6[i4] !== 0)
            break;
        }
        if (++i4 < w6.length) {
          for (var q5 = res.sqr(); i4 < w6.length; i4++, q5 = q5.sqr()) {
            if (w6[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN6.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c4 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c4 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s4 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s4] = this.words[i4];
          }
          for (i4 = 0; i4 < s4; i4++) {
            this.words[i4] = 0;
          }
          this.length += s4;
        }
        return this._strip();
      };
      BN6.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN6.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r5 = bits % 26;
        var s4 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h5 -= s4;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i4 = 0; i4 < s4; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s4;
        }
        if (s4 === 0) {
        } else if (this.length > s4) {
          this.length -= s4;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s4];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h5); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN6.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN6.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN6.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN6.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN6.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN6.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4)
          return false;
        var w6 = this.words[s4];
        return !!(w6 & q5);
      };
      BN6.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s4 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s4) {
          return this;
        }
        if (r5 !== 0) {
          s4++;
        }
        this.length = Math.min(s4, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN6.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN6.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN6.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN6.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN6.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN6.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN6.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN6.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN6.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w6 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w6 = (this.words[i4 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w6 = -(this.words[i4] | 0) + carry;
          carry = w6 >> 26;
          this.words[i4] = w6 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN6.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b3 = num;
        var bhi = b3.words[b3.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b3 = b3.ushln(shift);
          a4.iushln(shift);
          bhi = b3.words[b3.length - 1] | 0;
        }
        var m5 = a4.length - b3.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN6(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b3, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j4 = m5 - 1; j4 >= 0; j4--) {
          var qj = (a4.words[b3.length + j4] | 0) * 67108864 + (a4.words[b3.length + j4 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b3, qj, j4);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b3, 1, j4);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j4] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a4._strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN6.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN6(0),
            mod: new BN6(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN6(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN6(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN6(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN6.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN6.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN6.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN6.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN6.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p5 * acc + (this.words[i4] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN6.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN6.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w6 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w6 / num | 0;
          carry = w6 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN6.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN6.prototype.egcd = function egcd(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var x5 = this;
        var y5 = p5.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p5);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN6(1);
        var B3 = new BN6(0);
        var C4 = new BN6(0);
        var D4 = new BN6(1);
        var g4 = 0;
        while (x5.isEven() && y5.isEven()) {
          x5.iushrn(1);
          y5.iushrn(1);
          ++g4;
        }
        var yp = y5.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B3.isOdd()) {
                A5.iadd(yp);
                B3.isub(xp);
              }
              A5.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (y5.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            y5.iushrn(j4);
            while (j4-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x5.cmp(y5) >= 0) {
            x5.isub(y5);
            A5.isub(C4);
            B3.isub(D4);
          } else {
            y5.isub(x5);
            C4.isub(A5);
            D4.isub(B3);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y5.iushln(g4)
        };
      };
      BN6.prototype._invmp = function _invmp(p5) {
        assert3(p5.negative === 0);
        assert3(!p5.isZero());
        var a4 = this;
        var b3 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x12 = new BN6(1);
        var x22 = new BN6(0);
        var delta = b3.clone();
        while (a4.cmpn(1) > 0 && b3.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x12.isOdd()) {
                x12.iadd(delta);
              }
              x12.iushrn(1);
            }
          }
          for (var j4 = 0, jm = 1; (b3.words[0] & jm) === 0 && j4 < 26; ++j4, jm <<= 1)
            ;
          if (j4 > 0) {
            b3.iushrn(j4);
            while (j4-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b3) >= 0) {
            a4.isub(b3);
            x12.isub(x22);
          } else {
            b3.isub(a4);
            x22.isub(x12);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x12;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN6.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b3 = num.clone();
        a4.negative = 0;
        b3.negative = 0;
        for (var shift = 0; a4.isEven() && b3.isEven(); shift++) {
          a4.iushrn(1);
          b3.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b3.isEven()) {
            b3.iushrn(1);
          }
          var r5 = a4.cmp(b3);
          if (r5 < 0) {
            var t5 = a4;
            a4 = b3;
            b3 = t5;
          } else if (r5 === 0 || b3.cmpn(1) === 0) {
            break;
          }
          a4.isub(b3);
        } while (true);
        return b3.iushln(shift);
      };
      BN6.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN6.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN6.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN6.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN6.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s4 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s4) {
          this._expand(s4 + 1);
          this.words[s4] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
          var w6 = this.words[i4] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i4] = w6;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN6.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN6.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN6.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b3 = num.words[i4] | 0;
          if (a4 === b3)
            continue;
          if (a4 < b3) {
            res = -1;
          } else if (a4 > b3) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN6.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN6.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN6.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN6.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN6.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN6.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN6.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN6.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN6.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN6.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN6.red = function red(num) {
        return new Red(num);
      };
      BN6.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN6.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN6.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN6.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN6.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN6.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN6.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN6.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN6.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN6.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN6.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN6.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN6.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN6.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN6.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN6.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN6.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p5) {
        this.name = name;
        this.p = new BN6(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN6(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN6(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          if (r5.strip !== void 0) {
            r5.strip();
          } else {
            r5._strip();
          }
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w6 = num.words[i4] | 0;
          lo2 += w6 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w6 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo2;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN6._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN6._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b3) {
        assert3((a4.negative | b3.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b3.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        move(a4, a4.umod(this.m)._forceRed(this));
        return a4;
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.add(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.iadd(b3);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.sub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b3) {
        this._verify2(a4, b3);
        var res = a4.isub(b3);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.imul(b3));
      };
      Red.prototype.mul = function mul(a4, b3) {
        this._verify2(a4, b3);
        return this.imod(a4.mul(b3));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN6(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s4 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s4++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN6(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z4 = this.m.bitLength();
        z4 = new BN6(2 * z4 * z4).toRed(this);
        while (this.pow(z4, lpow).cmp(nOne) !== 0) {
          z4.redIAdd(nOne);
        }
        var c4 = this.pow(z4, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t5 = this.pow(a4, q5);
        var m5 = s4;
        while (t5.cmp(one) !== 0) {
          var tmp = t5;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b3 = this.pow(c4, new BN6(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b3);
          c4 = b3.redSqr();
          t5 = t5.redMul(c4);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN6(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN6(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j4 = start - 1; j4 >= 0; j4--) {
            var bit = word >> j4 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j4 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN6.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN6(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b3) {
        if (a4.isZero() || b3.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t5 = a4.imul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b3) {
        if (a4.isZero() || b3.isZero())
          return new BN6(0)._forceRed(this);
        var t5 = a4.mul(b3);
        var c4 = t5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t5.isub(c4).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/rlp/dist.browser/index.js
var require_dist2 = __commonJS({
  "node_modules/rlp/dist.browser/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLength = exports.decode = exports.encode = void 0;
    var bn_js_1 = __importDefault(require_bn7());
    function encode2(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var i4 = 0; i4 < input.length; i4++) {
          output.push(encode2(input[i4]));
        }
        var buf = Buffer2.concat(output);
        return Buffer2.concat([encodeLength(buf.length, 192), buf]);
      } else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer2.concat([encodeLength(inputBuf.length, 128), inputBuf]);
      }
    }
    exports.encode = encode2;
    function safeParseInt(v5, base2) {
      if (v5[0] === "0" && v5[1] === "0") {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseInt(v5, base2);
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Buffer2.from([len + offset]);
      } else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer2.from(firstByte + hexLength, "hex");
      }
    }
    function decode(input, stream) {
      if (stream === void 0) {
        stream = false;
      }
      if (!input || input.length === 0) {
        return Buffer2.from([]);
      }
      var inputBuffer = toBuffer(input);
      var decoded = _decode(inputBuffer);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid remainder");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function getLength(input) {
      if (!input || input.length === 0) {
        return Buffer2.from([]);
      }
      var inputBuffer = toBuffer(input);
      var firstByte = inputBuffer[0];
      if (firstByte <= 127) {
        return inputBuffer.length;
      } else if (firstByte <= 183) {
        return firstByte - 127;
      } else if (firstByte <= 191) {
        return firstByte - 182;
      } else if (firstByte <= 247) {
        return firstByte - 191;
      } else {
        var llength = firstByte - 246;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
        return llength + length_1;
      }
    }
    exports.getLength = getLength;
    function _decode(input) {
      var length, llength, data, innerRemainder, d4;
      var decoded = [];
      var firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Buffer2.from([]);
        } else {
          data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid rlp encoding: byte must be less 0x80");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
          throw new Error("invalid RLP: not enough bytes for string");
        }
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
          d4 = _decode(innerRemainder);
          decoded.push(d4.data);
          innerRemainder = d4.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid rlp: total length is larger than the data");
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
          throw new Error("invalid rlp, List has a invalid length");
        }
        while (innerRemainder.length) {
          d4 = _decode(innerRemainder);
          decoded.push(d4.data);
          innerRemainder = d4.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    function isHexPrefixed(str) {
      return str.slice(0, 2) === "0x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function intToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      var hex = integer.toString(16);
      return hex.length % 2 ? "0" + hex : hex;
    }
    function padToEven(a4) {
      return a4.length % 2 ? "0" + a4 : a4;
    }
    function intToBuffer(integer) {
      var hex = intToHex(integer);
      return Buffer2.from(hex, "hex");
    }
    function toBuffer(v5) {
      if (!Buffer2.isBuffer(v5)) {
        if (typeof v5 === "string") {
          if (isHexPrefixed(v5)) {
            return Buffer2.from(padToEven(stripHexPrefix(v5)), "hex");
          } else {
            return Buffer2.from(v5);
          }
        } else if (typeof v5 === "number" || typeof v5 === "bigint") {
          if (!v5) {
            return Buffer2.from([]);
          } else {
            return intToBuffer(v5);
          }
        } else if (v5 === null || v5 === void 0) {
          return Buffer2.from([]);
        } else if (v5 instanceof Uint8Array) {
          return Buffer2.from(v5);
        } else if (bn_js_1.default.isBN(v5)) {
          return Buffer2.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    }
  }
});

// node_modules/hash-base/index.js
var require_hash_base = __commonJS({
  "node_modules/hash-base/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_readable_browser().Transform;
    var inherits2 = require_inherits_browser();
    function throwIfNotStringOrBuffer(val, prefix) {
      if (!Buffer4.isBuffer(val) && typeof val !== "string") {
        throw new TypeError(prefix + " must be a string or a buffer");
      }
    }
    function HashBase(blockSize) {
      Transform2.call(this);
      this._block = Buffer4.allocUnsafe(blockSize);
      this._blockSize = blockSize;
      this._blockOffset = 0;
      this._length = [0, 0, 0, 0];
      this._finalized = false;
    }
    inherits2(HashBase, Transform2);
    HashBase.prototype._transform = function(chunk, encoding, callback) {
      var error2 = null;
      try {
        this.update(chunk, encoding);
      } catch (err) {
        error2 = err;
      }
      callback(error2);
    };
    HashBase.prototype._flush = function(callback) {
      var error2 = null;
      try {
        this.push(this.digest());
      } catch (err) {
        error2 = err;
      }
      callback(error2);
    };
    HashBase.prototype.update = function(data, encoding) {
      throwIfNotStringOrBuffer(data, "Data");
      if (this._finalized)
        throw new Error("Digest already called");
      if (!Buffer4.isBuffer(data))
        data = Buffer4.from(data, encoding);
      var block = this._block;
      var offset = 0;
      while (this._blockOffset + data.length - offset >= this._blockSize) {
        for (var i4 = this._blockOffset; i4 < this._blockSize; )
          block[i4++] = data[offset++];
        this._update();
        this._blockOffset = 0;
      }
      while (offset < data.length)
        block[this._blockOffset++] = data[offset++];
      for (var j4 = 0, carry = data.length * 8; carry > 0; ++j4) {
        this._length[j4] += carry;
        carry = this._length[j4] / 4294967296 | 0;
        if (carry > 0)
          this._length[j4] -= 4294967296 * carry;
      }
      return this;
    };
    HashBase.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    HashBase.prototype.digest = function(encoding) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var digest = this._digest();
      if (encoding !== void 0)
        digest = digest.toString(encoding);
      this._block.fill(0);
      this._blockOffset = 0;
      for (var i4 = 0; i4 < 4; ++i4)
        this._length[i4] = 0;
      return digest;
    };
    HashBase.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    module.exports = HashBase;
  }
});

// node_modules/md5.js/index.js
var require_md5 = __commonJS({
  "node_modules/md5.js/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var Buffer4 = require_safe_buffer().Buffer;
    var ARRAY16 = new Array(16);
    function MD5() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
    }
    inherits2(MD5, HashBase);
    MD5.prototype._update = function() {
      var M4 = ARRAY16;
      for (var i4 = 0; i4 < 16; ++i4)
        M4[i4] = this._block.readInt32LE(i4 * 4);
      var a4 = this._a;
      var b3 = this._b;
      var c4 = this._c;
      var d4 = this._d;
      a4 = fnF(a4, b3, c4, d4, M4[0], 3614090360, 7);
      d4 = fnF(d4, a4, b3, c4, M4[1], 3905402710, 12);
      c4 = fnF(c4, d4, a4, b3, M4[2], 606105819, 17);
      b3 = fnF(b3, c4, d4, a4, M4[3], 3250441966, 22);
      a4 = fnF(a4, b3, c4, d4, M4[4], 4118548399, 7);
      d4 = fnF(d4, a4, b3, c4, M4[5], 1200080426, 12);
      c4 = fnF(c4, d4, a4, b3, M4[6], 2821735955, 17);
      b3 = fnF(b3, c4, d4, a4, M4[7], 4249261313, 22);
      a4 = fnF(a4, b3, c4, d4, M4[8], 1770035416, 7);
      d4 = fnF(d4, a4, b3, c4, M4[9], 2336552879, 12);
      c4 = fnF(c4, d4, a4, b3, M4[10], 4294925233, 17);
      b3 = fnF(b3, c4, d4, a4, M4[11], 2304563134, 22);
      a4 = fnF(a4, b3, c4, d4, M4[12], 1804603682, 7);
      d4 = fnF(d4, a4, b3, c4, M4[13], 4254626195, 12);
      c4 = fnF(c4, d4, a4, b3, M4[14], 2792965006, 17);
      b3 = fnF(b3, c4, d4, a4, M4[15], 1236535329, 22);
      a4 = fnG(a4, b3, c4, d4, M4[1], 4129170786, 5);
      d4 = fnG(d4, a4, b3, c4, M4[6], 3225465664, 9);
      c4 = fnG(c4, d4, a4, b3, M4[11], 643717713, 14);
      b3 = fnG(b3, c4, d4, a4, M4[0], 3921069994, 20);
      a4 = fnG(a4, b3, c4, d4, M4[5], 3593408605, 5);
      d4 = fnG(d4, a4, b3, c4, M4[10], 38016083, 9);
      c4 = fnG(c4, d4, a4, b3, M4[15], 3634488961, 14);
      b3 = fnG(b3, c4, d4, a4, M4[4], 3889429448, 20);
      a4 = fnG(a4, b3, c4, d4, M4[9], 568446438, 5);
      d4 = fnG(d4, a4, b3, c4, M4[14], 3275163606, 9);
      c4 = fnG(c4, d4, a4, b3, M4[3], 4107603335, 14);
      b3 = fnG(b3, c4, d4, a4, M4[8], 1163531501, 20);
      a4 = fnG(a4, b3, c4, d4, M4[13], 2850285829, 5);
      d4 = fnG(d4, a4, b3, c4, M4[2], 4243563512, 9);
      c4 = fnG(c4, d4, a4, b3, M4[7], 1735328473, 14);
      b3 = fnG(b3, c4, d4, a4, M4[12], 2368359562, 20);
      a4 = fnH(a4, b3, c4, d4, M4[5], 4294588738, 4);
      d4 = fnH(d4, a4, b3, c4, M4[8], 2272392833, 11);
      c4 = fnH(c4, d4, a4, b3, M4[11], 1839030562, 16);
      b3 = fnH(b3, c4, d4, a4, M4[14], 4259657740, 23);
      a4 = fnH(a4, b3, c4, d4, M4[1], 2763975236, 4);
      d4 = fnH(d4, a4, b3, c4, M4[4], 1272893353, 11);
      c4 = fnH(c4, d4, a4, b3, M4[7], 4139469664, 16);
      b3 = fnH(b3, c4, d4, a4, M4[10], 3200236656, 23);
      a4 = fnH(a4, b3, c4, d4, M4[13], 681279174, 4);
      d4 = fnH(d4, a4, b3, c4, M4[0], 3936430074, 11);
      c4 = fnH(c4, d4, a4, b3, M4[3], 3572445317, 16);
      b3 = fnH(b3, c4, d4, a4, M4[6], 76029189, 23);
      a4 = fnH(a4, b3, c4, d4, M4[9], 3654602809, 4);
      d4 = fnH(d4, a4, b3, c4, M4[12], 3873151461, 11);
      c4 = fnH(c4, d4, a4, b3, M4[15], 530742520, 16);
      b3 = fnH(b3, c4, d4, a4, M4[2], 3299628645, 23);
      a4 = fnI(a4, b3, c4, d4, M4[0], 4096336452, 6);
      d4 = fnI(d4, a4, b3, c4, M4[7], 1126891415, 10);
      c4 = fnI(c4, d4, a4, b3, M4[14], 2878612391, 15);
      b3 = fnI(b3, c4, d4, a4, M4[5], 4237533241, 21);
      a4 = fnI(a4, b3, c4, d4, M4[12], 1700485571, 6);
      d4 = fnI(d4, a4, b3, c4, M4[3], 2399980690, 10);
      c4 = fnI(c4, d4, a4, b3, M4[10], 4293915773, 15);
      b3 = fnI(b3, c4, d4, a4, M4[1], 2240044497, 21);
      a4 = fnI(a4, b3, c4, d4, M4[8], 1873313359, 6);
      d4 = fnI(d4, a4, b3, c4, M4[15], 4264355552, 10);
      c4 = fnI(c4, d4, a4, b3, M4[6], 2734768916, 15);
      b3 = fnI(b3, c4, d4, a4, M4[13], 1309151649, 21);
      a4 = fnI(a4, b3, c4, d4, M4[4], 4149444226, 6);
      d4 = fnI(d4, a4, b3, c4, M4[11], 3174756917, 10);
      c4 = fnI(c4, d4, a4, b3, M4[2], 718787259, 15);
      b3 = fnI(b3, c4, d4, a4, M4[9], 3951481745, 21);
      this._a = this._a + a4 | 0;
      this._b = this._b + b3 | 0;
      this._c = this._c + c4 | 0;
      this._d = this._d + d4 | 0;
    };
    MD5.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer4.allocUnsafe(16);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      return buffer;
    };
    function rotl(x5, n4) {
      return x5 << n4 | x5 >>> 32 - n4;
    }
    function fnF(a4, b3, c4, d4, m5, k5, s4) {
      return rotl(a4 + (b3 & c4 | ~b3 & d4) + m5 + k5 | 0, s4) + b3 | 0;
    }
    function fnG(a4, b3, c4, d4, m5, k5, s4) {
      return rotl(a4 + (b3 & d4 | c4 & ~d4) + m5 + k5 | 0, s4) + b3 | 0;
    }
    function fnH(a4, b3, c4, d4, m5, k5, s4) {
      return rotl(a4 + (b3 ^ c4 ^ d4) + m5 + k5 | 0, s4) + b3 | 0;
    }
    function fnI(a4, b3, c4, d4, m5, k5, s4) {
      return rotl(a4 + (c4 ^ (b3 | ~d4)) + m5 + k5 | 0, s4) + b3 | 0;
    }
    module.exports = MD5;
  }
});

// node_modules/ripemd160/index.js
var require_ripemd160 = __commonJS({
  "node_modules/ripemd160/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_buffer().Buffer;
    var inherits2 = require_inherits_browser();
    var HashBase = require_hash_base();
    var ARRAY16 = new Array(16);
    var zl = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var zr2 = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var sl = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sr2 = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
    var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
    var hr2 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function RIPEMD160() {
      HashBase.call(this, 64);
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
    }
    inherits2(RIPEMD160, HashBase);
    RIPEMD160.prototype._update = function() {
      var words = ARRAY16;
      for (var j4 = 0; j4 < 16; ++j4)
        words[j4] = this._block.readInt32LE(j4 * 4);
      var al = this._a | 0;
      var bl = this._b | 0;
      var cl = this._c | 0;
      var dl = this._d | 0;
      var el = this._e | 0;
      var ar2 = this._a | 0;
      var br = this._b | 0;
      var cr2 = this._c | 0;
      var dr2 = this._d | 0;
      var er2 = this._e | 0;
      for (var i4 = 0; i4 < 80; i4 += 1) {
        var tl;
        var tr2;
        if (i4 < 16) {
          tl = fn1(al, bl, cl, dl, el, words[zl[i4]], hl[0], sl[i4]);
          tr2 = fn5(ar2, br, cr2, dr2, er2, words[zr2[i4]], hr2[0], sr2[i4]);
        } else if (i4 < 32) {
          tl = fn2(al, bl, cl, dl, el, words[zl[i4]], hl[1], sl[i4]);
          tr2 = fn4(ar2, br, cr2, dr2, er2, words[zr2[i4]], hr2[1], sr2[i4]);
        } else if (i4 < 48) {
          tl = fn3(al, bl, cl, dl, el, words[zl[i4]], hl[2], sl[i4]);
          tr2 = fn3(ar2, br, cr2, dr2, er2, words[zr2[i4]], hr2[2], sr2[i4]);
        } else if (i4 < 64) {
          tl = fn4(al, bl, cl, dl, el, words[zl[i4]], hl[3], sl[i4]);
          tr2 = fn2(ar2, br, cr2, dr2, er2, words[zr2[i4]], hr2[3], sr2[i4]);
        } else {
          tl = fn5(al, bl, cl, dl, el, words[zl[i4]], hl[4], sl[i4]);
          tr2 = fn1(ar2, br, cr2, dr2, er2, words[zr2[i4]], hr2[4], sr2[i4]);
        }
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = tl;
        ar2 = er2;
        er2 = dr2;
        dr2 = rotl(cr2, 10);
        cr2 = br;
        br = tr2;
      }
      var t5 = this._b + cl + dr2 | 0;
      this._b = this._c + dl + er2 | 0;
      this._c = this._d + el + ar2 | 0;
      this._d = this._e + al + br | 0;
      this._e = this._a + bl + cr2 | 0;
      this._a = t5;
    };
    RIPEMD160.prototype._digest = function() {
      this._block[this._blockOffset++] = 128;
      if (this._blockOffset > 56) {
        this._block.fill(0, this._blockOffset, 64);
        this._update();
        this._blockOffset = 0;
      }
      this._block.fill(0, this._blockOffset, 56);
      this._block.writeUInt32LE(this._length[0], 56);
      this._block.writeUInt32LE(this._length[1], 60);
      this._update();
      var buffer = Buffer4.alloc ? Buffer4.alloc(20) : new Buffer4(20);
      buffer.writeInt32LE(this._a, 0);
      buffer.writeInt32LE(this._b, 4);
      buffer.writeInt32LE(this._c, 8);
      buffer.writeInt32LE(this._d, 12);
      buffer.writeInt32LE(this._e, 16);
      return buffer;
    };
    function rotl(x5, n4) {
      return x5 << n4 | x5 >>> 32 - n4;
    }
    function fn1(a4, b3, c4, d4, e5, m5, k5, s4) {
      return rotl(a4 + (b3 ^ c4 ^ d4) + m5 + k5 | 0, s4) + e5 | 0;
    }
    function fn2(a4, b3, c4, d4, e5, m5, k5, s4) {
      return rotl(a4 + (b3 & c4 | ~b3 & d4) + m5 + k5 | 0, s4) + e5 | 0;
    }
    function fn3(a4, b3, c4, d4, e5, m5, k5, s4) {
      return rotl(a4 + ((b3 | ~c4) ^ d4) + m5 + k5 | 0, s4) + e5 | 0;
    }
    function fn4(a4, b3, c4, d4, e5, m5, k5, s4) {
      return rotl(a4 + (b3 & d4 | c4 & ~d4) + m5 + k5 | 0, s4) + e5 | 0;
    }
    function fn5(a4, b3, c4, d4, e5, m5, k5, s4) {
      return rotl(a4 + (b3 ^ (c4 | ~d4)) + m5 + k5 | 0, s4) + e5 | 0;
    }
    module.exports = RIPEMD160;
  }
});

// node_modules/sha.js/hash.js
var require_hash2 = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer4.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer4.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i4 = 0; i4 < remainder; i4++) {
          block[assigned + i4] = data[offset + i4];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var K3 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W3 = new Array(80);
    function Sha() {
      this.init();
      this._w = W3;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s4, b3, c4, d4) {
      if (s4 === 0)
        return b3 & c4 | ~b3 & d4;
      if (s4 === 2)
        return b3 & c4 | b3 & d4 | c4 & d4;
      return b3 ^ c4 ^ d4;
    }
    Sha.prototype._update = function(M4) {
      var W4 = this._w;
      var a4 = this._a | 0;
      var b3 = this._b | 0;
      var c4 = this._c | 0;
      var d4 = this._d | 0;
      var e5 = this._e | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W4[i4] = M4.readInt32BE(i4 * 4);
      for (; i4 < 80; ++i4)
        W4[i4] = W4[i4 - 3] ^ W4[i4 - 8] ^ W4[i4 - 14] ^ W4[i4 - 16];
      for (var j4 = 0; j4 < 80; ++j4) {
        var s4 = ~~(j4 / 20);
        var t5 = rotl5(a4) + ft(s4, b3, c4, d4) + e5 + W4[j4] + K3[s4] | 0;
        e5 = d4;
        d4 = c4;
        c4 = rotl30(b3);
        b3 = a4;
        a4 = t5;
      }
      this._a = a4 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c4 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var K3 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W3 = new Array(80);
    function Sha1() {
      this.init();
      this._w = W3;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s4, b3, c4, d4) {
      if (s4 === 0)
        return b3 & c4 | ~b3 & d4;
      if (s4 === 2)
        return b3 & c4 | b3 & d4 | c4 & d4;
      return b3 ^ c4 ^ d4;
    }
    Sha1.prototype._update = function(M4) {
      var W4 = this._w;
      var a4 = this._a | 0;
      var b3 = this._b | 0;
      var c4 = this._c | 0;
      var d4 = this._d | 0;
      var e5 = this._e | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W4[i4] = M4.readInt32BE(i4 * 4);
      for (; i4 < 80; ++i4)
        W4[i4] = rotl1(W4[i4 - 3] ^ W4[i4 - 8] ^ W4[i4 - 14] ^ W4[i4 - 16]);
      for (var j4 = 0; j4 < 80; ++j4) {
        var s4 = ~~(j4 / 20);
        var t5 = rotl5(a4) + ft(s4, b3, c4, d4) + e5 + W4[j4] + K3[s4] | 0;
        e5 = d4;
        d4 = c4;
        c4 = rotl30(b3);
        b3 = a4;
        a4 = t5;
      }
      this._a = a4 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c4 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e5 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(20);
      H4.writeInt32BE(this._a | 0, 0);
      H4.writeInt32BE(this._b | 0, 4);
      H4.writeInt32BE(this._c | 0, 8);
      H4.writeInt32BE(this._d | 0, 12);
      H4.writeInt32BE(this._e | 0, 16);
      return H4;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var K3 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W3 = new Array(64);
    function Sha256() {
      this.init();
      this._w = W3;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x5, y5, z4) {
      return z4 ^ x5 & (y5 ^ z4);
    }
    function maj(x5, y5, z4) {
      return x5 & y5 | z4 & (x5 | y5);
    }
    function sigma0(x5) {
      return (x5 >>> 2 | x5 << 30) ^ (x5 >>> 13 | x5 << 19) ^ (x5 >>> 22 | x5 << 10);
    }
    function sigma1(x5) {
      return (x5 >>> 6 | x5 << 26) ^ (x5 >>> 11 | x5 << 21) ^ (x5 >>> 25 | x5 << 7);
    }
    function gamma0(x5) {
      return (x5 >>> 7 | x5 << 25) ^ (x5 >>> 18 | x5 << 14) ^ x5 >>> 3;
    }
    function gamma1(x5) {
      return (x5 >>> 17 | x5 << 15) ^ (x5 >>> 19 | x5 << 13) ^ x5 >>> 10;
    }
    Sha256.prototype._update = function(M4) {
      var W4 = this._w;
      var a4 = this._a | 0;
      var b3 = this._b | 0;
      var c4 = this._c | 0;
      var d4 = this._d | 0;
      var e5 = this._e | 0;
      var f5 = this._f | 0;
      var g4 = this._g | 0;
      var h5 = this._h | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W4[i4] = M4.readInt32BE(i4 * 4);
      for (; i4 < 64; ++i4)
        W4[i4] = gamma1(W4[i4 - 2]) + W4[i4 - 7] + gamma0(W4[i4 - 15]) + W4[i4 - 16] | 0;
      for (var j4 = 0; j4 < 64; ++j4) {
        var T12 = h5 + sigma1(e5) + ch(e5, f5, g4) + K3[j4] + W4[j4] | 0;
        var T22 = sigma0(a4) + maj(a4, b3, c4) | 0;
        h5 = g4;
        g4 = f5;
        f5 = e5;
        e5 = d4 + T12 | 0;
        d4 = c4;
        c4 = b3;
        b3 = a4;
        a4 = T12 + T22 | 0;
      }
      this._a = a4 + this._a | 0;
      this._b = b3 + this._b | 0;
      this._c = c4 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e5 + this._e | 0;
      this._f = f5 + this._f | 0;
      this._g = g4 + this._g | 0;
      this._h = h5 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(32);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      H4.writeInt32BE(this._h, 28);
      return H4;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var W3 = new Array(64);
    function Sha224() {
      this.init();
      this._w = W3;
      Hash.call(this, 64, 56);
    }
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(28);
      H4.writeInt32BE(this._a, 0);
      H4.writeInt32BE(this._b, 4);
      H4.writeInt32BE(this._c, 8);
      H4.writeInt32BE(this._d, 12);
      H4.writeInt32BE(this._e, 16);
      H4.writeInt32BE(this._f, 20);
      H4.writeInt32BE(this._g, 24);
      return H4;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var K3 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W3 = new Array(160);
    function Sha512() {
      this.init();
      this._w = W3;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x5, y5, z4) {
      return z4 ^ x5 & (y5 ^ z4);
    }
    function maj(x5, y5, z4) {
      return x5 & y5 | z4 & (x5 | y5);
    }
    function sigma0(x5, xl) {
      return (x5 >>> 28 | xl << 4) ^ (xl >>> 2 | x5 << 30) ^ (xl >>> 7 | x5 << 25);
    }
    function sigma1(x5, xl) {
      return (x5 >>> 14 | xl << 18) ^ (x5 >>> 18 | xl << 14) ^ (xl >>> 9 | x5 << 23);
    }
    function Gamma0(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ x5 >>> 7;
    }
    function Gamma0l(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ (x5 >>> 7 | xl << 25);
    }
    function Gamma1(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ x5 >>> 6;
    }
    function Gamma1l(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ (x5 >>> 6 | xl << 26);
    }
    function getCarry(a4, b3) {
      return a4 >>> 0 < b3 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M4) {
      var W4 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i4 = 0; i4 < 32; i4 += 2) {
        W4[i4] = M4.readInt32BE(i4 * 4);
        W4[i4 + 1] = M4.readInt32BE(i4 * 4 + 4);
      }
      for (; i4 < 160; i4 += 2) {
        var xh = W4[i4 - 15 * 2];
        var xl = W4[i4 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W4[i4 - 2 * 2];
        xl = W4[i4 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W4[i4 - 7 * 2];
        var Wi7l = W4[i4 - 7 * 2 + 1];
        var Wi16h = W4[i4 - 16 * 2];
        var Wi16l = W4[i4 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W4[i4] = Wih;
        W4[i4 + 1] = Wil;
      }
      for (var j4 = 0; j4 < 160; j4 += 2) {
        Wih = W4[j4];
        Wil = W4[j4 + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K3[j4];
        var Kil = K3[j4 + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(64);
      function writeInt64BE(h5, l5, offset) {
        H4.writeInt32BE(h5, offset);
        H4.writeInt32BE(l5, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H4;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash2();
    var Buffer4 = require_safe_buffer().Buffer;
    var W3 = new Array(160);
    function Sha384() {
      this.init();
      this._w = W3;
      Hash.call(this, 128, 112);
    }
    inherits2(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H4 = Buffer4.allocUnsafe(48);
      function writeInt64BE(h5, l5, offset) {
        H4.writeInt32BE(h5, offset);
        H4.writeInt32BE(l5, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H4;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha4 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha2();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha256();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha512();
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:string_decoder
var require_string_decoder2 = __commonJS({
  "node-modules-polyfills-commonjs:string_decoder"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k5 in polyfill) {
        module.exports[k5] = polyfill[k5];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/cipher-base/index.js
var require_cipher_base = __commonJS({
  "node_modules/cipher-base/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Buffer4 = require_safe_buffer().Buffer;
    var Transform2 = require_stream().Transform;
    var StringDecoder2 = require_string_decoder2().StringDecoder;
    var inherits2 = require_inherits_browser();
    function CipherBase(hashMode) {
      Transform2.call(this);
      this.hashMode = typeof hashMode === "string";
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      if (this._final) {
        this.__final = this._final;
        this._final = null;
      }
      this._decoder = null;
      this._encoding = null;
    }
    inherits2(CipherBase, Transform2);
    CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
      if (typeof data === "string") {
        data = Buffer4.from(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode)
        return this;
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function() {
    };
    CipherBase.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    CipherBase.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    CipherBase.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    CipherBase.prototype._transform = function(data, _5, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e5) {
        err = e5;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function(done2) {
      var err;
      try {
        this.push(this.__final());
      } catch (e5) {
        err = e5;
      }
      done2(err);
    };
    CipherBase.prototype._finalOrDigest = function(outputEnc) {
      var outData = this.__final() || Buffer4.alloc(0);
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function(value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder2(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc)
        throw new Error("can't switch encodings");
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
    module.exports = CipherBase;
  }
});

// node_modules/create-hash/browser.js
var require_browser5 = __commonJS({
  "node_modules/create-hash/browser.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_inherits_browser();
    var MD5 = require_md5();
    var RIPEMD160 = require_ripemd160();
    var sha = require_sha4();
    var Base = require_cipher_base();
    function Hash(hash) {
      Base.call(this, "digest");
      this._hash = hash;
    }
    inherits2(Hash, Base);
    Hash.prototype._update = function(data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function() {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === "md5")
        return new MD5();
      if (alg === "rmd160" || alg === "ripemd160")
        return new RIPEMD160();
      return new Hash(sha(alg));
    };
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src2 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var isHexPrefixed = require_src();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/ethjs-util/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var isHexPrefixed = require_src();
    var stripHexPrefix = require_src2();
    function padToEven(value) {
      var a4 = value;
      if (typeof a4 !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a4 + ", while padToEven.");
      }
      if (a4.length % 2) {
        a4 = "0" + a4;
      }
      return a4;
    }
    function intToHex(i4) {
      var hex = i4.toString(16);
      return "0x" + hex;
    }
    function intToBuffer(i4) {
      var hex = intToHex(i4);
      return new Buffer2(padToEven(hex.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer2.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex) {
      var bufferValue = new Buffer2(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex) {
      var str = "";
      var i4 = 0, l5 = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i4 = 2;
      }
      for (; i4 < l5; i4 += 2) {
        var code = parseInt(hex.substr(i4, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer2(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex = "";
      for (var i4 = 0; i4 < stringValue.length; i4++) {
        var code = stringValue.charCodeAt(i4);
        var n4 = code.toString(16);
        hex += n4.length < 2 ? "0" + n4 : n4;
      }
      return "0x" + hex;
    }
    function getKeys(params, key2, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key2 !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key2 + "'.");
      }
      var result = [];
      for (var i4 = 0; i4 < params.length; i4++) {
        var value = params[i4][key2];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString8(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString: isHexString8
    };
  }
});

// node_modules/ethereumjs-util/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak3();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k1 = require_secp256k1_adapter();
    var assert3 = require_assert();
    var rlp = require_dist2();
    var BN6 = require_bn6();
    var createHash = require_browser5();
    var Buffer4 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib2());
    exports.MAX_INTEGER = new BN6("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN6("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer4.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer4.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer4.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN6;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer4.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a4) {
      a4 = exports.stripHexPrefix(a4);
      var first = a4[0];
      while (a4.length > 0 && first.toString() === "0") {
        a4 = a4.slice(1);
        first = a4[0];
      }
      return a4;
    };
    exports.toBuffer = function(v5) {
      if (!Buffer4.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer4.from(v5);
        } else if (typeof v5 === "string") {
          if (exports.isHexString(v5)) {
            v5 = Buffer4.from(exports.padToEven(exports.stripHexPrefix(v5)), "hex");
          } else {
            v5 = Buffer4.from(v5);
          }
        } else if (typeof v5 === "number") {
          v5 = exports.intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer4.allocUnsafe(0);
        } else if (BN6.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer4);
        } else if (v5.toArray) {
          v5 = Buffer4.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    };
    exports.bufferToInt = function(buf) {
      return new BN6(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN6(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer4.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a4, bits) {
      a4 = exports.toBuffer(a4);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a4);
        }
        case 256: {
          return k256(a4);
        }
        case 384: {
          return keccak384(a4);
        }
        case 512: {
          return keccak512(a4);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a4) {
      return exports.keccak(a4);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a4) {
      a4 = exports.toBuffer(a4);
      return createHash("sha256").update(a4).digest();
    };
    exports.ripemd160 = function(a4, padded) {
      a4 = exports.toBuffer(a4);
      var hash = createHash("rmd160").update(a4).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a4) {
      return exports.keccak(rlp.encode(a4));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer4.concat([Buffer4.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert3(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer4.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v5, r5, s4) {
      var signature = Buffer4.concat([exports.setLength(r5, 32), exports.setLength(s4, 32)], 64);
      var recovery = v5 - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v5, r5, s4) {
      if (v5 !== 27 && v5 !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer4.concat([exports.setLengthLeft(r5, 32), exports.setLengthLeft(s4, 32), exports.toBuffer(v5 - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v5 = sig[64];
      if (v5 < 27) {
        v5 += 27;
      }
      return {
        v: v5,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i4 = 0; i4 < address.length; i4++) {
        if (parseInt(hash[i4], 16) >= 8) {
          ret += address[i4].toUpperCase();
        } else {
          ret += address[i4];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from3, nonce) {
      from3 = exports.toBuffer(from3);
      nonce = new BN6(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer4.from(nonce.toArray());
      }
      return exports.rlphash([from3, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a4 = exports.unpad(address);
      return a4.length === 1 && a4[0] >= 1 && a4[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v5, r5, s4, homestead) {
      var SECP256K1_N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN6("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r5.length !== 32 || s4.length !== 32) {
        return false;
      }
      if (v5 !== 27 && v5 !== 28) {
        return false;
      }
      r5 = new BN6(r5);
      s4 = new BN6(s4);
      if (r5.isZero() || r5.gt(SECP256K1_N) || s4.isZero() || s4.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN6(s4).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba2) {
      if (Buffer4.isBuffer(ba2)) {
        return "0x" + ba2.toString("hex");
      } else if (ba2 instanceof Array) {
        var array = [];
        for (var i4 = 0; i4 < ba2.length; i4++) {
          array.push(exports.baToJSON(ba2[i4]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i4) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i4];
        }
        function setter(v5) {
          v5 = exports.toBuffer(v5);
          if (v5.toString("hex") === "00" && !field.allowZero) {
            v5 = Buffer4.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v5 = exports.stripZeros(v5);
            assert3(field.length >= v5.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v5.length === 0) && field.length) {
            assert3(field.length === v5.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i4] = v5;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer4.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer4.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d4, i4) {
            self2[self2._fields[i4]] = exports.toBuffer(d4);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys2 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys2.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys2.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var processFn = (fn2, opts) => function() {
      const P4 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i4 = 0; i4 < arguments.length; i4++) {
        args[i4] = arguments[i4];
      }
      return new P4((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i4 = 1; i4 < arguments.length; i4++) {
                results2[i4 - 1] = arguments[i4];
              }
              if (err) {
                results2.unshift(err);
                reject(results2);
              } else {
                resolve(results2);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results2 = new Array(arguments.length - 1);
              for (let i4 = 0; i4 < arguments.length; i4++) {
                results2[i4] = arguments[i4];
              }
              resolve(results2);
            } else {
              resolve(result);
            }
          });
        }
        fn2.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key2) => {
        const match = (pattern) => typeof pattern === "string" ? key2 === pattern : pattern.test(key2);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key2 in obj) {
        const x5 = obj[key2];
        ret[key2] = typeof x5 === "function" && filter(key2) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = extend;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key2 in source) {
          if (hasOwnProperty3.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max);
      return function createRandomId() {
        idCounter = idCounter % max;
        return idCounter++;
      };
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module.exports = EthQuery;
    function EthQuery(provider2) {
      const self2 = this;
      self2.currentProvider = provider2;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data) {
      return extend({
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/events/events.js
var require_events2 = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning2) {
      if (console && console.warn)
        console.warn(warning2);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once4;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners2(n4) {
      if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
      }
      this._maxListeners = n4;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners2() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit4(type2) {
      var args = [];
      for (var i4 = 1; i4 < arguments.length; i4++)
        args.push(arguments[i4]);
      var doError = type2 === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events2[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners3 = arrayClone2(handler, len);
        for (var i4 = 0; i4 < len; ++i4)
          ReflectApply(listeners3[i4], this, args);
      }
      return true;
    };
    function _addListener2(target, type2, listener, prepend) {
      var m5;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type2,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type2];
      }
      if (existing === void 0) {
        existing = events2[type2] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m5 = _getMaxListeners(target);
        if (m5 > 0 && existing.length > m5 && !existing.warned) {
          existing.warned = true;
          var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w6.name = "MaxListenersExceededWarning";
          w6.emitter = target;
          w6.type = type2;
          w6.count = existing.length;
          ProcessEmitWarning(w6);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener4(type2, listener) {
      return _addListener2(this, type2, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener3(type2, listener) {
      return _addListener2(this, type2, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap2(target, type2, listener) {
      var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once5(type2, listener) {
      checkListener(listener);
      this.on(type2, _onceWrap2(this, type2, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener2(type2, listener) {
      checkListener(listener);
      this.prependListener(type2, _onceWrap2(this, type2, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener4(type2, listener) {
      var list, events2, position, i4, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type2];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type2];
          if (events2.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i4 = list.length - 1; i4 >= 0; i4--) {
          if (list[i4] === listener || list[i4].listener === listener) {
            originalListener = list[i4].listener;
            position = i4;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne2(list, position);
        }
        if (list.length === 1)
          events2[type2] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners4(type2) {
      var listeners3, events2, i4;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type2] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events2);
        var key2;
        for (i4 = 0; i4 < keys2.length; ++i4) {
          key2 = keys2[i4];
          if (key2 === "removeListener")
            continue;
          this.removeAllListeners(key2);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners3 = events2[type2];
      if (typeof listeners3 === "function") {
        this.removeListener(type2, listeners3);
      } else if (listeners3 !== void 0) {
        for (i4 = listeners3.length - 1; i4 >= 0; i4--) {
          this.removeListener(type2, listeners3[i4]);
        }
      }
      return this;
    };
    function _listeners(target, type2, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type2];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners2(evlistener) : arrayClone2(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners3(type2) {
      return _listeners(this, type2, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type2) {
      return _listeners(this, type2, false);
    };
    EventEmitter3.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount3.call(emitter, type2);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount3;
    function listenerCount3(type2) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type2];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames2() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone2(arr, n4) {
      var copy3 = new Array(n4);
      for (var i4 = 0; i4 < n4; ++i4)
        copy3[i4] = arr[i4];
      return copy3;
    }
    function spliceOne2(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners2(arr) {
      var ret = new Array(arr.length);
      for (var i4 = 0; i4 < ret.length; ++i4) {
        ret[i4] = arr[i4].listener || arr[i4];
      }
      return ret;
    }
    function once4(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/safe-event-emitter/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var util = require_util();
    var EventEmitter3 = require_events2();
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    module.exports = SafeEventEmitter;
    function SafeEventEmitter() {
      EventEmitter3.call(this);
    }
    util.inherits(SafeEventEmitter, EventEmitter3);
    SafeEventEmitter.prototype.emit = function(type2) {
      var args = [];
      for (var i4 = 1; i4 < arguments.length; i4++)
        args.push(arguments[i4]);
      var doError = type2 === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events2[type2];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners3 = arrayClone2(handler, len);
        for (var i4 = 0; i4 < len; ++i4)
          safeApply(listeners3[i4], this, args);
      }
      return true;
    };
    function safeApply(handler, context2, args) {
      try {
        ReflectApply(handler, context2, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone2(arr, n4) {
      var copy3 = new Array(n4);
      for (var i4 = 0; i4 < n4; ++i4)
        copy3[i4] = arr[i4];
      return copy3;
    }
  }
});

// node_modules/eth-block-tracker/src/base.js
var require_base2 = __commonJS({
  "node_modules/eth-block-tracker/src/base.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EthQuery = require_eth_query();
    var pify = require_pify();
    var SafeEventEmitter = require_safe_event_emitter();
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends SafeEventEmitter {
      constructor(opts = {}) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._blockResetTimeout;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
      }
      _start() {
      }
      _end() {
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName, handler) {
        if (!blockTrackerEvents.includes(eventName))
          return;
        this._maybeStart();
      }
      _onRemoveListener(eventName, handler) {
        if (this._getBlockTrackerEventCount() > 0)
          return;
        this._maybeEnd();
      }
      _maybeStart() {
        if (this._isRunning)
          return;
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        this._start();
      }
      _maybeEnd() {
        if (!this._isRunning)
          return;
        this._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock))
          return;
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        clearTimeout(this._blockResetTimeout);
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    module.exports = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/eth-block-tracker/src/polling.js
var require_polling = __commonJS({
  "node_modules/eth-block-tracker/src/polling.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var pify = require_pify();
    var BaseBlockTracker = require_base2();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider)
          throw new Error("PollingBlockTracker - no provider specified.");
        const pollingInterval = opts.pollingInterval || 20 * sec;
        const retryTimeout = opts.retryTimeout || pollingInterval / 10;
        const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
        const setSkipCacheFlag = opts.setSkipCacheFlag || false;
        super(Object.assign({
          blockResetDuration: pollingInterval
        }, opts));
        this._provider = opts.provider;
        this._pollingInterval = pollingInterval;
        this._retryTimeout = retryTimeout;
        this._keepEventLoopActive = keepEventLoopActive;
        this._setSkipCacheFlag = setSkipCacheFlag;
      }
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      _start() {
        this._performSync().catch((err) => this.emit("error", err));
      }
      async _performSync() {
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            await timeout2(this._pollingInterval, !this._keepEventLoopActive);
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            await timeout2(this._retryTimeout, !this._keepEventLoopActive);
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
        if (this._setSkipCacheFlag)
          req.skipCache = true;
        const res = await pify((cb) => this._provider.sendAsync(req, cb))();
        if (res.error)
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
        return res.result;
      }
    };
    module.exports = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timoutRef = setTimeout(resolve, duration);
        if (timoutRef.unref && unref) {
          timoutRef.unref();
        }
      });
    }
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    module.exports = root2;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e5) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString2;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString2 = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function isObject2(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction3;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {};
    module.exports = exports["default"];
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function noop3() {
    }
    module.exports = noop3;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once4;
    function once4(fn2) {
      return function() {
        if (fn2 === null)
          return;
        var callFn = fn2;
        fn2 = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    module.exports = exports["default"];
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function baseTimes(n4, iteratee) {
      var index = -1, result = Array(n4);
      while (++index < n4) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments2 = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments2;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var isArray4 = Array.isArray;
    module.exports = isArray4;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var root2 = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer4 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0;
    var isBuffer5 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer5;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e5) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var baseTimes = require_baseTimes();
    var isArguments2 = require_isArguments();
    var isArray4 = require_isArray();
    var isBuffer5 = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray4(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer5(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty3.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty3.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys2;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    var _keys = require_keys();
    var _keys2 = _interopRequireDefault(_keys);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i4 = -1;
      var len = coll.length;
      return function next() {
        return ++i4 < len ? { value: coll[i4], key: i4 } : null;
      };
    }
    function createES2015Iterator(iterator2) {
      var i4 = -1;
      return function next() {
        var item = iterator2.next();
        if (item.done)
          return null;
        i4++;
        return { value: item.value, key: i4 };
      };
    }
    function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i4 = -1;
      var len = okeys.length;
      return function next() {
        var key2 = okeys[++i4];
        if (key2 === "__proto__") {
          return next();
        }
        return i4 < len ? { value: obj[key2], key: key2 } : null;
      };
    }
    function iterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator2 = (0, _getIterator2.default)(coll);
      return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn2) {
      return function() {
        if (fn2 === null)
          throw new Error("Callback was already called.");
        var callFn = fn2;
        fn2 = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _eachOfLimit;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done2 = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          running -= 1;
          if (err) {
            done2 = true;
            callback(err);
          } else if (value === _breakLoop2.default || done2 && running <= 0) {
            done2 = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done2) {
            var elem = nextElem();
            if (elem === null) {
              done2 = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS({
  "node_modules/async/internal/slice.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = slice3;
    function slice3(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn2) {
      return function() {
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn2.call(this, args, callback);
      };
    };
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasNextTick = exports.hasSetImmediate = void 0;
    exports.fallback = fallback;
    exports.wrap = wrap;
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn2) {
      setTimeout(fn2, 0);
    }
    function wrap(defer) {
      return function(fn2) {
        var args = (0, _slice2.default)(arguments, 1);
        defer(function() {
          fn2.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _isObject = require_isObject();
    var _isObject2 = _interopRequireDefault(_isObject);
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e5) {
          return callback(e5);
        }
        if ((0, _isObject2.default)(result) && typeof result.then === "function") {
          result.then(function(value) {
            invokeCallback(callback, null, value);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error2, value) {
      try {
        callback(error2, value);
      } catch (e5) {
        (0, _setImmediate2.default)(rethrow, e5);
      }
    }
    function rethrow(error2) {
      throw error2;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn2) {
      return supportsSymbol && fn2[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachOfLimit;
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS({
  "node_modules/async/internal/doLimit.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doLimit;
    function doLimit(fn2, limit) {
      return function(iterable, iteratee, callback) {
        return fn2(iterable, limit, iteratee, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    };
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doParallel.js
var require_doParallel = __commonJS({
  "node_modules/async/internal/doParallel.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doParallel;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function doParallel(fn2) {
      return function(obj, iteratee, callback) {
        return fn2(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/map.js
var require_map = __commonJS({
  "node_modules/async/internal/map.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _asyncMap;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || _noop2.default;
      arr = arr || [];
      var results2 = [];
      var counter = 0;
      var _iteratee = (0, _wrapAsync2.default)(iteratee);
      eachfn(arr, function(value, _5, callback2) {
        var index = counter++;
        _iteratee(value, function(err, v5) {
          results2[index] = v5;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/map.js
var require_map2 = __commonJS({
  "node_modules/async/map.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _doParallel = require_doParallel();
    var _doParallel2 = _interopRequireDefault(_doParallel);
    var _map = require_map();
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doParallel2.default)(_map2.default);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return function(value, index, callback) {
        return iteratee(value, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachLimit;
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/util/stoplight.js
var require_stoplight = __commonJS({
  "node_modules/web3-provider-engine/util/stoplight.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    module.exports = Stoplight;
    inherits2(Stoplight, EventEmitter3);
    function Stoplight() {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.isLocked = true;
    }
    Stoplight.prototype.go = function() {
      const self2 = this;
      self2.isLocked = false;
      self2.emit("unlock");
    };
    Stoplight.prototype.stop = function() {
      const self2 = this;
      self2.isLocked = true;
      self2.emit("lock");
    };
    Stoplight.prototype.await = function(fn2) {
      const self2 = this;
      if (self2.isLocked) {
        self2.once("unlock", fn2);
      } else {
        setTimeout(fn2);
      }
    };
  }
});

// node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "node_modules/jsonify/lib/parse.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    var error2 = function(m5) {
      throw {
        name: "SyntaxError",
        message: m5,
        at,
        text
      };
    };
    var next = function(c4) {
      if (c4 && c4 !== ch) {
        error2("Expected '" + c4 + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    };
    var number = function() {
      var number2, string2 = "";
      if (ch === "-") {
        string2 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        string2 += ch;
        next();
      }
      if (ch === ".") {
        string2 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          string2 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        string2 += ch;
        next();
        if (ch === "-" || ch === "+") {
          string2 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
      }
      number2 = +string2;
      if (!isFinite(number2)) {
        error2("Bad number");
      } else {
        return number2;
      }
    };
    var string = function() {
      var hex, i4, string2 = "", uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return string2;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i4 = 0; i4 < 4; i4 += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string2 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string2 += escapee[ch];
            } else {
              break;
            }
          } else {
            string2 += ch;
          }
        }
      }
      error2("Bad string");
    };
    var white = function() {
      while (ch && ch <= " ") {
        next();
      }
    };
    var word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
      }
      error2("Unexpected '" + ch + "'");
    };
    var value;
    var array = function() {
      var array2 = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return array2;
        }
        while (ch) {
          array2.push(value());
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          next(",");
          white();
        }
      }
      error2("Bad array");
    };
    var object = function() {
      var key2, object2 = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        while (ch) {
          key2 = string();
          white();
          next(":");
          if (Object.hasOwnProperty.call(object2, key2)) {
            error2('Duplicate key "' + key2 + '"');
          }
          object2[key2] = value();
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          next(",");
          white();
        }
      }
      error2("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    };
    module.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error2("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key2) {
        var k5, v5, value2 = holder[key2];
        if (value2 && typeof value2 === "object") {
          for (k5 in value2) {
            if (Object.prototype.hasOwnProperty.call(value2, k5)) {
              v5 = walk(value2, k5);
              if (v5 !== void 0) {
                value2[k5] = v5;
              } else {
                delete value2[k5];
              }
            }
          }
        }
        return reviver.call(holder, key2, value2);
      }({ "": result }, "") : result;
    };
  }
});

// node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/jsonify/lib/stringify.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a4) {
        var c4 = meta[a4];
        return typeof c4 === "string" ? c4 : "\\u" + ("0000" + a4.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key2, holder) {
      var i4, k5, v5, length, mind = gap, partial, value = holder[key2];
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key2);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key2, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "object":
          if (!value)
            return "null";
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i4 = 0; i4 < length; i4 += 1) {
              partial[i4] = str(i4, value) || "null";
            }
            v5 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v5;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i4 = 0; i4 < length; i4 += 1) {
              k5 = rep[i4];
              if (typeof k5 === "string") {
                v5 = str(k5, value);
                if (v5) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v5);
                }
              }
            }
          } else {
            for (k5 in value) {
              if (Object.prototype.hasOwnProperty.call(value, k5)) {
                v5 = str(k5, value);
                if (v5) {
                  partial.push(quote(k5) + (gap ? ": " : ":") + v5);
                }
              }
            }
          }
          v5 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v5;
      }
    }
    module.exports = function(value, replacer, space) {
      var i4;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i4 = 0; i4 < space; i4 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value });
    };
  }
});

// node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "node_modules/jsonify/index.js"(exports) {
    init_virtual_process_polyfill();
    init_buffer();
    exports.parse = require_parse();
    exports.stringify = require_stringify();
  }
});

// node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "node_modules/json-stable-stringify/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var json = typeof JSON !== "undefined" ? JSON : require_jsonify();
    module.exports = function(obj, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var space = opts.space || "";
      if (typeof space === "number")
        space = Array(space + 1).join(" ");
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var replacer = opts.replacer || function(key2, value) {
        return value;
      };
      var cmp = opts.cmp && function(f5) {
        return function(node) {
          return function(a4, b3) {
            var aobj = { key: a4, value: node[a4] };
            var bobj = { key: b3, value: node[b3] };
            return f5(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify7(parent, key2, node, level) {
        var indent = space ? "\n" + new Array(level + 1).join(space) : "";
        var colonSeparator = space ? ": " : ":";
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        node = replacer.call(parent, key2, node);
        if (node === void 0) {
          return;
        }
        if (typeof node !== "object" || node === null) {
          return json.stringify(node);
        }
        if (isArray4(node)) {
          var out = [];
          for (var i4 = 0; i4 < node.length; i4++) {
            var item = stringify7(node, i4, node[i4], level + 1) || json.stringify(null);
            out.push(indent + space + item);
          }
          return "[" + out.join(",") + indent + "]";
        } else {
          if (seen.indexOf(node) !== -1) {
            if (cycles)
              return json.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
          } else
            seen.push(node);
          var keys2 = objectKeys3(node).sort(cmp && cmp(node));
          var out = [];
          for (var i4 = 0; i4 < keys2.length; i4++) {
            var key2 = keys2[i4];
            var value = stringify7(node, key2, node[key2], level + 1);
            if (!value)
              continue;
            var keyValue = json.stringify(key2) + colonSeparator + value;
            ;
            out.push(indent + space + keyValue);
          }
          seen.splice(seen.indexOf(node), 1);
          return "{" + out.join(",") + indent + "}";
        }
      }({ "": obj }, "", obj, 0);
    };
    var isArray4 = Array.isArray || function(x5) {
      return {}.toString.call(x5) === "[object Array]";
    };
    var objectKeys3 = Object.keys || function(obj) {
      var has = Object.prototype.hasOwnProperty || function() {
        return true;
      };
      var keys2 = [];
      for (var key2 in obj) {
        if (has.call(obj, key2))
          keys2.push(key2);
      }
      return keys2;
    };
  }
});

// node_modules/web3-provider-engine/util/rpc-cache-utils.js
var require_rpc_cache_utils = __commonJS({
  "node_modules/web3-provider-engine/util/rpc-cache-utils.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var stringify7 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, opts = {}) {
      if (!canCache(payload))
        return null;
      const { includeBlockRef } = opts;
      const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify7(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/util/random-id.js
var require_random_id = __commonJS({
  "node_modules/web3-provider-engine/util/random-id.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/util/create-payload.js
var require_create_payload = __commonJS({
  "node_modules/web3-provider-engine/util/create-payload.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var getRandomId = require_random_id();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/index.js
var require_web3_provider_engine = __commonJS({
  "node_modules/web3-provider-engine/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EventEmitter3 = require_events().EventEmitter;
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist3();
    var EthBlockTracker = require_polling();
    var map3 = require_map2();
    var eachSeries = require_eachSeries();
    var Stoplight = require_stoplight();
    var cacheUtils = require_rpc_cache_utils();
    var createPayload = require_create_payload();
    var noop3 = function() {
    };
    module.exports = Web3ProviderEngine;
    inherits2(Web3ProviderEngine, EventEmitter3);
    function Web3ProviderEngine(opts) {
      const self2 = this;
      EventEmitter3.call(self2);
      self2.setMaxListeners(30);
      opts = opts || {};
      const directProvider = { sendAsync: self2._handleAsync.bind(self2) };
      const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
      self2._blockTracker = opts.blockTracker || new EthBlockTracker({
        provider: blockTrackerProvider,
        pollingInterval: opts.pollingInterval || 4e3,
        setSkipCacheFlag: true
      });
      self2._ready = new Stoplight();
      self2.currentBlock = null;
      self2._providers = [];
    }
    Web3ProviderEngine.prototype.start = function(cb = noop3) {
      const self2 = this;
      self2._ready.go();
      self2._blockTracker.on("latest", (blockNumber) => {
        self2._getBlockByNumberWithRetry(blockNumber, (err, block) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          if (!block) {
            console.log(block);
            this.emit("error", new Error("Could not find block"));
            return;
          }
          const bufferBlock = toBufferBlock(block);
          self2._setCurrentBlock(bufferBlock);
          self2.emit("rawBlock", block);
          self2.emit("latest", block);
        });
      });
      self2._blockTracker.on("sync", self2.emit.bind(self2, "sync"));
      self2._blockTracker.on("error", self2.emit.bind(self2, "error"));
      self2._running = true;
      self2.emit("start");
    };
    Web3ProviderEngine.prototype.stop = function() {
      const self2 = this;
      self2._blockTracker.removeAllListeners();
      self2._running = false;
      self2.emit("stop");
    };
    Web3ProviderEngine.prototype.isRunning = function() {
      const self2 = this;
      return self2._running;
    };
    Web3ProviderEngine.prototype.addProvider = function(source, index) {
      const self2 = this;
      if (typeof index === "number") {
        self2._providers.splice(index, 0, source);
      } else {
        self2._providers.push(source);
      }
      source.setEngine(this);
    };
    Web3ProviderEngine.prototype.removeProvider = function(source) {
      const self2 = this;
      const index = self2._providers.indexOf(source);
      if (index < 0)
        throw new Error("Provider not found.");
      self2._providers.splice(index, 1);
    };
    Web3ProviderEngine.prototype.send = function(payload) {
      throw new Error("Web3ProviderEngine does not support synchronous requests.");
    };
    Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
      const self2 = this;
      self2._ready.await(function() {
        if (Array.isArray(payload)) {
          map3(payload, self2._handleAsync.bind(self2), cb);
        } else {
          self2._handleAsync(payload, cb);
        }
      });
    };
    Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
      const self2 = this;
      let retriesRemaining = 5;
      attemptRequest();
      return;
      function attemptRequest() {
        self2._getBlockByNumber(blockNumber, afterRequest);
      }
      function afterRequest(err, block) {
        if (err)
          return cb(err);
        if (!block) {
          if (retriesRemaining > 0) {
            retriesRemaining--;
            setTimeout(function() {
              attemptRequest();
            }, 1e3);
            return;
          } else {
            cb(null, null);
            return;
          }
        }
        cb(null, block);
        return;
      }
    };
    Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
      const req = createPayload({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
      this._handleAsync(req, (err, res) => {
        if (err)
          return cb(err);
        return cb(null, res.result);
      });
    };
    Web3ProviderEngine.prototype._handleAsync = function(payload, finished) {
      var self2 = this;
      var currentProvider = -1;
      var result = null;
      var error2 = null;
      var stack = [];
      next();
      function next(after) {
        currentProvider += 1;
        stack.unshift(after);
        if (currentProvider >= self2._providers.length) {
          end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
        } else {
          try {
            var provider2 = self2._providers[currentProvider];
            provider2.handleRequest(payload, next, end);
          } catch (e5) {
            end(e5);
          }
        }
      }
      function end(_error, _result) {
        error2 = _error;
        result = _result;
        eachSeries(stack, function(fn2, callback) {
          if (fn2) {
            fn2(error2, result, callback);
          } else {
            callback();
          }
        }, function() {
          var resultObj = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result
          };
          if (error2 != null) {
            resultObj.error = {
              message: error2.stack || error2.message || error2,
              code: -32e3
            };
            finished(error2, resultObj);
          } else {
            finished(null, resultObj);
          }
        });
      }
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
      const self2 = this;
      self2.currentBlock = block;
      self2.emit("block", block);
    };
    function toBufferBlock(jsonBlock) {
      return {
        number: ethUtil.toBuffer(jsonBlock.number),
        hash: ethUtil.toBuffer(jsonBlock.hash),
        parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
        nonce: ethUtil.toBuffer(jsonBlock.nonce),
        mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
        sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
        miner: ethUtil.toBuffer(jsonBlock.miner),
        difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
        totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
        size: ethUtil.toBuffer(jsonBlock.size),
        extraData: ethUtil.toBuffer(jsonBlock.extraData),
        gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
        gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
        timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions
      };
    }
  }
});

// node_modules/web3-provider-engine/subproviders/subprovider.js
var require_subprovider = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subprovider.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var createPayload = require_create_payload();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      const self2 = this;
      if (self2.engine)
        return;
      self2.engine = engine;
      engine.on("block", function(block) {
        self2.currentBlock = block;
      });
      engine.on("start", function() {
        self2.start();
      });
      engine.on("stop", function() {
        self2.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      const self2 = this;
      self2.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware = __commonJS({
  "node_modules/web3-provider-engine/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Subprovider = require_subprovider();
    var JsonRpcEngineMiddlewareSubprovider = class extends Subprovider {
      constructor(constructorFn) {
        super();
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        this._constructorFn = constructorFn;
      }
      setEngine(engine) {
        if (this.middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
        const blockTracker = engine._blockTracker;
        const middleware = this._constructorFn({ engine, provider: engine, blockTracker });
        if (!middleware)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
        if (typeof middleware !== "function")
          throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
        this.middleware = middleware;
      }
      handleRequest(req, provEngNext, provEngEnd) {
        const res = { id: req.id };
        this.middleware(req, res, middlewareNext, middlewareEnd);
        function middlewareNext(handler) {
          provEngNext((err, result, cb) => {
            if (err) {
              delete res.result;
              res.error = { message: err.message || err };
            } else {
              res.result = result;
            }
            if (handler) {
              handler(cb);
            } else {
              cb();
            }
          });
        }
        function middlewareEnd(err) {
          if (err)
            return provEngEnd(err);
          provEngEnd(null, res.result);
        }
      }
    };
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/eth-json-rpc-middleware/cache-utils.js
var require_cache_utils = __commonJS({
  "node_modules/eth-json-rpc-middleware/cache-utils.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var stringify7 = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, skipBlockRef) {
      const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
      if (canCache(payload)) {
        return payload.method + ":" + stringify7(simpleParams);
      } else {
        return null;
      }
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      let index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      const index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
        case "test_permaCache":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
        case "test_forkCache":
          return "fork";
        case "eth_gasPrice":
        case "eth_blockNumber":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "test_blockCache":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
        case "test_neverCache":
          return "never";
      }
    }
  }
});

// node_modules/json-rpc-engine/src/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/src/createAsyncMiddleware.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function createAsyncMiddleware(asyncMiddleware) {
      return (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback, nextWasCalled;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((callback) => {
            returnHandlerCallback = callback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        asyncMiddleware(req, res, asyncNext).then(async () => {
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        }).catch((error2) => {
          if (returnHandlerCallback) {
            returnHandlerCallback(error2);
          } else {
            end(error2);
          }
        });
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/block-cache.js
var require_block_cache = __commonJS({
  "node_modules/eth-json-rpc-middleware/block-cache.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var cacheUtils = require_cache_utils();
    var createAsyncMiddleware = require_createAsyncMiddleware();
    var emptyValues = [void 0, null, "<nil>"];
    module.exports = createBlockCacheMiddleware;
    function createBlockCacheMiddleware(opts = {}) {
      const { blockTracker } = opts;
      if (!blockTracker)
        throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
      const blockCache = new BlockCacheStrategy();
      const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
      };
      return createAsyncMiddleware(async (req, res, next) => {
        if (req.skipCache) {
          return next();
        }
        const type2 = cacheUtils.cacheTypeForPayload(req);
        const strategy = strategies[type2];
        if (!strategy) {
          return next();
        }
        if (!strategy.canCacheRequest(req)) {
          return next();
        }
        let blockTag = cacheUtils.blockTagForPayload(req);
        if (!blockTag)
          blockTag = "latest";
        let requestedBlockNumber;
        if (blockTag === "earliest") {
          requestedBlockNumber = "0x00";
        } else if (blockTag === "latest") {
          const latestBlockNumber = await blockTracker.getLatestBlock();
          blockCache.clearBefore(latestBlockNumber);
          requestedBlockNumber = latestBlockNumber;
        } else {
          requestedBlockNumber = blockTag;
        }
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === void 0) {
          await next();
          await strategy.set(req, requestedBlockNumber, res.result);
        } else {
          res.result = cacheResult;
        }
      });
    }
    var BlockCacheStrategy = class {
      constructor() {
        this.cache = {};
      }
      getBlockCacheForPayload(payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        if (!blockCache) {
          const newCache = {};
          this.cache[blockNumber] = newCache;
          blockCache = newCache;
        }
        return blockCache;
      }
      async get(payload, requestedBlockNumber) {
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache)
          return;
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        const cached = blockCache[identifier];
        return cached;
      }
      async set(payload, requestedBlockNumber, result) {
        const canCache = this.canCacheResult(payload, result);
        if (!canCache)
          return;
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        blockCache[identifier] = result;
      }
      canCacheRequest(payload) {
        if (!cacheUtils.canCache(payload)) {
          return false;
        }
        const blockTag = cacheUtils.blockTagForPayload(payload);
        if (blockTag === "pending") {
          return false;
        }
        return true;
      }
      canCacheResult(payload, result) {
        if (emptyValues.includes(result))
          return;
        if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
          if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return false;
          }
        }
        return true;
      }
      clearBefore(oldBlockHex) {
        const self2 = this;
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        Object.keys(self2.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self2.cache[num]);
      }
    };
  }
});

// node_modules/web3-provider-engine/subproviders/cache.js
var require_cache = __commonJS({
  "node_modules/web3-provider-engine/subproviders/cache.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = class extends ProviderSubprovider {
      constructor(opts) {
        super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)));
      }
    };
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/subproviders/fixture.js
var require_fixture = __commonJS({
  "node_modules/web3-provider-engine/subproviders/fixture.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_util().inherits;
    var Subprovider = require_subprovider();
    module.exports = FixtureProvider;
    inherits2(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      const self2 = this;
      staticResponses = staticResponses || {};
      self2.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      var staticResponse = self2.staticResponses[payload.method];
      if ("function" === typeof staticResponse) {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(() => end(null, staticResponse));
      } else {
        next();
      }
    };
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays2;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root2 = typeof window === "object" ? window : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root2, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root2, createExporter(module.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v5) {
          return exports2[id] = previous ? previous(id, v5) : v5;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
        d4.__proto__ = b3;
      } || function(d4, b3) {
        for (var p5 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p5))
            d4[p5] = b3[p5];
      };
      __extends = function(d4, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d4, b3);
        function __() {
          this.constructor = d4;
        }
        d4.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
      __assign = Object.assign || function(t5) {
        for (var s4, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
          s4 = arguments[i4];
          for (var p5 in s4)
            if (Object.prototype.hasOwnProperty.call(s4, p5))
              t5[p5] = s4[p5];
        }
        return t5;
      };
      __rest = function(s4, e5) {
        var t5 = {};
        for (var p5 in s4)
          if (Object.prototype.hasOwnProperty.call(s4, p5) && e5.indexOf(p5) < 0)
            t5[p5] = s4[p5];
        if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i4 = 0, p5 = Object.getOwnPropertySymbols(s4); i4 < p5.length; i4++) {
            if (e5.indexOf(p5[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p5[i4]))
              t5[p5[i4]] = s4[p5[i4]];
          }
        return t5;
      };
      __decorate = function(decorators, target, key2, desc) {
        var c4 = arguments.length, r5 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r5 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i4 = decorators.length - 1; i4 >= 0; i4--)
            if (d4 = decorators[i4])
              r5 = (c4 < 3 ? d4(r5) : c4 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
        return c4 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key2) {
          decorator(target, key2, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e5) {
              reject(e5);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e5) {
              reject(e5);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _5 = { label: 0, sent: function() {
          if (t5[0] & 1)
            throw t5[1];
          return t5[1];
        }, trys: [], ops: [] }, f5, y5, t5, g4;
        return g4 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
          return this;
        }), g4;
        function verb(n4) {
          return function(v5) {
            return step([n4, v5]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_5)
            try {
              if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
                return t5;
              if (y5 = 0, t5)
                op = [op[0] & 2, t5.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t5 = op;
                  break;
                case 4:
                  _5.label++;
                  return { value: op[1], done: false };
                case 5:
                  _5.label++;
                  y5 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _5.ops.pop();
                  _5.trys.pop();
                  continue;
                default:
                  if (!(t5 = _5.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _5 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                    _5.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _5.label < t5[1]) {
                    _5.label = t5[1];
                    t5 = op;
                    break;
                  }
                  if (t5 && _5.label < t5[2]) {
                    _5.label = t5[2];
                    _5.ops.push(op);
                    break;
                  }
                  if (t5[2])
                    _5.ops.pop();
                  _5.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _5);
            } catch (e5) {
              op = [6, e5];
              y5 = 0;
            } finally {
              f5 = t5 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m5, o4) {
        for (var p5 in m5)
          if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(o4, p5))
            __createBinding(o4, m5, p5);
      };
      __createBinding = Object.create ? function(o4, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        var desc = Object.getOwnPropertyDescriptor(m5, k5);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k5];
          } };
        }
        Object.defineProperty(o4, k22, desc);
      } : function(o4, m5, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o4[k22] = m5[k5];
      };
      __values = function(o4) {
        var s4 = typeof Symbol === "function" && Symbol.iterator, m5 = s4 && o4[s4], i4 = 0;
        if (m5)
          return m5.call(o4);
        if (o4 && typeof o4.length === "number")
          return {
            next: function() {
              if (o4 && i4 >= o4.length)
                o4 = void 0;
              return { value: o4 && o4[i4++], done: !o4 };
            }
          };
        throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o4, n4) {
        var m5 = typeof Symbol === "function" && o4[Symbol.iterator];
        if (!m5)
          return o4;
        var i4 = m5.call(o4), r5, ar2 = [], e5;
        try {
          while ((n4 === void 0 || n4-- > 0) && !(r5 = i4.next()).done)
            ar2.push(r5.value);
        } catch (error2) {
          e5 = { error: error2 };
        } finally {
          try {
            if (r5 && !r5.done && (m5 = i4["return"]))
              m5.call(i4);
          } finally {
            if (e5)
              throw e5.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i4 = 0; i4 < arguments.length; i4++)
          ar2 = ar2.concat(__read(arguments[i4]));
        return ar2;
      };
      __spreadArrays2 = function() {
        for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
          s4 += arguments[i4].length;
        for (var r5 = Array(s4), k5 = 0, i4 = 0; i4 < il; i4++)
          for (var a4 = arguments[i4], j4 = 0, jl = a4.length; j4 < jl; j4++, k5++)
            r5[k5] = a4[j4];
        return r5;
      };
      __spreadArray = function(to2, from3, pack) {
        if (pack || arguments.length === 2)
          for (var i4 = 0, l5 = from3.length, ar2; i4 < l5; i4++) {
            if (ar2 || !(i4 in from3)) {
              if (!ar2)
                ar2 = Array.prototype.slice.call(from3, 0, i4);
              ar2[i4] = from3[i4];
            }
          }
        return to2.concat(ar2 || Array.prototype.slice.call(from3));
      };
      __await = function(v5) {
        return this instanceof __await ? (this.v = v5, this) : new __await(v5);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g4 = generator.apply(thisArg, _arguments || []), i4, q5 = [];
        return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4;
        function verb(n4) {
          if (g4[n4])
            i4[n4] = function(v5) {
              return new Promise(function(a4, b3) {
                q5.push([n4, v5, a4, b3]) > 1 || resume2(n4, v5);
              });
            };
        }
        function resume2(n4, v5) {
          try {
            step(g4[n4](v5));
          } catch (e5) {
            settle(q5[0][3], e5);
          }
        }
        function step(r5) {
          r5.value instanceof __await ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q5[0][2], r5);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f5, v5) {
          if (f5(v5), q5.shift(), q5.length)
            resume2(q5[0][0], q5[0][1]);
        }
      };
      __asyncDelegator = function(o4) {
        var i4, p5;
        return i4 = {}, verb("next"), verb("throw", function(e5) {
          throw e5;
        }), verb("return"), i4[Symbol.iterator] = function() {
          return this;
        }, i4;
        function verb(n4, f5) {
          i4[n4] = o4[n4] ? function(v5) {
            return (p5 = !p5) ? { value: __await(o4[n4](v5)), done: n4 === "return" } : f5 ? f5(v5) : v5;
          } : f5;
        }
      };
      __asyncValues = function(o4) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m5 = o4[Symbol.asyncIterator], i4;
        return m5 ? m5.call(o4) : (o4 = typeof __values === "function" ? __values(o4) : o4[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
          return this;
        }, i4);
        function verb(n4) {
          i4[n4] = o4[n4] && function(v5) {
            return new Promise(function(resolve, reject) {
              v5 = o4[n4](v5), settle(resolve, reject, v5.done, v5.value);
            });
          };
        }
        function settle(resolve, reject, d4, v5) {
          Promise.resolve(v5).then(function(v6) {
            resolve({ value: v6, done: d4 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o4, v5) {
        Object.defineProperty(o4, "default", { enumerable: true, value: v5 });
      } : function(o4, v5) {
        o4["default"] = v5;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k5 in mod)
            if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
              __createBinding(result, mod, k5);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f5) {
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f5) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore = function() {
      function Semaphore2(_maxConcurrency) {
        this._maxConcurrency = _maxConcurrency;
        this._queue = [];
        if (_maxConcurrency <= 0) {
          throw new Error("semaphore must be initialized to a positive value");
        }
        this._value = _maxConcurrency;
      }
      Semaphore2.prototype.acquire = function() {
        var _this = this;
        var locked = this.isLocked();
        var ticket = new Promise(function(r5) {
          return _this._queue.push(r5);
        });
        if (!locked)
          this._dispatch();
        return ticket;
      };
      Semaphore2.prototype.runExclusive = function(callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a2, value, release4;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                _a2 = _b.sent(), value = _a2[0], release4 = _a2[1];
                _b.label = 2;
              case 2:
                _b.trys.push([2, , 4, 5]);
                return [4, callback(value)];
              case 3:
                return [2, _b.sent()];
              case 4:
                release4();
                return [7];
              case 5:
                return [2];
            }
          });
        });
      };
      Semaphore2.prototype.isLocked = function() {
        return this._value <= 0;
      };
      Semaphore2.prototype.release = function() {
        if (this._maxConcurrency > 1) {
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        }
        if (this._currentReleaser) {
          var releaser = this._currentReleaser;
          this._currentReleaser = void 0;
          releaser();
        }
      };
      Semaphore2.prototype._dispatch = function() {
        var _this = this;
        var nextConsumer = this._queue.shift();
        if (!nextConsumer)
          return;
        var released = false;
        this._currentReleaser = function() {
          if (released)
            return;
          released = true;
          _this._value++;
          _this._dispatch();
        };
        nextConsumer([this._value--, this._currentReleaser]);
      };
      return Semaphore2;
    }();
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore_1 = require_Semaphore();
    var Mutex = function() {
      function Mutex2() {
        this._semaphore = new Semaphore_1.default(1);
      }
      Mutex2.prototype.acquire = function() {
        return tslib_1.__awaiter(this, void 0, void 0, function() {
          var _a2, releaser;
          return tslib_1.__generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                _a2 = _b.sent(), releaser = _a2[1];
                return [2, releaser];
            }
          });
        });
      };
      Mutex2.prototype.runExclusive = function(callback) {
        return this._semaphore.runExclusive(function() {
          return callback();
        });
      };
      Mutex2.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      };
      Mutex2.prototype.release = function() {
        this._semaphore.release();
      };
      return Mutex2;
    }();
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_1 = require_tslib();
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release4;
              return tslib_1.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a2.sent();
                    if (isTimeout) {
                      release4 = Array.isArray(ticket) ? ticket[1] : ticket;
                      release4();
                    } else {
                      resolve(ticket);
                    }
                    return [2];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release4, ticket;
            return tslib_1.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  release4 = function() {
                    return void 0;
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a2.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release4 = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a2.sent()];
                case 4:
                  release4 = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a2.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release4();
                  return [7];
                case 8:
                  return [2];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/getUniqueId.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports.getUniqueId = getUniqueId;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done2) => {
          req.id = originalId;
          res.id = originalId;
          done2();
        });
      };
    }
    exports.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error2) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error2);
          } else {
            end(error2);
          }
        }
      };
    }
    exports.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter2 = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context2, args) {
      try {
        Reflect.apply(handler, context2, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone2(arr) {
      const n4 = arr.length;
      const copy3 = new Array(n4);
      for (let i4 = 0; i4 < n4; i4 += 1) {
        copy3[i4] = arr[i4];
      }
      return copy3;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type2, ...args) {
        let doError = type2 === "error";
        const events2 = this._events;
        if (events2 !== void 0) {
          doError = doError && events2.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er2;
          if (args.length > 0) {
            [er2] = args;
          }
          if (er2 instanceof Error) {
            throw er2;
          }
          const err = new Error(`Unhandled error.${er2 ? ` (${er2.message})` : ""}`);
          err.context = er2;
          throw err;
        }
        const handler = events2[type2];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners3 = arrayClone2(handler);
          for (let i4 = 0; i4 < len; i4 += 1) {
            safeApply(listeners3[i4], this, args);
          }
        }
        return true;
      }
    };
    exports.default = SafeEventEmitter;
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = stringify7;
    stringify7.default = stringify7;
    stringify7.stable = deterministicStringify;
    stringify7.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify7(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_5) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k5, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k5);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k5, { value: replace });
          arr.push([parent, k5, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k5, replace]);
        }
      } else {
        parent[k5] = replace;
        arr.push([parent, k5, val]);
      }
    }
    function decirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            decirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var keys2 = Object.keys(val);
          for (i4 = 0; i4 < keys2.length; i4++) {
            var key2 = keys2[i4];
            decirc(val[key2], key2, i4, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a4, b3) {
      if (a4 < b3) {
        return -1;
      }
      if (a4 > b3) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_5) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_5) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            deterministicDecirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys2 = Object.keys(val).sort(compareFunction);
          for (i4 = 0; i4 < keys2.length; i4++) {
            var key2 = keys2[i4];
            deterministicDecirc(val[key2], key2, i4, stack, val, depth, options);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k5, val]);
            parent[k5] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k5, v5) {
        return v5;
      };
      return function(key2, val) {
        if (replacerStack.length > 0) {
          for (var i4 = 0; i4 < replacerStack.length; i4++) {
            var part = replacerStack[i4];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i4, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_5, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/utils.js
var require_utils6 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error2, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a2, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error2 instanceof classes_1.EthereumRpcError) {
        return error2.serialize();
      }
      const serialized = {};
      if (error2 && typeof error2 === "object" && !Array.isArray(error2) && hasKey(error2, "code") && isValidCode(error2.code)) {
        const _error = error2;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error2) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a2 = error2) === null || _a2 === void 0 ? void 0 : _a2.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error2) };
      }
      const stack = (_b = error2) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error2 && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error2) {
      if (error2 && typeof error2 === "object" && !Array.isArray(error2)) {
        return Object.assign({}, error2);
      }
      return error2;
    }
    function hasKey(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils6();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils6();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault(require_safe_event_emitter2());
    var eth_rpc_errors_1 = require_dist4();
    var JsonRpcEngine = class extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error2) {
                return handlerCallback(error2);
              }
              return handlerCallback();
            });
          } catch (error2) {
            return end(error2);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(
            reqs.map(this._promiseHandle.bind(this))
          );
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error2) {
          if (cb) {
            return cb(error2);
          }
          throw error2;
        }
      }
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error3 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error3, { id: void 0, jsonrpc: "2.0", error: error3 });
        }
        if (typeof callerReq.method !== "string") {
          const error3 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error3, { id: callerReq.id, jsonrpc: "2.0", error: error3 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error2 = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error2 = _error;
        }
        if (error2) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error2);
          }
        }
        return cb(error2, res);
      }
      async _processRequest(req, res) {
        const [error2, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error2) {
          throw error2;
        }
      }
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error2 = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error2, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error2, isComplete, returnHandlers.reverse()];
      }
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error2 = err || res.error;
            if (error2) {
              res.error = eth_rpc_errors_1.serializeError(error2);
            }
            resolve([error2, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error2) {
            end(error2);
          }
        });
      }
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request3) {
      return JSON.stringify(request3, null, 2);
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/json-rpc-engine/dist/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o4, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_idRemapMiddleware(), exports);
    __exportStar(require_createAsyncMiddleware2(), exports);
    __exportStar(require_createScaffoldMiddleware(), exports);
    __exportStar(require_getUniqueId(), exports);
    __exportStar(require_JsonRpcEngine(), exports);
    __exportStar(require_mergeMiddleware(), exports);
  }
});

// node_modules/json-rpc-engine/src/createScaffoldMiddleware.js
var require_createScaffoldMiddleware2 = __commonJS({
  "node_modules/json-rpc-engine/src/createScaffoldMiddleware.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/scaffold.js
var require_scaffold = __commonJS({
  "node_modules/eth-json-rpc-middleware/scaffold.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_createScaffoldMiddleware2();
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var processFn = (fn2, options, proxy, unwrapped) => function(...arguments_) {
      const P4 = options.promiseModule;
      return new P4((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error2, result) => {
            if (error2) {
              reject(error2);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy ? unwrapped : this;
        Reflect.apply(fn2, self2, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = (target, key2) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key2 in cached) {
          return cached[key2];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key2 === "symbol" ? key2 === pattern : pattern.test(key2);
        const desc = Reflect.getOwnPropertyDescriptor(target, key2);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key2] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key2) {
          const property = target[key2];
          if (!filter(target, key2) || property === Function.prototype[key2]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var SafeEventEmitter = require_safe_event_emitter2().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn2) {
      return "0x" + bn2.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i4 = 0; i4 < byteCount; i4++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider: provider2, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider2);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log2) => this.matchLog(log2));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log2) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log2.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log2.blockNumber))
          return false;
        const normalizedLogAddress = log2.address && log2.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log2.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider: provider2, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_5, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider2, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function query(provider2, method, params) {
      return new Promise((resolve, reject) => {
        provider2.sendAsync({ id: 1, jsonrpc: "2.0", method, params }, (err, res) => {
          if (err)
            return reject(err);
          resolve(res.result);
        });
      });
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider: provider2, params }) {
        super();
        this.type = "block";
        this.provider = provider2;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider: provider2 }) {
        super();
        this.type = "tx";
        this.provider = provider2;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var Mutex = require_lib3().Mutex;
    var { createAsyncMiddleware } = require_dist5();
    var createJsonRpcMiddleware = require_scaffold();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider: provider2 }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createJsonRpcMiddleware({
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter) => {
            try {
              await filter.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter = new LogFilter({ provider: provider2, params });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function newBlockFilter() {
        const filter = new BlockFilter({ provider: provider2 });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function newPendingTransactionFilter() {
        const filter = new TxFilter({ provider: provider2 });
        const filterIndex2 = await installFilter(filter);
        return filter;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results2 = filter.getChangesAndClear();
        return results2;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        if (filter.type === "log") {
          results = filter.getAllResults();
        } else {
          results = [];
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter = filters[filterIndex2];
        const result = Boolean(filter);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter;
        filter.id = filterIndex;
        filter.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter = await createFilterFn(...args);
        const result = intToHex(filter.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn2) {
      const values = [];
      for (let key2 in obj) {
        values.push(obj[key2]);
      }
      return values;
    }
  }
});

// node_modules/web3-provider-engine/subproviders/filters.js
var require_filters = __commonJS({
  "node_modules/web3-provider-engine/subproviders/filters.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider2 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider: provider2, engine }) => {
          return createFilterMiddleware({ blockTracker, provider: provider2 });
        });
      }
    };
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/async/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/async/waterfall.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(tasks, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (!(0, _isArray2.default)(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
      }
      nextTask([]);
    };
    var _isArray = require_isArray();
    var _isArray2 = _interopRequireDefault(_isArray);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _parallel;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results2 = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, function(task, key2, callback2) {
        (0, _wrapAsync2.default)(task)(function(err, result) {
          if (arguments.length > 2) {
            result = (0, _slice2.default)(arguments, 1);
          }
          results2[key2] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results2);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/async/parallel.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parallelLimit;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _parallel = require_parallel();
    var _parallel2 = _interopRequireDefault(_parallel);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parallelLimit(tasks, callback) {
      (0, _parallel2.default)(_eachOf2.default, tasks, callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
var require_secp256k1v3_lib = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var BN6 = require_bn6();
    var EC = require_elliptic().ec;
    var ec2 = new EC("secp256k1");
    var ecparams = ec2.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var d4 = new BN6(privateKey);
      if (d4.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec2.g.mul(d4);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn2 = new BN6(privateKey);
      if (bn2.ucmp(ecparams.n) >= 0 || bn2.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn2.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r5 = new BN6(sigObj.r);
      if (r5.ucmp(ecparams.n) >= 0) {
        r5 = new BN6(0);
      }
      var s4 = new BN6(sigObj.s);
      if (s4.ucmp(ecparams.n) >= 0) {
        s4 = new BN6(0);
      }
      return Buffer2.concat([r5.toArrayLike(Buffer2, "be", 32), s4.toArrayLike(Buffer2, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var point = ec2.keyFromPublic(publicKey);
      var scalar = new BN6(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function(x5, y5, compressed) {
      var publicKey;
      if (compressed) {
        publicKey = Buffer2.alloc(33);
        publicKey[0] = y5.isOdd() ? 3 : 2;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer2.alloc(65);
        publicKey[0] = 4;
        x5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 1);
        y5.toArrayLike(Buffer2, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
var require_der2 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r5 = Buffer2.alloc(32, 0);
      var s4 = Buffer2.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + signature[index];
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + signature[index];
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r5, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s4, 32 - svalue.length);
      return { r: r5, s: s4 };
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
var require_secp256k1v3_adapter = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
    var secp256k1 = require_secp256k12();
    var secp256k1v3 = require_secp256k1v3_lib();
    var der = require_der2();
    exports.privateKeyVerify = function(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    exports.privateKeyImport = function(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    exports.privateKeyNegate = function(privateKey) {
      return Buffer2.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    exports.privateKeyModInverse = function(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      return Buffer2.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    exports.publicKeyConvert = function(publicKey, compressed) {
      return Buffer2.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    exports.publicKeyVerify = function(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    exports.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyTweakMul = function(publicKey, tweak, compressed) {
      return Buffer2.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var keys2 = [];
      publicKeys.forEach(function(publicKey) {
        keys2.push(Uint8Array.from(publicKey));
      });
      return Buffer2.from(secp256k1.publicKeyCombine(keys2, compressed));
    };
    exports.signatureNormalize = function(signature) {
      return Buffer2.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    exports.signatureExport = function(signature) {
      return Buffer2.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    exports.signatureImport = function(signature) {
      return Buffer2.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    exports.signatureImportLax = function(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    exports.sign = function(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length != 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer2.from(algo) : null;
            var bufferData = data != null ? Buffer2.from(data) : null;
            var buffer = Buffer2.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer2.from(message2), Buffer2.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return new Uint8Array(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer2.from(sig.signature),
        recovery: sig.recid
      };
    };
    exports.verify = function(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    exports.recover = function(message, signature, recid, compressed) {
      return Buffer2.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    exports.ecdh = function(publicKey, privateKey) {
      return Buffer2.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer2.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js
var require_constants = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
    var BN6 = require_bn6();
    exports.MAX_INTEGER = new BN6("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN6("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
    var ethjsUtil = require_lib2();
    var BN6 = require_bn6();
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.setLengthLeft = function(msg, length, right) {
      if (right === void 0) {
        right = false;
      }
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLength = exports.setLengthLeft;
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = function(a4) {
      a4 = ethjsUtil.stripHexPrefix(a4);
      var first = a4[0];
      while (a4.length > 0 && first.toString() === "0") {
        a4 = a4.slice(1);
        first = a4[0];
      }
      return a4;
    };
    exports.stripZeros = exports.unpad;
    exports.toBuffer = function(v5) {
      if (!Buffer2.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer2.from(v5);
        } else if (typeof v5 === "string") {
          if (ethjsUtil.isHexString(v5)) {
            v5 = Buffer2.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v5)), "hex");
          } else {
            throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v5);
          }
        } else if (typeof v5 === "number") {
          v5 = ethjsUtil.intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer2.allocUnsafe(0);
        } else if (BN6.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer2);
        } else if (v5.toArray) {
          v5 = Buffer2.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    };
    exports.bufferToInt = function(buf) {
      return new BN6(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN6(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return ethjsUtil.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.baToJSON = function(ba2) {
      if (Buffer2.isBuffer(ba2)) {
        return "0x" + ba2.toString("hex");
      } else if (ba2 instanceof Array) {
        var array = [];
        for (var i4 = 0; i4 < ba2.length; i4++) {
          array.push(exports.baToJSON(ba2[i4]));
        }
        return array;
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js
var require_hash3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
    var _a2 = require_keccak3();
    var keccak224 = _a2.keccak224;
    var keccak384 = _a2.keccak384;
    var k256 = _a2.keccak256;
    var keccak512 = _a2.keccak512;
    var createHash = require_browser5();
    var ethjsUtil = require_lib2();
    var rlp = require_dist2();
    var bytes_1 = require_bytes();
    exports.keccak = function(a4, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      if (typeof a4 === "string" && !ethjsUtil.isHexString(a4)) {
        a4 = Buffer2.from(a4, "utf8");
      } else {
        a4 = bytes_1.toBuffer(a4);
      }
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a4);
        }
        case 256: {
          return k256(a4);
        }
        case 384: {
          return keccak384(a4);
        }
        case 512: {
          return keccak512(a4);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a4) {
      return exports.keccak(a4);
    };
    exports.sha256 = function(a4) {
      a4 = bytes_1.toBuffer(a4);
      return createHash("sha256").update(a4).digest();
    };
    exports.ripemd160 = function(a4, padded) {
      a4 = bytes_1.toBuffer(a4);
      var hash = createHash("rmd160").update(a4).digest();
      if (padded === true) {
        return bytes_1.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a4) {
      return exports.keccak(rlp.encode(a4));
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js
var require_account = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
    var assert3 = require_assert();
    var ethjsUtil = require_lib2();
    var secp256k1 = require_secp256k1v3_adapter();
    var BN6 = require_bn6();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.zeroAddress = function() {
      var addressLength = 20;
      var addr = bytes_1.zeros(addressLength);
      return bytes_1.bufferToHex(addr);
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddr = exports.zeroAddress();
      return zeroAddr === bytes_1.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address, eip1191ChainId) {
      address = ethjsUtil.stripHexPrefix(address).toLowerCase();
      var prefix = eip1191ChainId !== void 0 ? eip1191ChainId.toString() + "0x" : "";
      var hash = hash_1.keccak(prefix + address).toString("hex");
      var ret = "0x";
      for (var i4 = 0; i4 < address.length; i4++) {
        if (parseInt(hash[i4], 16) >= 8) {
          ret += address[i4].toUpperCase();
        } else {
          ret += address[i4];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address, eip1191ChainId) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
    };
    exports.generateAddress = function(from3, nonce) {
      from3 = bytes_1.toBuffer(from3);
      var nonceBN = new BN6(nonce);
      if (nonceBN.isZero()) {
        return hash_1.rlphash([from3, null]).slice(-20);
      }
      return hash_1.rlphash([from3, Buffer2.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress2 = function(from3, salt, initCode) {
      var fromBuf = bytes_1.toBuffer(from3);
      var saltBuf = bytes_1.toBuffer(salt);
      var initCodeBuf = bytes_1.toBuffer(initCode);
      assert3(fromBuf.length === 20);
      assert3(saltBuf.length === 32);
      var address = hash_1.keccak256(Buffer2.concat([Buffer2.from("ff", "hex"), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
      return address.slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a4 = bytes_1.unpad(address);
      return a4.length === 1 && a4[0] >= 1 && a4[0] <= 8;
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      pubKey = bytes_1.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert3(pubKey.length === 64);
      return hash_1.keccak(pubKey).slice(-20);
    };
    exports.publicToAddress = exports.pubToAddress;
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(exports.privateToPublic(privateKey));
    };
    exports.privateToPublic = function(privateKey) {
      privateKey = bytes_1.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = bytes_1.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js
var require_signature3 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    var BN6 = require_bn6();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash3();
    exports.ecsign = function(msgHash, privateKey, chainId) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var recovery = sig.recovery;
      var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
      };
      return ret;
    };
    exports.ecrecover = function(msgHash, v5, r5, s4, chainId) {
      var signature = Buffer2.concat([bytes_1.setLength(r5, 32), bytes_1.setLength(s4, 32)], 64);
      var recovery = calculateSigRecovery(v5, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v5, r5, s4, chainId) {
      var recovery = calculateSigRecovery(v5, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return bytes_1.bufferToHex(Buffer2.concat([bytes_1.setLengthLeft(r5, 32), bytes_1.setLengthLeft(s4, 32), bytes_1.toBuffer(v5)]));
    };
    exports.fromRpcSig = function(sig) {
      var buf = bytes_1.toBuffer(sig);
      if (buf.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v5 = buf[64];
      if (v5 < 27) {
        v5 += 27;
      }
      return {
        v: v5,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64)
      };
    };
    exports.isValidSignature = function(v5, r5, s4, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN6("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r5.length !== 32 || s4.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v5, chainId))) {
        return false;
      }
      var rBN = new BN6(r5);
      var sBN = new BN6(s4);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = Buffer2.from("Ethereum Signed Message:\n" + message.length.toString(), "utf-8");
      return hash_1.keccak(Buffer2.concat([prefix, message]));
    };
    function calculateSigRecovery(v5, chainId) {
      return chainId ? v5 - (2 * chainId + 35) : v5 - 27;
    }
    function isValidSigRecovery(recovery) {
      return recovery === 0 || recovery === 1;
    }
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert3 = require_assert();
    var ethjsUtil = require_lib2();
    var rlp = require_dist2();
    var bytes_1 = require_bytes();
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x" + self2[field].toString("hex");
          });
          return obj_1;
        }
        return bytes_1.baToJSON(self2.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i4) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i4];
        }
        function setter(v5) {
          v5 = bytes_1.toBuffer(v5);
          if (v5.toString("hex") === "00" && !field.allowZero) {
            v5 = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v5 = bytes_1.stripZeros(v5);
            assert3(field.length >= v5.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v5.length === 0) && field.length) {
            assert3(field.length === v5.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i4] = v5;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(ethjsUtil.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d4, i4) {
            self2[self2._fields[i4]] = bytes_1.toBuffer(d4);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o4, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o4, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o4[k22] = m5[k5];
    });
    var __exportStar = exports && exports.__exportStar || function(m5, exports2) {
      for (var p5 in m5)
        if (p5 !== "default" && !exports2.hasOwnProperty(p5))
          __createBinding(exports2, m5, p5);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = exports.rlp = exports.BN = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    exports.secp256k1 = secp256k1;
    var ethjsUtil = require_lib2();
    var BN6 = require_bn6();
    exports.BN = BN6;
    var rlp = require_dist2();
    exports.rlp = rlp;
    Object.assign(exports, ethjsUtil);
    __exportStar(require_constants(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_hash3(), exports);
    __exportStar(require_signature3(), exports);
    __exportStar(require_bytes(), exports);
    __exportStar(require_object(), exports);
  }
});

// node_modules/ethereumjs-abi/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ethereumjs-abi/lib/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var utils = require_dist6();
    var BN6 = require_bn6();
    var ABI = function() {
    };
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    ABI.eventID = function(name, types) {
      var sig = name + "(" + types.map(elementaryName).join(",") + ")";
      return utils.keccak256(Buffer2.from(sig));
    };
    ABI.methodID = function(name, types) {
      return ABI.eventID(name, types).slice(0, 4);
    };
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (utils.isHexPrefixed(arg)) {
          return new BN6(utils.stripHexPrefix(arg), 16);
        } else {
          return new BN6(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN6(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function parseSignature(sig) {
      var tmp = /^(\w+)\((.*)\)$/.exec(sig);
      if (tmp.length !== 3) {
        throw new Error("Invalid method signature");
      }
      var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
      if (args !== null && args.length === 3) {
        return {
          method: tmp[1],
          args: args[1].split(","),
          retargs: args[2].split(",")
        };
      } else {
        var params = tmp[2].split(",");
        if (params.length === 1 && params[0] === "") {
          params = [];
        }
        return {
          method: tmp[1],
          args: params
        };
      }
    }
    function encodeSingle(type2, arg) {
      var size, num, ret, i4;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", Buffer2.from(arg, "utf8"));
      } else if (isArray4(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type2);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i4 in arg) {
          ret.push(encodeSingle(type2, arg[i4]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer2.concat(ret);
      } else if (type2 === "bytes") {
        arg = Buffer2.from(arg);
        ret = Buffer2.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer2.concat([ret, utils.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer2, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN6(2).pow(new BN6(size[1]))));
      } else if (type2.startsWith("fixed")) {
        size = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN6(2).pow(new BN6(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function decodeSingle(parsedType, data, offset) {
      if (typeof parsedType === "string") {
        parsedType = parseType(parsedType);
      }
      var size, num, ret, i4;
      if (parsedType.name === "address") {
        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer2, "be", 20).toString("hex");
      } else if (parsedType.name === "bool") {
        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN6(1).toString();
      } else if (parsedType.name === "string") {
        var bytes = decodeSingle(parsedType.rawType, data, offset);
        return Buffer2.from(bytes, "utf8").toString();
      } else if (parsedType.isArray) {
        ret = [];
        size = parsedType.size;
        if (parsedType.size === "dynamic") {
          offset = decodeSingle("uint256", data, offset).toNumber();
          size = decodeSingle("uint256", data, offset).toNumber();
          offset = offset + 32;
        }
        for (i4 = 0; i4 < size; i4++) {
          var decoded = decodeSingle(parsedType.subArray, data, offset);
          ret.push(decoded);
          offset += parsedType.subArray.memoryUsage;
        }
        return ret;
      } else if (parsedType.name === "bytes") {
        offset = decodeSingle("uint256", data, offset).toNumber();
        size = decodeSingle("uint256", data, offset).toNumber();
        return data.slice(offset + 32, offset + 32 + size);
      } else if (parsedType.name.startsWith("bytes")) {
        return data.slice(offset, offset + parsedType.size);
      } else if (parsedType.name.startsWith("uint")) {
        num = new BN6(data.slice(offset, offset + 32), 16, "be");
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("int")) {
        num = new BN6(data.slice(offset, offset + 32), 16, "be").fromTwos(256);
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("ufixed")) {
        size = new BN6(2).pow(new BN6(parsedType.size[1]));
        num = decodeSingle("uint256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      } else if (parsedType.name.startsWith("fixed")) {
        size = new BN6(2).pow(new BN6(parsedType.size[1]));
        num = decodeSingle("int256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      }
      throw new Error("Unsupported or invalid type: " + parsedType.name);
    }
    function parseType(type2) {
      var size;
      var ret;
      if (isArray4(type2)) {
        size = parseTypeArray(type2);
        var subArray = type2.slice(0, type2.lastIndexOf("["));
        subArray = parseType(subArray);
        ret = {
          isArray: true,
          name: type2,
          size,
          memoryUsage: size === "dynamic" ? 32 : subArray.memoryUsage * size,
          subArray
        };
        return ret;
      } else {
        var rawType;
        switch (type2) {
          case "address":
            rawType = "uint160";
            break;
          case "bool":
            rawType = "uint8";
            break;
          case "string":
            rawType = "bytes";
            break;
        }
        ret = {
          rawType,
          name: type2,
          memoryUsage: 32
        };
        if (type2.startsWith("bytes") && type2 !== "bytes" || type2.startsWith("uint") || type2.startsWith("int")) {
          ret.size = parseTypeN(type2);
        } else if (type2.startsWith("ufixed") || type2.startsWith("fixed")) {
          ret.size = parseTypeNxM(type2);
        }
        if (type2.startsWith("bytes") && type2 !== "bytes" && (ret.size < 1 || ret.size > 32)) {
          throw new Error("Invalid bytes<N> width: " + ret.size);
        }
        if ((type2.startsWith("uint") || type2.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
          throw new Error("Invalid int/uint<N> width: " + ret.size);
        }
        return ret;
      }
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray4(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    ABI.rawEncode = function(types, values) {
      var output = [];
      var data = [];
      var headLength = 0;
      types.forEach(function(type3) {
        if (isArray4(type3)) {
          var size = parseTypeArray(type3);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (var i4 = 0; i4 < types.length; i4++) {
        var type2 = elementaryName(types[i4]);
        var value = values[i4];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer2.concat(output.concat(data));
    };
    ABI.rawDecode = function(types, data) {
      var ret = [];
      data = Buffer2.from(data);
      var offset = 0;
      for (var i4 = 0; i4 < types.length; i4++) {
        var type2 = elementaryName(types[i4]);
        var parsed = parseType(type2, data, offset);
        var decoded = decodeSingle(parsed, data, offset);
        offset += parsed.memoryUsage;
        ret.push(decoded);
      }
      return ret;
    };
    ABI.simpleEncode = function(method) {
      var args = Array.prototype.slice.call(arguments).slice(1);
      var sig = parseSignature(method);
      if (args.length !== sig.args.length) {
        throw new Error("Argument count mismatch");
      }
      return Buffer2.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
    };
    ABI.simpleDecode = function(method, data) {
      var sig = parseSignature(method);
      if (!sig.retargs) {
        throw new Error("No return values in method");
      }
      return ABI.rawDecode(sig.retargs, data);
    };
    function stringify7(type2, value) {
      if (type2.startsWith("address") || type2.startsWith("bytes")) {
        return "0x" + value.toString("hex");
      } else {
        return value.toString();
      }
    }
    ABI.stringify = function(types, values) {
      var ret = [];
      for (var i4 in types) {
        var type2 = types[i4];
        var value = values[i4];
        if (/^[^\[]+\[.*\]$/.test(type2)) {
          value = value.map(function(item) {
            return stringify7(type2, item);
          }).join(", ");
        } else {
          value = stringify7(type2, value);
        }
        ret.push(value);
      }
      return ret;
    };
    ABI.solidityHexValue = function(type2, value, bitsize) {
      var size, num;
      if (isArray4(type2)) {
        var subType = type2.replace(/\[.*?\]/, "");
        if (!isArray4(subType)) {
          var arraySize = parseTypeArray(type2);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error("Elements exceed array size: " + arraySize);
          }
        }
        var arrayValues = value.map(function(v5) {
          return ABI.solidityHexValue(subType, v5, 256);
        });
        return Buffer2.concat(arrayValues);
      } else if (type2 === "bytes") {
        return value;
      } else if (type2 === "string") {
        return Buffer2.from(value, "utf8");
      } else if (type2 === "bool") {
        bitsize = bitsize || 8;
        var padding = Array(bitsize / 4).join("0");
        return Buffer2.from(value ? padding + "1" : padding + "0", "hex");
      } else if (type2 === "address") {
        var bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return utils.setLengthLeft(value, bytesize);
      } else if (type2.startsWith("bytes")) {
        size = parseTypeN(type2);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(value, size);
      } else if (type2.startsWith("uint")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer2, "be", bitsize / 8);
      } else if (type2.startsWith("int")) {
        size = parseTypeN(type2);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer2, "be", bitsize / 8);
      } else {
        throw new Error("Unsupported or invalid type: " + type2);
      }
    };
    ABI.solidityPack = function(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var ret = [];
      for (var i4 = 0; i4 < types.length; i4++) {
        var type2 = elementaryName(types[i4]);
        var value = values[i4];
        ret.push(ABI.solidityHexValue(type2, value, null));
      }
      return Buffer2.concat(ret);
    };
    ABI.soliditySHA3 = function(types, values) {
      return utils.keccak256(ABI.solidityPack(types, values));
    };
    ABI.soliditySHA256 = function(types, values) {
      return utils.sha256(ABI.solidityPack(types, values));
    };
    ABI.solidityRIPEMD160 = function(types, values) {
      return utils.ripemd160(ABI.solidityPack(types, values), true);
    };
    function isNumeric(c4) {
      return c4 >= "0" && c4 <= "9";
    }
    ABI.fromSerpent = function(sig) {
      var ret = [];
      for (var i4 = 0; i4 < sig.length; i4++) {
        var type2 = sig[i4];
        if (type2 === "s") {
          ret.push("bytes");
        } else if (type2 === "b") {
          var tmp = "bytes";
          var j4 = i4 + 1;
          while (j4 < sig.length && isNumeric(sig[j4])) {
            tmp += sig[j4] - "0";
            j4++;
          }
          i4 = j4 - 1;
          ret.push(tmp);
        } else if (type2 === "i") {
          ret.push("int256");
        } else if (type2 === "a") {
          ret.push("int256[]");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret;
    };
    ABI.toSerpent = function(types) {
      var ret = [];
      for (var i4 = 0; i4 < types.length; i4++) {
        var type2 = types[i4];
        if (type2 === "bytes") {
          ret.push("s");
        } else if (type2.startsWith("bytes")) {
          ret.push("b" + parseTypeN(type2));
        } else if (type2 === "int256") {
          ret.push("i");
        } else if (type2 === "int256[]") {
          ret.push("a");
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return ret.join("");
    };
    module.exports = ABI;
  }
});

// node_modules/ethereumjs-abi/index.js
var require_ethereumjs_abi = __commonJS({
  "node_modules/ethereumjs-abi/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    module.exports = require_lib4();
  }
});

// node_modules/eth-sig-util/index.js
var require_eth_sig_util = __commonJS({
  "node_modules/eth-sig-util/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var ethUtil = require_dist3();
    var ethAbi = require_ethereumjs_abi();
    module.exports = {
      concatSig: function(v5, r5, s4) {
        const rSig = ethUtil.fromSigned(r5);
        const sSig = ethUtil.fromSigned(s4);
        const vSig = ethUtil.bufferToInt(v5);
        const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString("hex"), 64);
        const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString("hex"), 64);
        const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
        return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString("hex");
      },
      normalize: function(input) {
        if (!input)
          return;
        if (typeof input === "number") {
          const buffer = ethUtil.toBuffer(input);
          input = ethUtil.bufferToHex(buffer);
        }
        if (typeof input !== "string") {
          var msg = "eth-sig-util.normalize() requires hex string or integer input.";
          msg += " received " + typeof input + ": " + input;
          throw new Error(msg);
        }
        return ethUtil.addHexPrefix(input.toLowerCase());
      },
      personalSign: function(privateKey, msgParams) {
        var message = ethUtil.toBuffer(msgParams.data);
        var msgHash = ethUtil.hashPersonalMessage(message);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
        return serialized;
      },
      recoverPersonalSignature: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        const sender = ethUtil.publicToAddress(publicKey);
        const senderHex = ethUtil.bufferToHex(sender);
        return senderHex;
      },
      extractPublicKey: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        return "0x" + publicKey.toString("hex");
      },
      typedSignatureHash: function(typedData) {
        const hashBuffer = typedSignatureHash(typedData);
        return ethUtil.bufferToHex(hashBuffer);
      },
      signTypedData: function(privateKey, msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const sig = ethUtil.ecsign(msgHash, privateKey);
        return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
      },
      recoverTypedSignature: function(msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const publicKey = recoverPublicKey(msgHash, msgParams.sig);
        const sender = ethUtil.publicToAddress(publicKey);
        return ethUtil.bufferToHex(sender);
      }
    };
    function typedSignatureHash(typedData) {
      const error2 = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error2;
      const data = typedData.map(function(e5) {
        return e5.type === "bytes" ? ethUtil.toBuffer(e5.value) : e5.value;
      });
      const types = typedData.map(function(e5) {
        return e5.type;
      });
      const schema = typedData.map(function(e5) {
        if (!e5.name)
          throw error2;
        return e5.type + " " + e5.name;
      });
      return ethAbi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          ethAbi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          ethAbi.soliditySHA3(types, data)
        ]
      );
    }
    function recoverPublicKey(hash, sig) {
      const signature = ethUtil.toBuffer(sig);
      const sigParams = ethUtil.fromRpcSig(signature);
      return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
    }
    function getPublicKeyFor(msgParams) {
      const message = ethUtil.toBuffer(msgParams.data);
      const msgHash = ethUtil.hashPersonalMessage(message);
      return recoverPublicKey(msgHash, msgParams.sig);
    }
    function padWithZeroes(number, length) {
      var myString = "" + number;
      while (myString.length < length) {
        myString = "0" + myString;
      }
      return myString;
    }
  }
});

// node_modules/semaphore/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/semaphore/lib/semaphore.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    (function(global2) {
      "use strict";
      var nextTick3 = function(fn2) {
        setTimeout(fn2, 0);
      };
      if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
        nextTick3 = process.nextTick;
      }
      function semaphore(capacity) {
        var semaphore2 = {
          capacity: capacity || 1,
          current: 0,
          queue: [],
          firstHere: false,
          take: function() {
            if (semaphore2.firstHere === false) {
              semaphore2.current++;
              semaphore2.firstHere = true;
              var isFirst = 1;
            } else {
              var isFirst = 0;
            }
            var item = { n: 1 };
            if (typeof arguments[0] == "function") {
              item.task = arguments[0];
            } else {
              item.n = arguments[0];
            }
            if (arguments.length >= 2) {
              if (typeof arguments[1] == "function")
                item.task = arguments[1];
              else
                item.n = arguments[1];
            }
            var task = item.task;
            item.task = function() {
              task(semaphore2.leave);
            };
            if (semaphore2.current + item.n - isFirst > semaphore2.capacity) {
              if (isFirst === 1) {
                semaphore2.current--;
                semaphore2.firstHere = false;
              }
              return semaphore2.queue.push(item);
            }
            semaphore2.current += item.n - isFirst;
            item.task(semaphore2.leave);
            if (isFirst === 1)
              semaphore2.firstHere = false;
          },
          leave: function(n4) {
            n4 = n4 || 1;
            semaphore2.current -= n4;
            if (!semaphore2.queue.length) {
              if (semaphore2.current < 0) {
                throw new Error("leave called too many times.");
              }
              return;
            }
            var item = semaphore2.queue[0];
            if (item.n + semaphore2.current > semaphore2.capacity) {
              return;
            }
            semaphore2.queue.shift();
            semaphore2.current += item.n;
            nextTick3(item.task);
          },
          available: function(n4) {
            n4 = n4 || 1;
            return semaphore2.current + n4 <= semaphore2.capacity;
          }
        };
        return semaphore2;
      }
      ;
      if (typeof exports === "object") {
        module.exports = semaphore;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return semaphore;
        });
      } else {
        global2.semaphore = semaphore;
      }
    })(exports);
  }
});

// node_modules/web3-provider-engine/util/estimate-gas.js
var require_estimate_gas = __commonJS({
  "node_modules/web3-provider-engine/util/estimate-gas.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var createPayload = require_create_payload();
    module.exports = estimateGas;
    function estimateGas(provider2, txParams, cb) {
      provider2.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/subproviders/hooked-wallet.js
var require_hooked_wallet = __commonJS({
  "node_modules/web3-provider-engine/subproviders/hooked-wallet.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits2 = require_util().inherits;
    var ethUtil = require_dist3();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider();
    var estimateGas = require_estimate_gas();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider2;
    inherits2(HookedWalletSubprovider2, Subprovider);
    function HookedWalletSubprovider2(opts) {
      const self2 = this;
      self2.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self2.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self2.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self2.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self2.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self2.processTypedMessage = opts.processTypedMessage;
      self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
      self2.approveMessage = opts.approveMessage || self2.autoApprove;
      self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
      self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
      self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
      self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
      if (opts.signTransaction)
        self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self2.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self2.publishTransaction = opts.publishTransaction;
      self2.estimateGas = opts.estimateGas || self2.estimateGas;
      self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
    }
    HookedWalletSubprovider2.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      self2._parityRequests = {};
      self2._parityRequestCount = 0;
      let txParams, msgParams, extraParams;
      let message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            let result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processTransaction(txParams, cb)
          ], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([
            (cb) => self2.validateTransaction(txParams, cb),
            (cb) => self2.processSignTransaction(txParams, cb)
          ], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([
            (cb) => self2.validateMessage(msgParams, cb),
            (cb) => self2.processMessage(msgParams, cb)
          ], end);
          return;
        case "personal_sign":
          return function() {
            const first = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              let warning2 = `The eth_personalSign method requires params ordered `;
              warning2 += `[message, address]. This was previously handled incorrectly, `;
              warning2 += `and has been corrected automatically. `;
              warning2 += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning2);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validatePersonalMessage(msgParams, cb),
              (cb) => self2.processPersonalMessage(msgParams, cb)
            ], end);
          }();
        case "eth_decryptMessage":
          return function() {
            const first = payload.params[0];
            const second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              let warning2 = `The eth_decryptMessage method requires params ordered `;
              warning2 += `[message, address]. This was previously handled incorrectly, `;
              warning2 += `and has been corrected automatically. `;
              warning2 += `Please switch this param order for smooth behavior in the future.`;
              console.warn(warning2);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateDecryptMessage(msgParams, cb),
              (cb) => self2.processDecryptMessage(msgParams, cb)
            ], end);
          }();
        case "encryption_public_key":
          return function() {
            const address2 = payload.params[0];
            waterfall([
              (cb) => self2.validateEncryptionPublicKey(address2, cb),
              (cb) => self2.processEncryptionPublicKey(address2, cb)
            ], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            let signature = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature,
              data: message
            });
            self2.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            const first = payload.params[0];
            const second = payload.params[1];
            if (resemblesAddress(first)) {
              address = first;
              message = second;
            } else {
              message = first;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([
              (cb) => self2.validateTypedMessage(msgParams, cb),
              (cb) => self2.processTypedMessage(msgParams, cb)
            ], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self2.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self2.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            const requestId = payload.params[0];
            self2.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            const account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider2.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider2.prototype.processTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeAndSubmitTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processSignTransaction = function(txParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTransaction(txParams, cb2),
        (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
        (cb2) => self2.finalizeTx(txParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processPersonalMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approvePersonalMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signPersonalMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveDecryptMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("decryptMessage", didApprove, cb2),
        (cb2) => self2.decryptMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveEncryptionPublicKey(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("encryptionPublicKey", didApprove, cb2),
        (cb2) => self2.encryptionPublicKey(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.processTypedMessage = function(msgParams, cb) {
      const self2 = this;
      waterfall([
        (cb2) => self2.approveTypedMessage(msgParams, cb2),
        (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
        (cb2) => self2.signTypedMessage(msgParams, cb2)
      ], cb);
    };
    HookedWalletSubprovider2.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider2.prototype.checkApproval = function(type2, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type2 + " signature."));
    };
    HookedWalletSubprovider2.prototype.parityPostTransaction = function(txParams, cb) {
      const self2 = this;
      const count = self2._parityRequestCount;
      const reqId = `0x${count.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error2, res) {
        if (error2) {
          self2._parityRequests[reqId] = { error: error2 };
          return;
        }
        const txHash = res.result;
        self2._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityPostSign = function(address, message, cb) {
      const self2 = this;
      const count = self2._parityRequestCount;
      const reqId = `0x${count.toString(16)}`;
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error2, res) {
        if (error2) {
          self2._parityRequests[reqId] = { error: error2 };
          return;
        }
        const result = res.result;
        self2._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityCheckRequest = function(reqId, cb) {
      const self2 = this;
      const result = self2._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider2.prototype.recoverPersonalSignature = function(msgParams, cb) {
      let senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider2.prototype.validateTransaction = function(txParams, cb) {
      const self2 = this;
      if (txParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign transaction.`));
      self2.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign message.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validatePersonalMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign personal message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to sign personal message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateDecryptMessage = function(msgParams, cb) {
      const self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to decrypt message.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined message - message required to decrypt message.`));
      if (!isValidHex(msgParams.data))
        return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateEncryptionPublicKey = function(address, cb) {
      const self2 = this;
      self2.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error(`Undefined address - from address required to sign typed data.`));
      if (msgParams.data === void 0)
        return cb(new Error(`Undefined data - message required to sign typed data.`));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateSender = function(senderAddress, cb) {
      const self2 = this;
      if (!senderAddress)
        return cb(null, false);
      self2.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider2.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2),
          self2.publishTransaction.bind(self2)
        ], function(err, txHash) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider2.prototype.finalizeTx = function(txParams, cb) {
      const self2 = this;
      self2.nonceLock.take(function() {
        waterfall([
          self2.fillInTxExtras.bind(self2, txParams),
          self2.signTransaction.bind(self2)
        ], function(err, signedTx) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, { raw: signedTx, tx: txParams });
        });
      });
    };
    HookedWalletSubprovider2.prototype.publishTransaction = function(rawTx, cb) {
      const self2 = this;
      self2.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.estimateGas = function(txParams, cb) {
      const self2 = this;
      estimateGas(self2.engine, txParams, cb);
    };
    HookedWalletSubprovider2.prototype.getGasPrice = function(cb) {
      const self2 = this;
      self2.emitPayload({ method: "eth_gasPrice", params: [] }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.fillInTxExtras = function(txParams, cb) {
      const self2 = this;
      const address = txParams.from;
      const tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self2.getGasPrice.bind(self2);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self2.emitPayload.bind(self2, { method: "eth_getTransactionCount", params: [address, "pending"] });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        const result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string) {
      return string.toLowerCase();
    }
    function resemblesAddress(string) {
      const fixed = ethUtil.addHexPrefix(string);
      const isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string) {
      const fixed = ethUtil.addHexPrefix(string);
      const isValidAddress2 = ethUtil.isValidAddress(fixed);
      return !isValidAddress2 && isValidHex(string);
    }
    function isValidHex(data) {
      const isString2 = typeof data === "string";
      if (!isString2)
        return false;
      const isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      const nonPrefixed = data.slice(2);
      const isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/ethereum-common/params.json
var require_params = __commonJS({
  "node_modules/ethereum-common/params.json"(exports, module) {
    module.exports = {
      genesisGasLimit: {
        v: 5e3,
        d: "Gas limit of the Genesis block."
      },
      genesisDifficulty: {
        v: 17179869184,
        d: "Difficulty of the Genesis block."
      },
      genesisNonce: {
        v: "0x0000000000000042",
        d: "the geneis nonce"
      },
      genesisExtraData: {
        v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        d: "extra data "
      },
      genesisHash: {
        v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        d: "genesis hash"
      },
      genesisStateRoot: {
        v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
        d: "the genesis state root"
      },
      minGasLimit: {
        v: 5e3,
        d: "Minimum the gas limit may ever be."
      },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations."
      },
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be."
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations."
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
      },
      maximumExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis."
      },
      epochDuration: {
        v: 3e4,
        d: "Duration between proof-of-work epochs."
      },
      stackLimit: {
        v: 1024,
        d: "Maximum size of VM stack allowed."
      },
      callCreateDepth: {
        v: 1024,
        d: "Maximum depth of call/create stack."
      },
      tierStepGas: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them."
      },
      expGas: {
        v: 10,
        d: "Once per EXP instuction."
      },
      expByteGas: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction."
      },
      sha3Gas: {
        v: 30,
        d: "Once per SHA3 operation."
      },
      sha3WordGas: {
        v: 6,
        d: "Once per word of the SHA3 operation's data."
      },
      sloadGas: {
        v: 50,
        d: "Once per SLOAD operation."
      },
      sstoreSetGas: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero."
      },
      sstoreResetGas: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero."
      },
      sstoreRefundGas: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero."
      },
      jumpdestGas: {
        v: 1,
        d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
      },
      logGas: {
        v: 375,
        d: "Per LOG* operation."
      },
      logDataGas: {
        v: 8,
        d: "Per byte in a LOG* operation's data."
      },
      logTopicGas: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
      },
      createGas: {
        v: 32e3,
        d: "Once per CREATE operation & contract-creation transaction."
      },
      callGas: {
        v: 40,
        d: "Once per CALL operation & message call transaction."
      },
      callStipend: {
        v: 2300,
        d: "Free gas given at beginning of call."
      },
      callValueTransferGas: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero."
      },
      callNewAccountGas: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior."
      },
      suicideRefundGas: {
        v: 24e3,
        d: "Refunded following a suicide operation."
      },
      memoryGas: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation."
      },
      createDataGas: {
        v: 200,
        d: ""
      },
      txGas: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions."
      },
      txCreation: {
        v: 32e3,
        d: "the cost of creating a contract via tx"
      },
      txDataZeroGas: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
      },
      txDataNonZeroGas: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
      },
      copyGas: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
      },
      ecrecoverGas: {
        v: 3e3,
        d: ""
      },
      sha256Gas: {
        v: 60,
        d: ""
      },
      sha256WordGas: {
        v: 12,
        d: ""
      },
      ripemd160Gas: {
        v: 600,
        d: ""
      },
      ripemd160WordGas: {
        v: 120,
        d: ""
      },
      identityGas: {
        v: 15,
        d: ""
      },
      identityWordGas: {
        v: 3,
        d: ""
      },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block"
      },
      ommerReward: {
        v: "625000000000000000",
        d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
      },
      niblingReward: {
        v: "156250000000000000",
        d: "the amount a miner gets for inculding a uncle"
      },
      homeSteadForkNumber: {
        v: 115e4,
        d: "the block that the Homestead fork started at"
      },
      homesteadRepriceForkNumber: {
        v: 2463e3,
        d: "the block that the Homestead Reprice (EIP150) fork started at"
      },
      timebombPeriod: {
        v: 1e5,
        d: "Exponential difficulty timebomb period"
      },
      freeBlockPeriod: {
        v: 2
      }
    };
  }
});

// node_modules/ethereumjs-tx/es5/index.js
var require_es5 = __commonJS({
  "node_modules/ethereumjs-tx/es5/index.js"(exports, module) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ethUtil = require_dist3();
    var fees = require_params();
    var BN6 = ethUtil.BN;
    var N_DIV_2 = new BN6("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var Transaction = function() {
      function Transaction2(data) {
        _classCallCheck(this, Transaction2);
        data = data || {};
        var fields = [{
          name: "nonce",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "gasPrice",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "gasLimit",
          alias: "gas",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "to",
          allowZero: true,
          length: 20,
          default: new Buffer2([])
        }, {
          name: "value",
          length: 32,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "data",
          alias: "input",
          allowZero: true,
          default: new Buffer2([])
        }, {
          name: "v",
          allowZero: true,
          default: new Buffer2([28])
        }, {
          name: "r",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer2([])
        }, {
          name: "s",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer2([])
        }];
        ethUtil.defineProperties(this, fields, data);
        Object.defineProperty(this, "from", {
          enumerable: true,
          configurable: true,
          get: this.getSenderAddress.bind(this)
        });
        var sigV = ethUtil.bufferToInt(this.v);
        var chainId = Math.floor((sigV - 35) / 2);
        if (chainId < 0)
          chainId = 0;
        this._chainId = chainId || data.chainId || 0;
        this._homestead = true;
      }
      Transaction2.prototype.toCreationAddress = function toCreationAddress() {
        return this.to.toString("hex") === "";
      };
      Transaction2.prototype.hash = function hash(includeSignature) {
        if (includeSignature === void 0)
          includeSignature = true;
        var items = void 0;
        if (includeSignature) {
          items = this.raw;
        } else {
          if (this._chainId > 0) {
            var raw = this.raw.slice();
            this.v = this._chainId;
            this.r = 0;
            this.s = 0;
            items = this.raw;
            this.raw = raw;
          } else {
            items = this.raw.slice(0, 6);
          }
        }
        return ethUtil.rlphash(items);
      };
      Transaction2.prototype.getChainId = function getChainId() {
        return this._chainId;
      };
      Transaction2.prototype.getSenderAddress = function getSenderAddress() {
        if (this._from) {
          return this._from;
        }
        var pubkey = this.getSenderPublicKey();
        this._from = ethUtil.publicToAddress(pubkey);
        return this._from;
      };
      Transaction2.prototype.getSenderPublicKey = function getSenderPublicKey() {
        if (!this._senderPubKey || !this._senderPubKey.length) {
          if (!this.verifySignature())
            throw new Error("Invalid Signature");
        }
        return this._senderPubKey;
      };
      Transaction2.prototype.verifySignature = function verifySignature() {
        var msgHash = this.hash(false);
        if (this._homestead && new BN6(this.s).cmp(N_DIV_2) === 1) {
          return false;
        }
        try {
          var v5 = ethUtil.bufferToInt(this.v);
          if (this._chainId > 0) {
            v5 -= this._chainId * 2 + 8;
          }
          this._senderPubKey = ethUtil.ecrecover(msgHash, v5, this.r, this.s);
        } catch (e5) {
          return false;
        }
        return !!this._senderPubKey;
      };
      Transaction2.prototype.sign = function sign(privateKey) {
        var msgHash = this.hash(false);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        if (this._chainId > 0) {
          sig.v += this._chainId * 2 + 8;
        }
        Object.assign(this, sig);
      };
      Transaction2.prototype.getDataFee = function getDataFee() {
        var data = this.raw[5];
        var cost = new BN6(0);
        for (var i4 = 0; i4 < data.length; i4++) {
          data[i4] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
        }
        return cost;
      };
      Transaction2.prototype.getBaseFee = function getBaseFee() {
        var fee = this.getDataFee().iaddn(fees.txGas.v);
        if (this._homestead && this.toCreationAddress()) {
          fee.iaddn(fees.txCreation.v);
        }
        return fee;
      };
      Transaction2.prototype.getUpfrontCost = function getUpfrontCost() {
        return new BN6(this.gasLimit).imul(new BN6(this.gasPrice)).iadd(new BN6(this.value));
      };
      Transaction2.prototype.validate = function validate(stringError) {
        var errors2 = [];
        if (!this.verifySignature()) {
          errors2.push("Invalid Signature");
        }
        if (this.getBaseFee().cmp(new BN6(this.gasLimit)) > 0) {
          errors2.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
        }
        if (stringError === void 0 || stringError === false) {
          return errors2.length === 0;
        } else {
          return errors2.join(" ");
        }
      };
      return Transaction2;
    }();
    module.exports = Transaction;
  }
});

// node_modules/web3-provider-engine/subproviders/nonce-tracker.js
var require_nonce_tracker = __commonJS({
  "node_modules/web3-provider-engine/subproviders/nonce-tracker.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var inherits2 = require_util().inherits;
    var Transaction = require_es5();
    var ethUtil = require_dist3();
    var Subprovider = require_subprovider();
    var blockTagForPayload = require_rpc_cache_utils().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits2(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      const self2 = this;
      self2.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      const self2 = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self2.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self2.nonceCache[address] === void 0) {
                  self2.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer2.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction(Buffer2.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self2.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self2.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var SafeEventEmitter = require_safe_event_emitter2().default;
    var createScaffoldMiddleware = require_scaffold();
    var { createAsyncMiddleware } = require_dist5();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider: provider2 }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider: provider2 });
      let isDestroyed = false;
      const events2 = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events: events2, middleware };
      async function subscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider: provider2, fromBlock, toBlock });
              const results2 = rawBlocks.map(normalizeBlock);
              results2.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter }) {
          filter.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id = req.params[0];
        const subscription = subscriptions[id];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events2.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events2.removeAllListeners();
        for (const id in subscriptions) {
          subscriptions[id].destroy();
          delete subscriptions[id];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/web3-provider-engine/subproviders/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/web3-provider-engine/subproviders/subscriptions.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider2 = class extends ProviderSubprovider {
      constructor() {
        super(({ blockTracker, provider: provider2, engine }) => {
          const { events: events2, middleware } = createSubscriptionManager({ blockTracker, provider: provider2 });
          events2.on("notification", (data) => engine.emit("data", null, data));
          return middleware;
        });
      }
    };
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/posthog-js-lite/dist/package.json
var require_package2 = __commonJS({
  "node_modules/posthog-js-lite/dist/package.json"(exports, module) {
    module.exports = {
      name: "posthog-js-lite",
      version: "0.0.5",
      description: "Reimplementation of posthog-js to be as light and modular as possible.",
      main: "dist/src/index.js",
      scripts: {
        build: "tsc -p .",
        test: "jest",
        prepublish: "yarn test && yarn build"
      },
      author: "PostHog",
      license: "MIT",
      devDependencies: {
        "@babel/core": "^7.10.4",
        "@babel/preset-env": "^7.10.4",
        "@babel/preset-typescript": "^7.10.4",
        "@types/jest": "^26.0.3",
        husky: ">=4",
        "lint-staged": ">=10",
        "@types/node": "^14.0.19",
        prettier: "^2.0.5",
        eslint: "^7.4.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-prettier": "^3.1.4",
        "babel-jest": "^26.1.0",
        jest: "^26.1.0",
        "ts-jest": "^26.1.1",
        "ts-node": "^8.10.2",
        typescript: "^3.9.6"
      },
      jest: {
        testPathIgnorePatterns: [
          "<rootDir>/dist/"
        ]
      },
      husky: {
        hooks: {
          "pre-commit": "lint-staged"
        }
      },
      "lint-staged": {
        "*.{ts,js,css,scss}": "prettier --write"
      }
    };
  }
});

// node_modules/posthog-js-lite/dist/src/utils/utils.js
var require_utils7 = __commonJS({
  "node_modules/posthog-js-lite/dist/src/utils/utils.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.currentISOTime = exports.currentTimestamp = exports.generateUUID = void 0;
    function generateUUID(globalThis2) {
      var d4 = new Date().getTime();
      var d22 = globalThis2 && globalThis2.performance && globalThis2.performance.now && globalThis2.performance.now() * 1e3 || 0;
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c4) {
        var r5 = Math.random() * 16;
        if (d4 > 0) {
          r5 = (d4 + r5) % 16 | 0;
          d4 = Math.floor(d4 / 16);
        } else {
          r5 = (d22 + r5) % 16 | 0;
          d22 = Math.floor(d22 / 16);
        }
        return (c4 === "x" ? r5 : r5 & 3 | 8).toString(16);
      });
    }
    exports.generateUUID = generateUUID;
    function currentTimestamp() {
      return new Date().getTime();
    }
    exports.currentTimestamp = currentTimestamp;
    function currentISOTime() {
      return new Date().toISOString();
    }
    exports.currentISOTime = currentISOTime;
  }
});

// node_modules/posthog-js-lite/dist/src/utils/context.js
var require_context = __commonJS({
  "node_modules/posthog-js-lite/dist/src/utils/context.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContext = void 0;
    var package_json_1 = require_package2();
    var utils_1 = require_utils7();
    function getContext2(window2) {
      const context2 = {};
      if (window2.navigator) {
        const userAgent = window2.navigator.userAgent;
        Object.assign(context2, {
          $os: os2(window2),
          $browser: browser3(userAgent, window2.navigator.vendor, !!window2.opera),
          $referrer: window2.document.referrer,
          $referring_domain: referringDomain(window2.document.referrer),
          $device: device(userAgent),
          $current_url: window2.location.href,
          $host: window2.location.host,
          $pathname: window2.location.pathname,
          $browser_version: browserVersion(userAgent, window2.navigator.vendor, !!window2.opera),
          $screen_height: window2.screen.height,
          $screen_width: window2.screen.width,
          $screen_dpr: window2.devicePixelRatio
        });
      }
      Object.assign(context2, {
        $lib: "js",
        $lib_version: package_json_1.version,
        $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
        $time: utils_1.currentTimestamp() / 1e3
      });
      return context2;
    }
    exports.getContext = getContext2;
    function includes3(haystack, needle) {
      return haystack.indexOf(needle) >= 0;
    }
    function browser3(userAgent, vendor, opera) {
      vendor = vendor || "";
      if (opera || includes3(userAgent, " OPR/")) {
        if (includes3(userAgent, "Mini")) {
          return "Opera Mini";
        }
        return "Opera";
      } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {
        return "BlackBerry";
      } else if (includes3(userAgent, "IEMobile") || includes3(userAgent, "WPDesktop")) {
        return "Internet Explorer Mobile";
      } else if (includes3(userAgent, "SamsungBrowser/")) {
        return "Samsung Internet";
      } else if (includes3(userAgent, "Edge") || includes3(userAgent, "Edg/")) {
        return "Microsoft Edge";
      } else if (includes3(userAgent, "FBIOS")) {
        return "Facebook Mobile";
      } else if (includes3(userAgent, "Chrome")) {
        return "Chrome";
      } else if (includes3(userAgent, "CriOS")) {
        return "Chrome iOS";
      } else if (includes3(userAgent, "UCWEB") || includes3(userAgent, "UCBrowser")) {
        return "UC Browser";
      } else if (includes3(userAgent, "FxiOS")) {
        return "Firefox iOS";
      } else if (includes3(vendor, "Apple")) {
        if (includes3(userAgent, "Mobile")) {
          return "Mobile Safari";
        }
        return "Safari";
      } else if (includes3(userAgent, "Android")) {
        return "Android Mobile";
      } else if (includes3(userAgent, "Konqueror")) {
        return "Konqueror";
      } else if (includes3(userAgent, "Firefox")) {
        return "Firefox";
      } else if (includes3(userAgent, "MSIE") || includes3(userAgent, "Trident/")) {
        return "Internet Explorer";
      } else if (includes3(userAgent, "Gecko")) {
        return "Mozilla";
      } else {
        return "";
      }
    }
    function browserVersion(userAgent, vendor, opera) {
      const regexList = {
        "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
        "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
        Chrome: /Chrome\/(\d+(\.\d+)?)/,
        "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
        "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
        Safari: /Version\/(\d+(\.\d+)?)/,
        "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
        Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
        Firefox: /Firefox\/(\d+(\.\d+)?)/,
        "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
        Konqueror: /Konqueror:(\d+(\.\d+)?)/,
        BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
        "Android Mobile": /android\s(\d+(\.\d+)?)/,
        "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
        "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
        Mozilla: /rv:(\d+(\.\d+)?)/
      };
      const browserString = browser3(userAgent, vendor, opera);
      const regex2 = regexList[browserString] || void 0;
      if (regex2 === void 0) {
        return null;
      }
      var matches = userAgent.match(regex2);
      if (!matches) {
        return null;
      }
      return parseFloat(matches[matches.length - 2]);
    }
    function os2(window2) {
      var a4 = window2.navigator.userAgent;
      if (/Windows/i.test(a4)) {
        if (/Phone/.test(a4) || /WPDesktop/.test(a4)) {
          return "Windows Phone";
        }
        return "Windows";
      } else if (/(iPhone|iPad|iPod)/.test(a4)) {
        return "iOS";
      } else if (/Android/.test(a4)) {
        return "Android";
      } else if (/(BlackBerry|PlayBook|BB10)/i.test(a4)) {
        return "BlackBerry";
      } else if (/Mac/i.test(a4)) {
        return "Mac OS X";
      } else if (/Linux/.test(a4)) {
        return "Linux";
      } else if (/CrOS/.test(a4)) {
        return "Chrome OS";
      } else {
        return "";
      }
    }
    function device(userAgent) {
      if (/Windows Phone/i.test(userAgent) || /WPDesktop/.test(userAgent)) {
        return "Windows Phone";
      } else if (/iPad/.test(userAgent)) {
        return "iPad";
      } else if (/iPod/.test(userAgent)) {
        return "iPod Touch";
      } else if (/iPhone/.test(userAgent)) {
        return "iPhone";
      } else if (/(BlackBerry|PlayBook|BB10)/i.test(userAgent)) {
        return "BlackBerry";
      } else if (/Android/.test(userAgent)) {
        return "Android";
      } else {
        return "";
      }
    }
    function referringDomain(referrer) {
      var split = referrer.split("/");
      if (split.length >= 3) {
        return split[2];
      }
      return "";
    }
  }
});

// node_modules/posthog-js-lite/dist/src/utils/lz-string.js
var require_lz_string = __commonJS({
  "node_modules/posthog-js-lite/dist/src/utils/lz-string.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LZString = void 0;
    var f5 = String.fromCharCode;
    var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i4 = 0; i4 < alphabet.length; i4++) {
          baseReverseDic[alphabet][alphabet.charAt(i4)] = i4;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    exports.LZString = {
      compressToBase64: function(input) {
        if (input == null)
          return "";
        var res = exports.LZString._compress(input, 6, function(a4) {
          return keyStrBase64.charAt(a4);
        });
        switch (res.length % 4) {
          default:
          case 0:
            return res;
          case 1:
            return res + "===";
          case 2:
            return res + "==";
          case 3:
            return res + "=";
        }
      },
      decompressFromBase64: function(input) {
        if (input == null)
          return "";
        if (input == "")
          return null;
        return exports.LZString._decompress(input.length, 32, function(index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compressToUTF16: function(input) {
        if (input == null)
          return "";
        return exports.LZString._compress(input, 15, function(a4) {
          return f5(a4 + 32);
        }) + " ";
      },
      decompressFromUTF16: function(compressed) {
        if (compressed == null)
          return "";
        if (compressed == "")
          return null;
        return exports.LZString._decompress(compressed.length, 16384, function(index) {
          return compressed.charCodeAt(index) - 32;
        });
      },
      compressToUint8Array: function(uncompressed) {
        var compressed = exports.LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);
        for (var i4 = 0, TotalLen = compressed.length; i4 < TotalLen; i4++) {
          var current_value = compressed.charCodeAt(i4);
          buf[i4 * 2] = current_value >>> 8;
          buf[i4 * 2 + 1] = current_value % 256;
        }
        return buf;
      },
      decompressFromUint8Array: function(compressed) {
        if (compressed === null || compressed === void 0) {
          return exports.LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);
          for (var i4 = 0, TotalLen = buf.length; i4 < TotalLen; i4++) {
            buf[i4] = compressed[i4 * 2] * 256 + compressed[i4 * 2 + 1];
          }
          var result = [];
          buf.forEach(function(c4) {
            result.push(f5(c4));
          });
          return exports.LZString.decompress(result.join(""));
        }
      },
      compressToEncodedURIComponent: function(input) {
        if (input == null)
          return "";
        return exports.LZString._compress(input, 6, function(a4) {
          return keyStrUriSafe.charAt(a4);
        });
      },
      decompressFromEncodedURIComponent: function(input) {
        if (input == null)
          return "";
        if (input == "")
          return null;
        input = input.replace(/ /g, "+");
        return exports.LZString._decompress(input.length, 32, function(index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },
      compress: function(uncompressed) {
        return exports.LZString._compress(uncompressed, 16, function(a4) {
          return f5(a4);
        });
      },
      _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null)
          return "";
        var i4, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i4 = 0; i4 < context_numBits; i4++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i4 = 0; i4 < 8; i4++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i4 = 0; i4 < context_numBits; i4++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i4 = 0; i4 < 16; i4++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i4 = 0; i4 < context_numBits; i4++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i4 = 0; i4 < context_numBits; i4++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i4 = 0; i4 < 8; i4++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i4 = 0; i4 < context_numBits; i4++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i4 = 0; i4 < 16; i4++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i4 = 0; i4 < context_numBits; i4++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        value = 2;
        for (i4 = 0; i4 < context_numBits; i4++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else
            context_data_position++;
        }
        return context_data.join("");
      },
      decompress: function(compressed) {
        if (compressed == null)
          return "";
        if (compressed == "")
          return null;
        return exports.LZString._decompress(compressed.length, 32768, function(index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function(length, resetValue, getNextValue) {
        var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i4, w6, bits, resb, maxpower, power, c4, data = { val: getNextValue(0), position: resetValue, index: 1 };
        for (i4 = 0; i4 < 3; i4 += 1) {
          dictionary[i4] = i4;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (next = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c4 = f5(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c4 = f5(bits);
            break;
          case 2:
            return "";
        }
        dictionary[3] = c4;
        w6 = c4;
        result.push(c4);
        while (true) {
          if (data.index > length) {
            return "";
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c4 = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f5(bits);
              c4 = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f5(bits);
              c4 = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join("");
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c4]) {
            entry = dictionary[c4];
          } else {
            if (c4 === dictSize) {
              entry = w6 + w6.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          dictionary[dictSize++] = w6 + entry.charAt(0);
          enlargeIn--;
          w6 = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
  }
});

// node_modules/posthog-js-lite/dist/src/index.js
var require_src3 = __commonJS({
  "node_modules/posthog-js-lite/dist/src/index.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
      function adopt(value) {
        return value instanceof P4 ? value : new P4(function(resolve) {
          resolve(value);
        });
      }
      return new (P4 || (P4 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e5) {
            reject(e5);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e5) {
            reject(e5);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInternalPostHogInstance = void 0;
    var package_json_1 = require_package2();
    var utils_1 = require_utils7();
    var context_1 = require_context();
    var lz_string_js_1 = require_lz_string();
    var defaultOptions = {
      apiHost: "https://app.posthog.com",
      maxQueueLength: 1,
      optedIn: true
    };
    function createInternalPostHogInstance(apiKey, options, globalThis2) {
      const session = {};
      const anonymousId = utils_1.generateUUID(globalThis2);
      let postHogInstance = {
        options: Object.assign(Object.assign(Object.assign({}, defaultOptions), options), { apiKey }),
        session: Object.assign({ anonymousId, distinctId: anonymousId }, session),
        getDistinctId() {
          return postHogInstance.session.distinctId;
        },
        getContextProperties() {
          return {
            $lib: "posthog-js-lite",
            $lib_version: package_json_1.version
          };
        },
        optedIn() {
          return postHogInstance.options.optedIn;
        },
        optIn() {
          postHogInstance.options.optedIn = true;
          postHogInstance.flush();
        },
        optOut() {
          postHogInstance.options.optedIn = false;
        },
        capture(event, properties = {}) {
          postHogInstance.enqueue({
            event,
            distinct_id: postHogInstance.getDistinctId(),
            timestamp: utils_1.currentISOTime(),
            properties: Object.assign(Object.assign({}, context_1.getContext(globalThis2)), properties)
          });
        },
        identify(distinctId, userProperties = {}) {
          postHogInstance.enqueue({
            event: "$identify",
            distinct_id: distinctId || postHogInstance.session.anonymousId,
            timestamp: utils_1.currentISOTime(),
            $set: Object.assign({}, userProperties),
            properties: Object.assign(Object.assign({}, context_1.getContext(globalThis2)), { $anon_distinct_id: postHogInstance.session.anonymousId })
          });
          if (distinctId) {
            postHogInstance.session.distinctId = distinctId;
          }
        },
        queue: [],
        enqueue(apiRequest) {
          postHogInstance.queue.push(apiRequest);
          if (postHogInstance.optedIn() && postHogInstance.queue.length >= postHogInstance.options.maxQueueLength) {
            postHogInstance.flush();
          }
        },
        flush() {
          let queue3 = postHogInstance.queue;
          postHogInstance.queue = [];
          postHogInstance.makeRequest(queue3);
        },
        makeRequest: function(events2) {
          return __awaiter(this, void 0, void 0, function* () {
            const requestData = {
              api_key: postHogInstance.options.apiKey,
              batch: events2,
              sent_at: utils_1.currentISOTime()
            };
            const url = `${postHogInstance.options.apiHost}/e/?ip=1&_=${utils_1.currentTimestamp()}&v=${package_json_1.version}`;
            const payload = JSON.stringify(requestData);
            const compressedPayload = lz_string_js_1.LZString.compressToBase64(payload);
            const fetchOptions = {
              method: "POST",
              mode: "no-cors",
              credentials: "omit",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: `data=${encodeURIComponent(compressedPayload)}&compression=lz64`
            };
            try {
              const rawResponse = yield postHogInstance.options.fetch(url, fetchOptions);
              const body = yield rawResponse.text();
            } catch (error2) {
              throw error2;
            }
          });
        }
      };
      return postHogInstance;
    }
    exports.createInternalPostHogInstance = createInternalPostHogInstance;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        var React8 = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format3) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format3, args);
            }
          }
        }
        function error2(format3) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format3, args);
            }
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        function beginWriting(destination) {
        }
        function writeChunk(destination, chunk) {
          writeChunkAndReturn(destination, chunk);
        }
        function writeChunkAndReturn(destination, chunk) {
          return destination.push(chunk);
        }
        function completeWriting(destination) {
        }
        function close(destination) {
          destination.push(null);
        }
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return content;
        }
        function closeWithError(destination, error3) {
          destination.destroy(error3);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            name,
            null,
            false,
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            name,
            null,
            false,
            false
          );
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            name,
            null,
            false,
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            false,
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            true,
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key2) {
          return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props2) {
          {
            if (!(hasReadOnlyValue[props2.type] || props2.onChange || props2.onInput || props2.readOnly || props2.disabled || props2.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props2.onChange || props2.readOnly || props2.disabled || props2.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props2) {
          if (tagName.indexOf("-") === -1) {
            return typeof props2.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty3.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props2) {
          {
            var invalidProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty(type2, key2);
              if (!isValid) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props2) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnInvalidARIAProps(type2, props2);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props2) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props2 != null && props2.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props2.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty3.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props2, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty$1(type2, key2, props2[key2], eventRegistry);
              if (!isValid) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props2, eventRegistry) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnUnknownProperties(type2, props2, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_5, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name,
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#x27;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape2;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a4) {
          return isArrayImpl(a4);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s4, suffix) {
          return "" + prefix2 + (s4 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i4 = 0; i4 < bootstrapScripts.length; i4++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i4])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i2 = 0; _i2 < bootstrapModules.length; _i2++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i2])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function getChildFormatContext(parentContext, type2, props2) {
          switch (type2) {
            case "select":
              return createFormatContext(HTML_MODE, props2.value != null ? props2.value : props2.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty3.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty3.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props2, propName) {
          {
            var value = props2[propName];
            if (value != null) {
              var array = isArray4(value);
              if (props2.multiple && !array) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props2.multiple && array) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props2, responseState) {
          {
            checkControlledValueProps("select", props2);
            checkSelectProp(props2, "value");
            checkSelectProp(props2, "defaultValue");
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React8.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props2, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray4(selectedValue)) {
              for (var i4 = 0; i4 < selectedValue.length; i4++) {
                {
                  checkAttributeStringCoercion(selectedValue[i4], "value");
                }
                var v5 = "" + selectedValue[i4];
                if (v5 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props2, responseState) {
          {
            checkControlledValueProps("input", props2);
            if (props2.checked !== void 0 && props2.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props2.type);
              didWarnDefaultChecked = true;
            }
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props2.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked3 = null;
          var defaultChecked = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked3 = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked3 !== null) {
            pushAttribute(target, responseState, "checked", checked3);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props2, responseState) {
          {
            checkControlledValueProps("textarea", props2);
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error2("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray4(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props2, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props2, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error2("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error2("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error2("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type2, props2, responseState, formatContext) {
          {
            validateProperties(type2, props2);
            validateProperties$1(type2, props2);
            validateProperties$2(type2, props2, null);
            if (!props2.suppressContentEditableWarning && props2.contentEditable && props2.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type2.indexOf("-") === -1 && typeof props2.is !== "string" && type2.toLowerCase() !== type2) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2);
              }
            }
          }
          switch (type2) {
            case "select":
              return pushStartSelect(target, props2, responseState);
            case "option":
              return pushStartOption(target, props2, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props2, responseState);
            case "input":
              return pushInput(target, props2, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props2, responseState);
            case "title":
              return pushStartTitle(target, props2, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props2, type2, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props2, type2, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props2, type2, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props2, type2, responseState);
            }
            default: {
              if (type2.indexOf("-") === -1 && typeof props2.is !== "string") {
                return pushStartGenericElement(target, props2, type2, responseState);
              } else {
                return pushStartCustomElement(target, props2, type2, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type2, props2) {
          switch (type2) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type2), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i4 = 0;
          for (; i4 < bootstrapChunks.length - 1; i4++) {
            writeChunk(destination, bootstrapChunks[i4]);
          }
          if (i4 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i4]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        function createResponseState$1(generateStaticMarkup, identifierPrefix) {
          var responseState = createResponseState(identifierPrefix, void 0);
          return {
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            generateStaticMarkup
          };
        }
        function createRootFormatContext() {
          return {
            insertionMode: HTML_MODE,
            selectedValue: null
          };
        }
        function pushTextInstance$1(target, text, responseState, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text)));
            return false;
          } else {
            return pushTextInstance(target, text, responseState, textEmbedded);
          }
        }
        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            return;
          } else {
            return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
          }
        }
        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartCompletedSuspenseBoundary(destination);
        }
        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
        }
        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndCompletedSuspenseBoundary(destination);
        }
        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndClientRenderedSuspenseBoundary(destination);
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type2;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type2;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x5) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props2, {
                  value: prevLog
                }),
                info: assign({}, props2, {
                  value: prevInfo
                }),
                warn: assign({}, props2, {
                  value: prevWarn
                }),
                error: assign({}, props2, {
                  value: prevError
                }),
                group: assign({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x5) {
                var match = x5.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x5) {
                  control = x5;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x5) {
                  control = x5;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x5) {
                control = x5;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                c4--;
              }
              for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                if (sampleLines[s4] !== controlLines[c4]) {
                  if (s4 !== 1 || c4 !== 1) {
                    do {
                      s4--;
                      c4--;
                      if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x5) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type2, unmaskedContext) {
          {
            var contextTypes = type2.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromType(type2) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            return context2;
          }
        }
        function processChildContext(instance, type2, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type2) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type2) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue2 = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue2 = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next)
            ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context2, nextValue) {
          var prevValue;
          {
            prevValue = context2._currentValue2;
            context2._currentValue2 = nextValue;
            {
              if (context2._currentRenderer2 !== void 0 && context2._currentRenderer2 !== null && context2._currentRenderer2 !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer2 = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context2,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context2) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context2) {
              error2("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var _value = prevSnapshot.parentValue;
            if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue2 = _value;
            }
            {
              if (context2._currentRenderer2 !== void 0 && context2._currentRenderer2 !== null && context2._currentRenderer2 !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer2 = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context2) {
          var value = context2._currentValue2;
          return value;
        }
        function get3(key2) {
          return key2._reactInternals;
        }
        function set(key2, value) {
          key2._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type2, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type2) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error2("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get3(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get3(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get3(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props2, maskedLegacyContext) {
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            context2 = maskedLegacyContext;
          }
          var instance = new ctor(props2, context2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray4(_state))) {
              error2("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type2) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props2, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i4 = oldReplace ? 1 : 0; i4 < oldQueue.length; i4++) {
                var partial = oldQueue[i4];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props2, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context2) {
          var overflow = context2.overflow;
          var idWithLeadingBit = context2.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log2 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x5) {
          var asUint = x5 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log2(asUint) / LN2 | 0) | 0;
        }
        function is(x5, y5) {
          return x5 === y5 && (x5 !== 0 || 1 / x5 === 1 / y5) || x5 !== x5 && y5 !== y5;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props2, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props2, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context2) {
          {
            if (isInHookUserCodeInDev) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context2);
        }
        function useContext2(context2) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context2);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            initialState
          );
        }
        function useReducer(reducer, initialArg, init3) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue3 = workInProgressHook.queue;
            var dispatch = queue3.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue3);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init3 !== void 0 ? init3(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo2(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef2(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error2("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue3, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue3, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo2(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop3() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext2,
          useMemo: useMemo2,
          useReducer,
          useRef: useRef2,
          useState,
          useInsertionEffect: noop3,
          useLayoutEffect,
          useCallback,
          useImperativeHandle: noop3,
          useEffect: noop3,
          useDebugValue: noop3,
          useDeferredValue,
          useTransition,
          useId,
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x5) {
            return "\nError generating stack: " + x5.message + "\n" + x5.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error3) {
          console["error"](error3);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request3 = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError2 === void 0 ? defaultErrorHandler : onError2,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request3,
            0,
            null,
            rootFormatContext,
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request3, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request3;
        }
        function pingTask(request3, task) {
          var pingedTasks = request3.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request3);
            });
          }
        }
        function createSuspenseBoundary(request3, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request3, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context2, treeContext) {
          request3.allPendingTasks++;
          if (blockedBoundary === null) {
            request3.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request3, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context: context2,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request3, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function pushClassComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error2("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error3) {
          {
            var errorMessage;
            if (typeof error3 === "string") {
              errorMessage = error3;
            } else if (error3 && typeof error3.message === "string") {
              errorMessage = error3.message;
            } else {
              errorMessage = String(error3);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request3, error3) {
          var errorDigest = request3.onError(error3);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request3, error3) {
          var onShellError = request3.onShellError;
          onShellError(error3);
          var onFatalError = request3.onFatalError;
          onFatalError(error3);
          if (request3.destination !== null) {
            request3.status = CLOSED;
            closeWithError(request3.destination, error3);
          } else {
            request3.status = CLOSING;
            request3.fatalError = error3;
          }
        }
        function renderSuspenseBoundary(request3, task, props2) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props2.fallback;
          var content = props2.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request3, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request3,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request3,
            0,
            null,
            parentSegment.formatContext,
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request3, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request3.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error3) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request3, error3);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error3);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request3, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request3.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request3, task, type2, props2) {
          pushBuiltInComponentStackInDEV(task, type2);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type2, props2, request3.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type2, props2);
          renderNode(request3, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type2);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request3, task, Component, props2, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props2, secondArg);
          return finishHooks(Component, props2, result, secondArg);
        }
        function finishClassComponent(request3, task, instance, Component, props2) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props2) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request3, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request3, task, nextChildren);
        }
        function renderClassComponent(request3, task, Component, props2) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props2, maskedContext);
          mountClassInstance(instance, Component, props2, maskedContext);
          finishClassComponent(request3, task, instance, Component, props2);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request3, task, Component, props2) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request3, task, Component, props2, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props2, legacyContext);
            finishClassComponent(request3, task, value, Component, props2);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request3, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request3, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props2 = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props2[propName] === void 0) {
                props2[propName] = defaultProps[propName];
              }
            }
            return props2;
          }
          return baseProps;
        }
        function renderForwardRef(request3, task, type2, props2, ref) {
          pushFunctionComponentStackInDEV(task, type2.render);
          var children = renderWithHooks(request3, task, type2.render, props2, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request3, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request3, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request3, task, type2, props2, ref) {
          var innerType = type2.type;
          var resolvedProps = resolveDefaultProps(innerType, props2);
          renderElement(request3, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request3, task, context2, props2) {
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var render = props2.children;
          {
            if (typeof render !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context2);
          var newChildren = render(newValue);
          renderNodeDestructive(request3, task, newChildren);
        }
        function renderContextProvider(request3, task, type2, props2) {
          var context2 = type2._context;
          var value = props2.value;
          var children = props2.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context2, value);
          renderNodeDestructive(request3, task, children);
          task.context = popProvider(context2);
          {
            if (prevSnapshot !== task.context) {
              error2("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request3, task, lazyComponent, props2, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init3 = lazyComponent._init;
          var Component = init3(payload);
          var resolvedProps = resolveDefaultProps(Component, props2);
          renderElement(request3, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request3, task, type2, props2, ref) {
          if (typeof type2 === "function") {
            if (shouldConstruct$1(type2)) {
              renderClassComponent(request3, task, type2, props2);
              return;
            } else {
              renderIndeterminateComponent(request3, task, type2, props2);
              return;
            }
          }
          if (typeof type2 === "string") {
            renderHostElement(request3, task, type2, props2);
            return;
          }
          switch (type2) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request3, task, props2.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request3, task, props2.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request3, task, props2);
              }
              return;
            }
          }
          if (typeof type2 === "object" && type2 !== null) {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request3, task, type2, props2, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request3, task, type2, props2, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request3, task, type2, props2);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request3, task, type2, props2);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request3, task, type2, props2);
                return;
              }
            }
          }
          var info = "";
          {
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request3, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request3, task, node);
            } catch (x5) {
              if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x5;
            }
          }
        }
        function renderNodeDestructiveImpl(request3, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type2 = element.type;
                var props2 = element.props;
                var ref = element.ref;
                renderElement(request3, task, type2, props2, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init3 = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init3(payload);
                  } catch (x5) {
                    if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x5;
                  }
                }
                renderNodeDestructive(request3, task, resolvedNode);
                return;
              }
            }
            if (isArray4(node)) {
              renderChildrenArray(request3, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request3, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request3.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request3.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request3, task, children) {
          var totalChildren = children.length;
          for (var i4 = 0; i4 < totalChildren; i4++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i4);
            try {
              renderNode(request3, task, children[i4]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request3, task, x5) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request3,
            insertionIndex,
            null,
            segment.formatContext,
            segment.lastPushedText,
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request3, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x5.then(ping, ping);
        }
        function renderNode(request3, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request3, task, node);
          } catch (x5) {
            resetHooksState();
            if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
              spawnNewSuspendedTask(request3, task, x5);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x5;
            }
          }
        }
        function erroredTask(request3, boundary, segment, error3) {
          var errorDigest = logRecoverableError(request3, error3);
          if (boundary === null) {
            fatalError(request3, error3);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error3);
              }
              if (boundary.parentFlushed) {
                request3.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request3.allPendingTasks--;
          if (request3.allPendingTasks === 0) {
            var onAllReady = request3.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request3 = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request3, boundary, segment);
        }
        function abortTask(task, request3, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request3.allPendingTasks--;
            if (request3.status !== CLOSED) {
              request3.status = CLOSED;
              if (request3.destination !== null) {
                close(request3.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request3.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request3.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request3, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request3.allPendingTasks--;
            if (request3.allPendingTasks === 0) {
              var onAllReady = request3.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request3, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request3.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request3.completedRootSegment = segment;
            }
            request3.pendingRootTasks--;
            if (request3.pendingRootTasks === 0) {
              request3.onShellError = noop$1;
              var onShellReady = request3.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request3.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request3);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request3.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request3.allPendingTasks--;
          if (request3.allPendingTasks === 0) {
            var onAllReady = request3.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request3, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request3, task, task.node);
            pushSegmentFinale$1(segment.chunks, request3.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request3, task.blockedBoundary, segment);
          } catch (x5) {
            resetHooksState();
            if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
              var ping = task.ping;
              x5.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request3, task.blockedBoundary, segment, x5);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request3) {
          if (request3.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request3.responseState);
          try {
            var pingedTasks = request3.pingedTasks;
            var i4;
            for (i4 = 0; i4 < pingedTasks.length; i4++) {
              var task = pingedTasks[i4];
              retryTask(request3, task);
            }
            pingedTasks.splice(0, i4);
            if (request3.destination !== null) {
              flushCompletedQueues(request3, request3.destination);
            }
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request3, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request3.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request3.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r5 = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r5 = flushSegment(request3, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r5 = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r5;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request3, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request3, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary$1(destination, request3.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request3, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request3.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request3.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request3.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request3.responseState);
            writeStartPendingSuspenseBoundary(destination, request3.responseState, id);
            flushSubtree(request3, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request3.responseState);
          } else if (boundary.byteSize > request3.progressiveChunkSize) {
            boundary.rootSegmentID = request3.nextSegmentId++;
            request3.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request3.responseState, boundary.id);
            flushSubtree(request3, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request3.responseState);
          } else {
            writeStartCompletedSuspenseBoundary$1(destination, request3.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request3, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request3.responseState);
          }
        }
        function flushClientRenderedBoundary(request3, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request3.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request3, destination, segment) {
          writeStartSegment(destination, request3.responseState, segment.formatContext, segment.id);
          flushSegment(request3, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request3, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            flushPartiallyCompletedSegment(request3, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request3.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request3, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            if (!flushPartiallyCompletedSegment(request3, destination, boundary, segment)) {
              i4++;
              completedSegments.splice(0, i4);
              return false;
            }
          }
          completedSegments.splice(0, i4);
          return true;
        }
        function flushPartiallyCompletedSegment(request3, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request3, destination, segment);
          } else {
            flushSegmentContainer(request3, destination, segment);
            return writeCompletedSegmentInstruction(destination, request3.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request3, destination) {
          try {
            var completedRootSegment = request3.completedRootSegment;
            if (completedRootSegment !== null && request3.pendingRootTasks === 0) {
              flushSegment(request3, destination, completedRootSegment);
              request3.completedRootSegment = null;
              writeCompletedRoot(destination, request3.responseState);
            }
            var clientRenderedBoundaries = request3.clientRenderedBoundaries;
            var i4;
            for (i4 = 0; i4 < clientRenderedBoundaries.length; i4++) {
              var boundary = clientRenderedBoundaries[i4];
              if (!flushClientRenderedBoundary(request3, destination, boundary)) {
                request3.destination = null;
                i4++;
                clientRenderedBoundaries.splice(0, i4);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i4);
            var completedBoundaries = request3.completedBoundaries;
            for (i4 = 0; i4 < completedBoundaries.length; i4++) {
              var _boundary = completedBoundaries[i4];
              if (!flushCompletedBoundary(request3, destination, _boundary)) {
                request3.destination = null;
                i4++;
                completedBoundaries.splice(0, i4);
                return;
              }
            }
            completedBoundaries.splice(0, i4);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request3.partialBoundaries;
            for (i4 = 0; i4 < partialBoundaries.length; i4++) {
              var _boundary2 = partialBoundaries[i4];
              if (!flushPartialBoundary(request3, destination, _boundary2)) {
                request3.destination = null;
                i4++;
                partialBoundaries.splice(0, i4);
                return;
              }
            }
            partialBoundaries.splice(0, i4);
            var largeBoundaries = request3.completedBoundaries;
            for (i4 = 0; i4 < largeBoundaries.length; i4++) {
              var _boundary3 = largeBoundaries[i4];
              if (!flushCompletedBoundary(request3, destination, _boundary3)) {
                request3.destination = null;
                i4++;
                largeBoundaries.splice(0, i4);
                return;
              }
            }
            largeBoundaries.splice(0, i4);
          } finally {
            if (request3.allPendingTasks === 0 && request3.pingedTasks.length === 0 && request3.clientRenderedBoundaries.length === 0 && request3.completedBoundaries.length === 0) {
              {
                if (request3.abortableTasks.size !== 0) {
                  error2("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request3) {
          scheduleWork(function() {
            return performWork(request3);
          });
        }
        function startFlowing(request3, destination) {
          if (request3.status === CLOSING) {
            request3.status = CLOSED;
            closeWithError(destination, request3.fatalError);
            return;
          }
          if (request3.status === CLOSED) {
            return;
          }
          if (request3.destination !== null) {
            return;
          }
          request3.destination = destination;
          try {
            flushCompletedQueues(request3, destination);
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          }
        }
        function abort(request3, reason) {
          try {
            var abortableTasks = request3.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request3, reason);
            });
            abortableTasks.clear();
            if (request3.destination !== null) {
              flushCompletedQueues(request3, request3.destination);
            }
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false;
          var fatalError2 = null;
          var result = "";
          var destination = {
            push: function(chunk) {
              if (chunk !== null) {
                result += chunk;
              }
              return true;
            },
            destroy: function(error3) {
              didFatal = true;
              fatalError2 = error3;
            }
          };
          var readyToStream = false;
          function onShellReady() {
            readyToStream = true;
          }
          var request3 = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
          startWork(request3);
          abort(request3, abortReason);
          startFlowing(request3, destination);
          if (didFatal) {
            throw fatalError2;
          }
          if (!readyToStream) {
            throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          }
          return result;
        }
        function renderToString(children, options) {
          return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToStaticMarkup(children, options) {
          return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToNodeStream() {
          throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
        }
        function renderToStaticNodeStream() {
          throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    if (true) {
      (function() {
        "use strict";
        var React8 = require_react();
        var ReactVersion = "18.2.0";
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format3) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format3, args);
            }
          }
        }
        function error2(format3) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format3, args);
            }
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
          if (chunk.length === 0) {
            return;
          }
          if (chunk.length > VIEW_SIZE) {
            if (writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            destination.enqueue(chunk);
            return;
          }
          var bytesToWrite = chunk;
          var allowableBytes = currentView.length - writtenBytes;
          if (allowableBytes < bytesToWrite.length) {
            if (allowableBytes === 0) {
              destination.enqueue(currentView);
            } else {
              currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
              destination.enqueue(currentView);
              bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          currentView.set(bytesToWrite, writtenBytes);
          writtenBytes += bytesToWrite.length;
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return true;
        }
        function completeWriting(destination) {
          if (currentView && writtenBytes > 0) {
            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
            currentView = null;
            writtenBytes = 0;
          }
        }
        function close(destination) {
          destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
          return textEncoder.encode(content);
        }
        function stringToPrecomputedChunk(content) {
          return textEncoder.encode(content);
        }
        function closeWithError(destination, error3) {
          if (typeof destination.error === "function") {
            destination.error(error3);
          } else {
            destination.close();
          }
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e5) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            name,
            null,
            false,
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            name,
            null,
            false,
            false
          );
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            name,
            null,
            false,
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            name,
            null,
            false,
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            name.toLowerCase(),
            null,
            false,
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            null,
            false,
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            false,
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            attributeName.toLowerCase(),
            null,
            true,
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key2) {
          return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props2) {
          {
            if (!(hasReadOnlyValue[props2.type] || props2.onChange || props2.onInput || props2.readOnly || props2.disabled || props2.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props2.onChange || props2.readOnly || props2.disabled || props2.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props2) {
          if (tagName.indexOf("-") === -1) {
            return typeof props2.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty3.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props2) {
          {
            var invalidProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty(type2, key2);
              if (!isValid) {
                invalidProps.push(key2);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props2) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnInvalidARIAProps(type2, props2);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props2) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props2 != null && props2.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props2.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty3.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props2, eventRegistry) {
          {
            var unknownProps = [];
            for (var key2 in props2) {
              var isValid = validateProperty$1(type2, key2, props2[key2], eventRegistry);
              if (!isValid) {
                unknownProps.push(key2);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props2, eventRegistry) {
          if (isCustomComponent(type2, props2)) {
            return;
          }
          warnUnknownProperties(type2, props2, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_5, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name,
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape2;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#x27;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape2;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a4) {
          return isArrayImpl(a4);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s4, suffix) {
          return "" + prefix2 + (s4 === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i4 = 0; i4 < bootstrapScripts.length; i4++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i4])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i2 = 0; _i2 < bootstrapModules.length; _i2++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i2])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function createRootFormatContext(namespaceURI) {
          var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
          return createFormatContext(insertionMode, null);
        }
        function getChildFormatContext(parentContext, type2, props2) {
          switch (type2) {
            case "select":
              return createFormatContext(HTML_MODE, props2.value != null ? props2.value : props2.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text) {
          return escapeTextForBrowser(text);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text, responseState, textEmbedded) {
          if (text === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty3.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty3.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false)
                  ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props2, propName) {
          {
            var value = props2[propName];
            if (value != null) {
              var array = isArray4(value);
              if (props2.multiple && !array) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props2.multiple && array) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props2, responseState) {
          {
            checkControlledValueProps("select", props2);
            checkSelectProp(props2, "value");
            checkSelectProp(props2, "defaultValue");
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React8.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props2, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray4(selectedValue)) {
              for (var i4 = 0; i4 < selectedValue.length; i4++) {
                {
                  checkAttributeStringCoercion(selectedValue[i4], "value");
                }
                var v5 = "" + selectedValue[i4];
                if (v5 === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props2, responseState) {
          {
            checkControlledValueProps("input", props2);
            if (props2.checked !== void 0 && props2.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props2.type);
              didWarnDefaultChecked = true;
            }
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props2.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked3 = null;
          var defaultChecked = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked3 = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked3 !== null) {
            pushAttribute(target, responseState, "checked", checked3);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props2, responseState) {
          {
            checkControlledValueProps("textarea", props2);
            if (props2.value !== void 0 && props2.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error2("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray4(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props2, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props2, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error2("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error2("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error2("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props2, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props2) {
            if (hasOwnProperty3.call(props2, propKey)) {
              var propValue = props2[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type2, props2, responseState, formatContext) {
          {
            validateProperties(type2, props2);
            validateProperties$1(type2, props2);
            validateProperties$2(type2, props2, null);
            if (!props2.suppressContentEditableWarning && props2.contentEditable && props2.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type2.indexOf("-") === -1 && typeof props2.is !== "string" && type2.toLowerCase() !== type2) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2);
              }
            }
          }
          switch (type2) {
            case "select":
              return pushStartSelect(target, props2, responseState);
            case "option":
              return pushStartOption(target, props2, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props2, responseState);
            case "input":
              return pushInput(target, props2, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props2, responseState);
            case "title":
              return pushStartTitle(target, props2, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props2, type2, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props2, type2, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props2, type2, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props2, type2, responseState);
            }
            default: {
              if (type2.indexOf("-") === -1 && typeof props2.is !== "string") {
                return pushStartGenericElement(target, props2, type2, responseState);
              } else {
                return pushStartCustomElement(target, props2, type2, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type2, props2) {
          switch (type2) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type2), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i4 = 0;
          for (; i4 < bootstrapChunks.length - 1; i4++) {
            writeChunk(destination, bootstrapChunks[i4]);
          }
          if (i4 < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i4]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context2 = type2;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider2 = type2;
                return getContextName(provider2._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init3(payload));
                } catch (x5) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props2 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props2,
                log: props2,
                warn: props2,
                error: props2,
                group: props2,
                groupCollapsed: props2,
                groupEnd: props2
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props2 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props2, {
                  value: prevLog
                }),
                info: assign({}, props2, {
                  value: prevInfo
                }),
                warn: assign({}, props2, {
                  value: prevWarn
                }),
                error: assign({}, props2, {
                  value: prevError
                }),
                group: assign({}, props2, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props2, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props2, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x5) {
                var match = x5.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x5) {
                  control = x5;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x5) {
                  control = x5;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x5) {
                control = x5;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s4 = sampleLines.length - 1;
              var c4 = controlLines.length - 1;
              while (s4 >= 1 && c4 >= 0 && sampleLines[s4] !== controlLines[c4]) {
                c4--;
              }
              for (; s4 >= 1 && c4 >= 0; s4--, c4--) {
                if (sampleLines[s4] !== controlLines[c4]) {
                  if (s4 !== 1 || c4 !== 1) {
                    do {
                      s4--;
                      c4--;
                      if (c4 < 0 || sampleLines[s4] !== controlLines[c4]) {
                        var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s4 >= 1 && c4 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init3 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                } catch (x5) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type2, unmaskedContext) {
          {
            var contextTypes = type2.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context2 = {};
            for (var key2 in contextTypes) {
              context2[key2] = unmaskedContext[key2];
            }
            {
              var name = getComponentNameFromType(type2) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name);
            }
            return context2;
          }
        }
        function processChildContext(instance, type2, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type2) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type2) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next)
            ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context2, nextValue) {
          var prevValue;
          {
            prevValue = context2._currentValue;
            context2._currentValue = nextValue;
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context2,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context2) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context2) {
              error2("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var value = prevSnapshot.parentValue;
            if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue = value;
            }
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context2) {
          var value = context2._currentValue;
          return value;
        }
        function get3(key2) {
          return key2._reactInternals;
        }
        function set(key2, value) {
          key2._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key2 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key2)) {
              didWarnOnInvalidCallback.add(key2);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type2, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type2) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error2("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get3(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get3(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get3(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props2, maskedLegacyContext) {
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            context2 = maskedLegacyContext;
          }
          var instance = new ctor(props2, context2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray4(_state))) {
              error2("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type2) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props2, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i4 = oldReplace ? 1 : 0; i4 < oldQueue.length; i4++) {
                var partial = oldQueue[i4];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props2, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context2) {
          var overflow = context2.overflow;
          var idWithLeadingBit = context2.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log2 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x5) {
          var asUint = x5 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log2(asUint) / LN2 | 0) | 0;
        }
        function is(x5, y5) {
          return x5 === y5 && (x5 !== 0 || 1 / x5 === 1 / y5) || x5 !== x5 && y5 !== y5;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i4 = 0; i4 < prevDeps.length && i4 < nextDeps.length; i4++) {
            if (objectIs(nextDeps[i4], prevDeps[i4])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props2, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props2, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context2) {
          {
            if (isInHookUserCodeInDev) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context2);
        }
        function useContext2(context2) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context2);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            initialState
          );
        }
        function useReducer(reducer, initialArg, init3) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue3 = workInProgressHook.queue;
            var dispatch = queue3.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue3);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init3 !== void 0 ? init3(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo2(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef2(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error2("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue3, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue3, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback(callback, deps) {
          return useMemo2(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop3() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext2,
          useMemo: useMemo2,
          useReducer,
          useRef: useRef2,
          useState,
          useInsertionEffect: noop3,
          useLayoutEffect,
          useCallback,
          useImperativeHandle: noop3,
          useEffect: noop3,
          useDebugValue: noop3,
          useDeferredValue,
          useTransition,
          useId,
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x5) {
            return "\nError generating stack: " + x5.message + "\n" + x5.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error3) {
          console["error"](error3);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request3 = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === void 0 ? defaultErrorHandler : onError,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request3,
            0,
            null,
            rootFormatContext,
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request3, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request3;
        }
        function pingTask(request3, task) {
          var pingedTasks = request3.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request3);
            });
          }
        }
        function createSuspenseBoundary(request3, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request3, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context2, treeContext) {
          request3.allPendingTasks++;
          if (blockedBoundary === null) {
            request3.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request3, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context: context2,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request3, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function pushClassComponentStackInDEV(task, type2) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type: type2
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error2("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error3) {
          {
            var errorMessage;
            if (typeof error3 === "string") {
              errorMessage = error3;
            } else if (error3 && typeof error3.message === "string") {
              errorMessage = error3.message;
            } else {
              errorMessage = String(error3);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request3, error3) {
          var errorDigest = request3.onError(error3);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request3, error3) {
          var onShellError = request3.onShellError;
          onShellError(error3);
          var onFatalError = request3.onFatalError;
          onFatalError(error3);
          if (request3.destination !== null) {
            request3.status = CLOSED;
            closeWithError(request3.destination, error3);
          } else {
            request3.status = CLOSING;
            request3.fatalError = error3;
          }
        }
        function renderSuspenseBoundary(request3, task, props2) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props2.fallback;
          var content = props2.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request3, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request3,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request3,
            0,
            null,
            parentSegment.formatContext,
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request3, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request3.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error3) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request3, error3);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error3);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request3, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request3.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request3, task, type2, props2) {
          pushBuiltInComponentStackInDEV(task, type2);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type2, props2, request3.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type2, props2);
          renderNode(request3, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type2);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request3, task, Component, props2, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props2, secondArg);
          return finishHooks(Component, props2, result, secondArg);
        }
        function finishClassComponent(request3, task, instance, Component, props2) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props2) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request3, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request3, task, nextChildren);
        }
        function renderClassComponent(request3, task, Component, props2) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props2, maskedContext);
          mountClassInstance(instance, Component, props2, maskedContext);
          finishClassComponent(request3, task, instance, Component, props2);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request3, task, Component, props2) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request3, task, Component, props2, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props2, legacyContext);
            finishClassComponent(request3, task, value, Component, props2);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request3, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request3, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props2 = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props2[propName] === void 0) {
                props2[propName] = defaultProps[propName];
              }
            }
            return props2;
          }
          return baseProps;
        }
        function renderForwardRef(request3, task, type2, props2, ref) {
          pushFunctionComponentStackInDEV(task, type2.render);
          var children = renderWithHooks(request3, task, type2.render, props2, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request3, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request3, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request3, task, type2, props2, ref) {
          var innerType = type2.type;
          var resolvedProps = resolveDefaultProps(innerType, props2);
          renderElement(request3, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request3, task, context2, props2) {
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var render = props2.children;
          {
            if (typeof render !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context2);
          var newChildren = render(newValue);
          renderNodeDestructive(request3, task, newChildren);
        }
        function renderContextProvider(request3, task, type2, props2) {
          var context2 = type2._context;
          var value = props2.value;
          var children = props2.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context2, value);
          renderNodeDestructive(request3, task, children);
          task.context = popProvider(context2);
          {
            if (prevSnapshot !== task.context) {
              error2("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request3, task, lazyComponent, props2, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init3 = lazyComponent._init;
          var Component = init3(payload);
          var resolvedProps = resolveDefaultProps(Component, props2);
          renderElement(request3, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request3, task, type2, props2, ref) {
          if (typeof type2 === "function") {
            if (shouldConstruct$1(type2)) {
              renderClassComponent(request3, task, type2, props2);
              return;
            } else {
              renderIndeterminateComponent(request3, task, type2, props2);
              return;
            }
          }
          if (typeof type2 === "string") {
            renderHostElement(request3, task, type2, props2);
            return;
          }
          switch (type2) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request3, task, props2.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request3, task, props2.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request3, task, props2);
              }
              return;
            }
          }
          if (typeof type2 === "object" && type2 !== null) {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request3, task, type2, props2, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request3, task, type2, props2, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request3, task, type2, props2);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request3, task, type2, props2);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request3, task, type2, props2);
                return;
              }
            }
          }
          var info = "";
          {
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request3, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request3, task, node);
            } catch (x5) {
              if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function")
                ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x5;
            }
          }
        }
        function renderNodeDestructiveImpl(request3, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type2 = element.type;
                var props2 = element.props;
                var ref = element.ref;
                renderElement(request3, task, type2, props2, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init3 = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init3(payload);
                  } catch (x5) {
                    if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x5;
                  }
                }
                renderNodeDestructive(request3, task, resolvedNode);
                return;
              }
            }
            if (isArray4(node)) {
              renderChildrenArray(request3, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request3, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request3.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request3.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request3, task, children) {
          var totalChildren = children.length;
          for (var i4 = 0; i4 < totalChildren; i4++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i4);
            try {
              renderNode(request3, task, children[i4]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request3, task, x5) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request3,
            insertionIndex,
            null,
            segment.formatContext,
            segment.lastPushedText,
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request3, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x5.then(ping, ping);
        }
        function renderNode(request3, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request3, task, node);
          } catch (x5) {
            resetHooksState();
            if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
              spawnNewSuspendedTask(request3, task, x5);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x5;
            }
          }
        }
        function erroredTask(request3, boundary, segment, error3) {
          var errorDigest = logRecoverableError(request3, error3);
          if (boundary === null) {
            fatalError(request3, error3);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error3);
              }
              if (boundary.parentFlushed) {
                request3.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request3.allPendingTasks--;
          if (request3.allPendingTasks === 0) {
            var onAllReady = request3.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request3 = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request3, boundary, segment);
        }
        function abortTask(task, request3, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request3.allPendingTasks--;
            if (request3.status !== CLOSED) {
              request3.status = CLOSED;
              if (request3.destination !== null) {
                close(request3.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request3.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request3.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request3, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request3.allPendingTasks--;
            if (request3.allPendingTasks === 0) {
              var onAllReady = request3.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request3, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request3.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request3.completedRootSegment = segment;
            }
            request3.pendingRootTasks--;
            if (request3.pendingRootTasks === 0) {
              request3.onShellError = noop$1;
              var onShellReady = request3.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender)
              ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request3.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request3);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request3.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request3.allPendingTasks--;
          if (request3.allPendingTasks === 0) {
            var onAllReady = request3.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request3, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request3, task, task.node);
            pushSegmentFinale(segment.chunks, request3.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request3, task.blockedBoundary, segment);
          } catch (x5) {
            resetHooksState();
            if (typeof x5 === "object" && x5 !== null && typeof x5.then === "function") {
              var ping = task.ping;
              x5.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request3, task.blockedBoundary, segment, x5);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request3) {
          if (request3.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request3.responseState);
          try {
            var pingedTasks = request3.pingedTasks;
            var i4;
            for (i4 = 0; i4 < pingedTasks.length; i4++) {
              var task = pingedTasks[i4];
              retryTask(request3, task);
            }
            pingedTasks.splice(0, i4);
            if (request3.destination !== null) {
              flushCompletedQueues(request3, request3.destination);
            }
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request3, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request3.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request3.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r5 = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r5 = flushSegment(request3, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r5 = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r5;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request3, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request3, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary(destination, request3.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request3, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request3.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request3.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request3.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request3.responseState);
            writeStartPendingSuspenseBoundary(destination, request3.responseState, id);
            flushSubtree(request3, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request3.responseState);
          } else if (boundary.byteSize > request3.progressiveChunkSize) {
            boundary.rootSegmentID = request3.nextSegmentId++;
            request3.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request3.responseState, boundary.id);
            flushSubtree(request3, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request3.responseState);
          } else {
            writeStartCompletedSuspenseBoundary(destination, request3.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request3, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request3.responseState);
          }
        }
        function flushClientRenderedBoundary(request3, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request3.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request3, destination, segment) {
          writeStartSegment(destination, request3.responseState, segment.formatContext, segment.id);
          flushSegment(request3, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request3, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            flushPartiallyCompletedSegment(request3, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request3.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request3, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i4 = 0;
          for (; i4 < completedSegments.length; i4++) {
            var segment = completedSegments[i4];
            if (!flushPartiallyCompletedSegment(request3, destination, boundary, segment)) {
              i4++;
              completedSegments.splice(0, i4);
              return false;
            }
          }
          completedSegments.splice(0, i4);
          return true;
        }
        function flushPartiallyCompletedSegment(request3, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request3, destination, segment);
          } else {
            flushSegmentContainer(request3, destination, segment);
            return writeCompletedSegmentInstruction(destination, request3.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request3, destination) {
          beginWriting();
          try {
            var completedRootSegment = request3.completedRootSegment;
            if (completedRootSegment !== null && request3.pendingRootTasks === 0) {
              flushSegment(request3, destination, completedRootSegment);
              request3.completedRootSegment = null;
              writeCompletedRoot(destination, request3.responseState);
            }
            var clientRenderedBoundaries = request3.clientRenderedBoundaries;
            var i4;
            for (i4 = 0; i4 < clientRenderedBoundaries.length; i4++) {
              var boundary = clientRenderedBoundaries[i4];
              if (!flushClientRenderedBoundary(request3, destination, boundary)) {
                request3.destination = null;
                i4++;
                clientRenderedBoundaries.splice(0, i4);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i4);
            var completedBoundaries = request3.completedBoundaries;
            for (i4 = 0; i4 < completedBoundaries.length; i4++) {
              var _boundary = completedBoundaries[i4];
              if (!flushCompletedBoundary(request3, destination, _boundary)) {
                request3.destination = null;
                i4++;
                completedBoundaries.splice(0, i4);
                return;
              }
            }
            completedBoundaries.splice(0, i4);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request3.partialBoundaries;
            for (i4 = 0; i4 < partialBoundaries.length; i4++) {
              var _boundary2 = partialBoundaries[i4];
              if (!flushPartialBoundary(request3, destination, _boundary2)) {
                request3.destination = null;
                i4++;
                partialBoundaries.splice(0, i4);
                return;
              }
            }
            partialBoundaries.splice(0, i4);
            var largeBoundaries = request3.completedBoundaries;
            for (i4 = 0; i4 < largeBoundaries.length; i4++) {
              var _boundary3 = largeBoundaries[i4];
              if (!flushCompletedBoundary(request3, destination, _boundary3)) {
                request3.destination = null;
                i4++;
                largeBoundaries.splice(0, i4);
                return;
              }
            }
            largeBoundaries.splice(0, i4);
          } finally {
            completeWriting(destination);
            if (request3.allPendingTasks === 0 && request3.pingedTasks.length === 0 && request3.clientRenderedBoundaries.length === 0 && request3.completedBoundaries.length === 0) {
              {
                if (request3.abortableTasks.size !== 0) {
                  error2("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request3) {
          scheduleWork(function() {
            return performWork(request3);
          });
        }
        function startFlowing(request3, destination) {
          if (request3.status === CLOSING) {
            request3.status = CLOSED;
            closeWithError(destination, request3.fatalError);
            return;
          }
          if (request3.status === CLOSED) {
            return;
          }
          if (request3.destination !== null) {
            return;
          }
          request3.destination = destination;
          try {
            flushCompletedQueues(request3, destination);
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          }
        }
        function abort(request3, reason) {
          try {
            var abortableTasks = request3.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request3, reason);
            });
            abortableTasks.clear();
            if (request3.destination !== null) {
              flushCompletedQueues(request3, request3.destination);
            }
          } catch (error3) {
            logRecoverableError(request3, error3);
            fatalError(request3, error3);
          }
        }
        function renderToReadableStream(children, options) {
          return new Promise(function(resolve, reject) {
            var onFatalError;
            var onAllReady;
            var allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            });
            function onShellReady() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request3, controller);
                  },
                  cancel: function(reason) {
                    abort(request3);
                  }
                },
                {
                  highWaterMark: 0
                }
              );
              stream.allReady = allReady;
              resolve(stream);
            }
            function onShellError(error3) {
              allReady.catch(function() {
              });
              reject(error3);
            }
            var request3 = createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
            if (options && options.signal) {
              var signal = options.signal;
              var listener = function() {
                abort(request3, signal.reason);
                signal.removeEventListener("abort", listener);
              };
              signal.addEventListener("abort", listener);
            }
            startWork(request3);
          });
        }
        exports.renderToReadableStream = renderToReadableStream;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "node_modules/react-dom/server.browser.js"(exports) {
    "use strict";
    init_virtual_process_polyfill();
    init_buffer();
    var l5;
    var s4;
    if (false) {
      l5 = null;
      s4 = null;
    } else {
      l5 = require_react_dom_server_legacy_browser_development();
      s4 = require_react_dom_server_browser_development();
    }
    exports.version = l5.version;
    exports.renderToString = l5.renderToString;
    exports.renderToStaticMarkup = l5.renderToStaticMarkup;
    exports.renderToNodeStream = l5.renderToNodeStream;
    exports.renderToStaticNodeStream = l5.renderToStaticNodeStream;
    exports.renderToReadableStream = s4.renderToReadableStream;
  }
});

// node_modules/qr-code-styling-new/lib/qr-code-styling.js
var require_qr_code_styling = __commonJS({
  "node_modules/qr-code-styling-new/lib/qr-code-styling.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    !function(t5, e5) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e5() : "function" == typeof define && define.amd ? define([], e5) : "object" == typeof exports ? exports.QRCodeStyling = e5() : t5.QRCodeStyling = e5();
    }(exports, function() {
      return (() => {
        var t5 = { 192: (t6, e6) => {
          var r6, n5, o4 = function() {
            var t7 = function(t8, e8) {
              var r8 = t8, n7 = a4[e8], o6 = null, i5 = 0, c5 = null, v6 = [], y6 = {}, _5 = function(t9, e9) {
                o6 = function(t10) {
                  for (var e10 = new Array(t10), r9 = 0; r9 < t10; r9 += 1) {
                    e10[r9] = new Array(t10);
                    for (var n8 = 0; n8 < t10; n8 += 1)
                      e10[r9][n8] = null;
                  }
                  return e10;
                }(i5 = 4 * r8 + 17), m5(0, 0), m5(i5 - 7, 0), m5(0, i5 - 7), x5(), b3(), S3(t9, e9), r8 >= 7 && M4(t9), null == c5 && (c5 = P4(r8, n7, v6)), C4(c5, e9);
              }, m5 = function(t9, e9) {
                for (var r9 = -1; r9 <= 7; r9 += 1)
                  if (!(t9 + r9 <= -1 || i5 <= t9 + r9))
                    for (var n8 = -1; n8 <= 7; n8 += 1)
                      e9 + n8 <= -1 || i5 <= e9 + n8 || (o6[t9 + r9][e9 + n8] = 0 <= r9 && r9 <= 6 && (0 == n8 || 6 == n8) || 0 <= n8 && n8 <= 6 && (0 == r9 || 6 == r9) || 2 <= r9 && r9 <= 4 && 2 <= n8 && n8 <= 4);
              }, b3 = function() {
                for (var t9 = 8; t9 < i5 - 8; t9 += 1)
                  null == o6[t9][6] && (o6[t9][6] = t9 % 2 == 0);
                for (var e9 = 8; e9 < i5 - 8; e9 += 1)
                  null == o6[6][e9] && (o6[6][e9] = e9 % 2 == 0);
              }, x5 = function() {
                for (var t9 = s4.getPatternPosition(r8), e9 = 0; e9 < t9.length; e9 += 1)
                  for (var n8 = 0; n8 < t9.length; n8 += 1) {
                    var i6 = t9[e9], a5 = t9[n8];
                    if (null == o6[i6][a5])
                      for (var c6 = -2; c6 <= 2; c6 += 1)
                        for (var u6 = -2; u6 <= 2; u6 += 1)
                          o6[i6 + c6][a5 + u6] = -2 == c6 || 2 == c6 || -2 == u6 || 2 == u6 || 0 == c6 && 0 == u6;
                  }
              }, M4 = function(t9) {
                for (var e9 = s4.getBCHTypeNumber(r8), n8 = 0; n8 < 18; n8 += 1) {
                  var a5 = !t9 && 1 == (e9 >> n8 & 1);
                  o6[Math.floor(n8 / 3)][n8 % 3 + i5 - 8 - 3] = a5;
                }
                for (n8 = 0; n8 < 18; n8 += 1)
                  a5 = !t9 && 1 == (e9 >> n8 & 1), o6[n8 % 3 + i5 - 8 - 3][Math.floor(n8 / 3)] = a5;
              }, S3 = function(t9, e9) {
                for (var r9 = n7 << 3 | e9, a5 = s4.getBCHTypeInfo(r9), c6 = 0; c6 < 15; c6 += 1) {
                  var u6 = !t9 && 1 == (a5 >> c6 & 1);
                  c6 < 6 ? o6[c6][8] = u6 : c6 < 8 ? o6[c6 + 1][8] = u6 : o6[i5 - 15 + c6][8] = u6;
                }
                for (c6 = 0; c6 < 15; c6 += 1)
                  u6 = !t9 && 1 == (a5 >> c6 & 1), c6 < 8 ? o6[8][i5 - c6 - 1] = u6 : c6 < 9 ? o6[8][15 - c6 - 1 + 1] = u6 : o6[8][15 - c6 - 1] = u6;
                o6[i5 - 8][8] = !t9;
              }, C4 = function(t9, e9) {
                for (var r9 = -1, n8 = i5 - 1, a5 = 7, c6 = 0, u6 = s4.getMaskFunction(e9), h6 = i5 - 1; h6 > 0; h6 -= 2)
                  for (6 == h6 && (h6 -= 1); ; ) {
                    for (var d5 = 0; d5 < 2; d5 += 1)
                      if (null == o6[n8][h6 - d5]) {
                        var l6 = false;
                        c6 < t9.length && (l6 = 1 == (t9[c6] >>> a5 & 1)), u6(n8, h6 - d5) && (l6 = !l6), o6[n8][h6 - d5] = l6, -1 == (a5 -= 1) && (c6 += 1, a5 = 7);
                      }
                    if ((n8 += r9) < 0 || i5 <= n8) {
                      n8 -= r9, r9 = -r9;
                      break;
                    }
                  }
              }, P4 = function(t9, e9, r9) {
                for (var n8 = h5.getRSBlocks(t9, e9), o7 = d4(), i6 = 0; i6 < r9.length; i6 += 1) {
                  var a5 = r9[i6];
                  o7.put(a5.getMode(), 4), o7.put(a5.getLength(), s4.getLengthInBits(a5.getMode(), t9)), a5.write(o7);
                }
                var c6 = 0;
                for (i6 = 0; i6 < n8.length; i6 += 1)
                  c6 += n8[i6].dataCount;
                if (o7.getLengthInBits() > 8 * c6)
                  throw "code length overflow. (" + o7.getLengthInBits() + ">" + 8 * c6 + ")";
                for (o7.getLengthInBits() + 4 <= 8 * c6 && o7.put(0, 4); o7.getLengthInBits() % 8 != 0; )
                  o7.putBit(false);
                for (; !(o7.getLengthInBits() >= 8 * c6 || (o7.put(236, 8), o7.getLengthInBits() >= 8 * c6)); )
                  o7.put(17, 8);
                return function(t10, e10) {
                  for (var r10 = 0, n9 = 0, o8 = 0, i7 = new Array(e10.length), a6 = new Array(e10.length), c7 = 0; c7 < e10.length; c7 += 1) {
                    var h6 = e10[c7].dataCount, d5 = e10[c7].totalCount - h6;
                    n9 = Math.max(n9, h6), o8 = Math.max(o8, d5), i7[c7] = new Array(h6);
                    for (var l6 = 0; l6 < i7[c7].length; l6 += 1)
                      i7[c7][l6] = 255 & t10.getBuffer()[l6 + r10];
                    r10 += h6;
                    var f6 = s4.getErrorCorrectPolynomial(d5), p6 = u5(i7[c7], f6.getLength() - 1).mod(f6);
                    for (a6[c7] = new Array(f6.getLength() - 1), l6 = 0; l6 < a6[c7].length; l6 += 1) {
                      var g5 = l6 + p6.getLength() - a6[c7].length;
                      a6[c7][l6] = g5 >= 0 ? p6.getAt(g5) : 0;
                    }
                  }
                  var v7 = 0;
                  for (l6 = 0; l6 < e10.length; l6 += 1)
                    v7 += e10[l6].totalCount;
                  var y7 = new Array(v7), w7 = 0;
                  for (l6 = 0; l6 < n9; l6 += 1)
                    for (c7 = 0; c7 < e10.length; c7 += 1)
                      l6 < i7[c7].length && (y7[w7] = i7[c7][l6], w7 += 1);
                  for (l6 = 0; l6 < o8; l6 += 1)
                    for (c7 = 0; c7 < e10.length; c7 += 1)
                      l6 < a6[c7].length && (y7[w7] = a6[c7][l6], w7 += 1);
                  return y7;
                }(o7, n8);
              };
              y6.addData = function(t9, e9) {
                var r9 = null;
                switch (e9 = e9 || "Byte") {
                  case "Numeric":
                    r9 = l5(t9);
                    break;
                  case "Alphanumeric":
                    r9 = f5(t9);
                    break;
                  case "Byte":
                    r9 = p5(t9);
                    break;
                  case "Kanji":
                    r9 = g4(t9);
                    break;
                  default:
                    throw "mode:" + e9;
                }
                v6.push(r9), c5 = null;
              }, y6.isDark = function(t9, e9) {
                if (t9 < 0 || i5 <= t9 || e9 < 0 || i5 <= e9)
                  throw t9 + "," + e9;
                return o6[t9][e9];
              }, y6.getModuleCount = function() {
                return i5;
              }, y6.make = function() {
                if (r8 < 1) {
                  for (var t9 = 1; t9 < 40; t9++) {
                    for (var e9 = h5.getRSBlocks(t9, n7), o7 = d4(), i6 = 0; i6 < v6.length; i6++) {
                      var a5 = v6[i6];
                      o7.put(a5.getMode(), 4), o7.put(a5.getLength(), s4.getLengthInBits(a5.getMode(), t9)), a5.write(o7);
                    }
                    var c6 = 0;
                    for (i6 = 0; i6 < e9.length; i6++)
                      c6 += e9[i6].dataCount;
                    if (o7.getLengthInBits() <= 8 * c6)
                      break;
                  }
                  r8 = t9;
                }
                _5(false, function() {
                  for (var t10 = 0, e10 = 0, r9 = 0; r9 < 8; r9 += 1) {
                    _5(true, r9);
                    var n8 = s4.getLostPoint(y6);
                    (0 == r9 || t10 > n8) && (t10 = n8, e10 = r9);
                  }
                  return e10;
                }());
              }, y6.createTableTag = function(t9, e9) {
                t9 = t9 || 2;
                var r9 = "";
                r9 += '<table style="', r9 += " border-width: 0px; border-style: none;", r9 += " border-collapse: collapse;", r9 += " padding: 0px; margin: " + (e9 = void 0 === e9 ? 4 * t9 : e9) + "px;", r9 += '">', r9 += "<tbody>";
                for (var n8 = 0; n8 < y6.getModuleCount(); n8 += 1) {
                  r9 += "<tr>";
                  for (var o7 = 0; o7 < y6.getModuleCount(); o7 += 1)
                    r9 += '<td style="', r9 += " border-width: 0px; border-style: none;", r9 += " border-collapse: collapse;", r9 += " padding: 0px; margin: 0px;", r9 += " width: " + t9 + "px;", r9 += " height: " + t9 + "px;", r9 += " background-color: ", r9 += y6.isDark(n8, o7) ? "#000000" : "#ffffff", r9 += ";", r9 += '"/>';
                  r9 += "</tr>";
                }
                return (r9 += "</tbody>") + "</table>";
              }, y6.createSvgTag = function(t9, e9, r9, n8) {
                var o7 = {};
                "object" == typeof arguments[0] && (t9 = (o7 = arguments[0]).cellSize, e9 = o7.margin, r9 = o7.alt, n8 = o7.title), t9 = t9 || 2, e9 = void 0 === e9 ? 4 * t9 : e9, (r9 = "string" == typeof r9 ? { text: r9 } : r9 || {}).text = r9.text || null, r9.id = r9.text ? r9.id || "qrcode-description" : null, (n8 = "string" == typeof n8 ? { text: n8 } : n8 || {}).text = n8.text || null, n8.id = n8.text ? n8.id || "qrcode-title" : null;
                var i6, a5, s5, c6, u6 = y6.getModuleCount() * t9 + 2 * e9, h6 = "";
                for (c6 = "l" + t9 + ",0 0," + t9 + " -" + t9 + ",0 0,-" + t9 + "z ", h6 += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', h6 += o7.scalable ? "" : ' width="' + u6 + 'px" height="' + u6 + 'px"', h6 += ' viewBox="0 0 ' + u6 + " " + u6 + '" ', h6 += ' preserveAspectRatio="xMinYMin meet"', h6 += n8.text || r9.text ? ' role="img" aria-labelledby="' + O4([n8.id, r9.id].join(" ").trim()) + '"' : "", h6 += ">", h6 += n8.text ? '<title id="' + O4(n8.id) + '">' + O4(n8.text) + "</title>" : "", h6 += r9.text ? '<description id="' + O4(r9.id) + '">' + O4(r9.text) + "</description>" : "", h6 += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', h6 += '<path d="', a5 = 0; a5 < y6.getModuleCount(); a5 += 1)
                  for (s5 = a5 * t9 + e9, i6 = 0; i6 < y6.getModuleCount(); i6 += 1)
                    y6.isDark(a5, i6) && (h6 += "M" + (i6 * t9 + e9) + "," + s5 + c6);
                return (h6 += '" stroke="transparent" fill="black"/>') + "</svg>";
              }, y6.createDataURL = function(t9, e9) {
                t9 = t9 || 2, e9 = void 0 === e9 ? 4 * t9 : e9;
                var r9 = y6.getModuleCount() * t9 + 2 * e9, n8 = e9, o7 = r9 - e9;
                return w6(r9, r9, function(e10, r10) {
                  if (n8 <= e10 && e10 < o7 && n8 <= r10 && r10 < o7) {
                    var i6 = Math.floor((e10 - n8) / t9), a5 = Math.floor((r10 - n8) / t9);
                    return y6.isDark(a5, i6) ? 0 : 1;
                  }
                  return 1;
                });
              }, y6.createImgTag = function(t9, e9, r9) {
                t9 = t9 || 2, e9 = void 0 === e9 ? 4 * t9 : e9;
                var n8 = y6.getModuleCount() * t9 + 2 * e9, o7 = "";
                return o7 += "<img", o7 += ' src="', o7 += y6.createDataURL(t9, e9), o7 += '"', o7 += ' width="', o7 += n8, o7 += '"', o7 += ' height="', o7 += n8, o7 += '"', r9 && (o7 += ' alt="', o7 += O4(r9), o7 += '"'), o7 + "/>";
              };
              var O4 = function(t9) {
                for (var e9 = "", r9 = 0; r9 < t9.length; r9 += 1) {
                  var n8 = t9.charAt(r9);
                  switch (n8) {
                    case "<":
                      e9 += "&lt;";
                      break;
                    case ">":
                      e9 += "&gt;";
                      break;
                    case "&":
                      e9 += "&amp;";
                      break;
                    case '"':
                      e9 += "&quot;";
                      break;
                    default:
                      e9 += n8;
                  }
                }
                return e9;
              };
              return y6.createASCII = function(t9, e9) {
                if ((t9 = t9 || 1) < 2)
                  return function(t10) {
                    t10 = void 0 === t10 ? 2 : t10;
                    var e10, r10, n9, o8, i7, a6 = 1 * y6.getModuleCount() + 2 * t10, s6 = t10, c7 = a6 - t10, u7 = { "\u2588\u2588": "\u2588", "\u2588 ": "\u2580", " \u2588": "\u2584", "  ": " " }, h7 = { "\u2588\u2588": "\u2580", "\u2588 ": "\u2580", " \u2588": " ", "  ": " " }, d6 = "";
                    for (e10 = 0; e10 < a6; e10 += 2) {
                      for (n9 = Math.floor((e10 - s6) / 1), o8 = Math.floor((e10 + 1 - s6) / 1), r10 = 0; r10 < a6; r10 += 1)
                        i7 = "\u2588", s6 <= r10 && r10 < c7 && s6 <= e10 && e10 < c7 && y6.isDark(n9, Math.floor((r10 - s6) / 1)) && (i7 = " "), s6 <= r10 && r10 < c7 && s6 <= e10 + 1 && e10 + 1 < c7 && y6.isDark(o8, Math.floor((r10 - s6) / 1)) ? i7 += " " : i7 += "\u2588", d6 += t10 < 1 && e10 + 1 >= c7 ? h7[i7] : u7[i7];
                      d6 += "\n";
                    }
                    return a6 % 2 && t10 > 0 ? d6.substring(0, d6.length - a6 - 1) + Array(a6 + 1).join("\u2580") : d6.substring(0, d6.length - 1);
                  }(e9);
                t9 -= 1, e9 = void 0 === e9 ? 2 * t9 : e9;
                var r9, n8, o7, i6, a5 = y6.getModuleCount() * t9 + 2 * e9, s5 = e9, c6 = a5 - e9, u6 = Array(t9 + 1).join("\u2588\u2588"), h6 = Array(t9 + 1).join("  "), d5 = "", l6 = "";
                for (r9 = 0; r9 < a5; r9 += 1) {
                  for (o7 = Math.floor((r9 - s5) / t9), l6 = "", n8 = 0; n8 < a5; n8 += 1)
                    i6 = 1, s5 <= n8 && n8 < c6 && s5 <= r9 && r9 < c6 && y6.isDark(o7, Math.floor((n8 - s5) / t9)) && (i6 = 0), l6 += i6 ? u6 : h6;
                  for (o7 = 0; o7 < t9; o7 += 1)
                    d5 += l6 + "\n";
                }
                return d5.substring(0, d5.length - 1);
              }, y6.renderTo2dContext = function(t9, e9) {
                e9 = e9 || 2;
                for (var r9 = y6.getModuleCount(), n8 = 0; n8 < r9; n8++)
                  for (var o7 = 0; o7 < r9; o7++)
                    t9.fillStyle = y6.isDark(n8, o7) ? "black" : "white", t9.fillRect(n8 * e9, o7 * e9, e9, e9);
              }, y6;
            };
            t7.stringToBytes = (t7.stringToBytesFuncs = { default: function(t8) {
              for (var e8 = [], r8 = 0; r8 < t8.length; r8 += 1) {
                var n7 = t8.charCodeAt(r8);
                e8.push(255 & n7);
              }
              return e8;
            } }).default, t7.createStringToBytes = function(t8, e8) {
              var r8 = function() {
                for (var r9 = y5(t8), n8 = function() {
                  var t9 = r9.read();
                  if (-1 == t9)
                    throw "eof";
                  return t9;
                }, o6 = 0, i5 = {}; ; ) {
                  var a5 = r9.read();
                  if (-1 == a5)
                    break;
                  var s5 = n8(), c5 = n8() << 8 | n8();
                  i5[String.fromCharCode(a5 << 8 | s5)] = c5, o6 += 1;
                }
                if (o6 != e8)
                  throw o6 + " != " + e8;
                return i5;
              }(), n7 = "?".charCodeAt(0);
              return function(t9) {
                for (var e9 = [], o6 = 0; o6 < t9.length; o6 += 1) {
                  var i5 = t9.charCodeAt(o6);
                  if (i5 < 128)
                    e9.push(i5);
                  else {
                    var a5 = r8[t9.charAt(o6)];
                    "number" == typeof a5 ? (255 & a5) == a5 ? e9.push(a5) : (e9.push(a5 >>> 8), e9.push(255 & a5)) : e9.push(n7);
                  }
                }
                return e9;
              };
            };
            var e7, r7, n6, o5, i4, a4 = { L: 1, M: 0, Q: 3, H: 2 }, s4 = (e7 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], r7 = 1335, n6 = 7973, i4 = function(t8) {
              for (var e8 = 0; 0 != t8; )
                e8 += 1, t8 >>>= 1;
              return e8;
            }, (o5 = {}).getBCHTypeInfo = function(t8) {
              for (var e8 = t8 << 10; i4(e8) - i4(r7) >= 0; )
                e8 ^= r7 << i4(e8) - i4(r7);
              return 21522 ^ (t8 << 10 | e8);
            }, o5.getBCHTypeNumber = function(t8) {
              for (var e8 = t8 << 12; i4(e8) - i4(n6) >= 0; )
                e8 ^= n6 << i4(e8) - i4(n6);
              return t8 << 12 | e8;
            }, o5.getPatternPosition = function(t8) {
              return e7[t8 - 1];
            }, o5.getMaskFunction = function(t8) {
              switch (t8) {
                case 0:
                  return function(t9, e8) {
                    return (t9 + e8) % 2 == 0;
                  };
                case 1:
                  return function(t9, e8) {
                    return t9 % 2 == 0;
                  };
                case 2:
                  return function(t9, e8) {
                    return e8 % 3 == 0;
                  };
                case 3:
                  return function(t9, e8) {
                    return (t9 + e8) % 3 == 0;
                  };
                case 4:
                  return function(t9, e8) {
                    return (Math.floor(t9 / 2) + Math.floor(e8 / 3)) % 2 == 0;
                  };
                case 5:
                  return function(t9, e8) {
                    return t9 * e8 % 2 + t9 * e8 % 3 == 0;
                  };
                case 6:
                  return function(t9, e8) {
                    return (t9 * e8 % 2 + t9 * e8 % 3) % 2 == 0;
                  };
                case 7:
                  return function(t9, e8) {
                    return (t9 * e8 % 3 + (t9 + e8) % 2) % 2 == 0;
                  };
                default:
                  throw "bad maskPattern:" + t8;
              }
            }, o5.getErrorCorrectPolynomial = function(t8) {
              for (var e8 = u5([1], 0), r8 = 0; r8 < t8; r8 += 1)
                e8 = e8.multiply(u5([1, c4.gexp(r8)], 0));
              return e8;
            }, o5.getLengthInBits = function(t8, e8) {
              if (1 <= e8 && e8 < 10)
                switch (t8) {
                  case 1:
                    return 10;
                  case 2:
                    return 9;
                  case 4:
                  case 8:
                    return 8;
                  default:
                    throw "mode:" + t8;
                }
              else if (e8 < 27)
                switch (t8) {
                  case 1:
                    return 12;
                  case 2:
                    return 11;
                  case 4:
                    return 16;
                  case 8:
                    return 10;
                  default:
                    throw "mode:" + t8;
                }
              else {
                if (!(e8 < 41))
                  throw "type:" + e8;
                switch (t8) {
                  case 1:
                    return 14;
                  case 2:
                    return 13;
                  case 4:
                    return 16;
                  case 8:
                    return 12;
                  default:
                    throw "mode:" + t8;
                }
              }
            }, o5.getLostPoint = function(t8) {
              for (var e8 = t8.getModuleCount(), r8 = 0, n7 = 0; n7 < e8; n7 += 1)
                for (var o6 = 0; o6 < e8; o6 += 1) {
                  for (var i5 = 0, a5 = t8.isDark(n7, o6), s5 = -1; s5 <= 1; s5 += 1)
                    if (!(n7 + s5 < 0 || e8 <= n7 + s5))
                      for (var c5 = -1; c5 <= 1; c5 += 1)
                        o6 + c5 < 0 || e8 <= o6 + c5 || 0 == s5 && 0 == c5 || a5 == t8.isDark(n7 + s5, o6 + c5) && (i5 += 1);
                  i5 > 5 && (r8 += 3 + i5 - 5);
                }
              for (n7 = 0; n7 < e8 - 1; n7 += 1)
                for (o6 = 0; o6 < e8 - 1; o6 += 1) {
                  var u6 = 0;
                  t8.isDark(n7, o6) && (u6 += 1), t8.isDark(n7 + 1, o6) && (u6 += 1), t8.isDark(n7, o6 + 1) && (u6 += 1), t8.isDark(n7 + 1, o6 + 1) && (u6 += 1), 0 != u6 && 4 != u6 || (r8 += 3);
                }
              for (n7 = 0; n7 < e8; n7 += 1)
                for (o6 = 0; o6 < e8 - 6; o6 += 1)
                  t8.isDark(n7, o6) && !t8.isDark(n7, o6 + 1) && t8.isDark(n7, o6 + 2) && t8.isDark(n7, o6 + 3) && t8.isDark(n7, o6 + 4) && !t8.isDark(n7, o6 + 5) && t8.isDark(n7, o6 + 6) && (r8 += 40);
              for (o6 = 0; o6 < e8; o6 += 1)
                for (n7 = 0; n7 < e8 - 6; n7 += 1)
                  t8.isDark(n7, o6) && !t8.isDark(n7 + 1, o6) && t8.isDark(n7 + 2, o6) && t8.isDark(n7 + 3, o6) && t8.isDark(n7 + 4, o6) && !t8.isDark(n7 + 5, o6) && t8.isDark(n7 + 6, o6) && (r8 += 40);
              var h6 = 0;
              for (o6 = 0; o6 < e8; o6 += 1)
                for (n7 = 0; n7 < e8; n7 += 1)
                  t8.isDark(n7, o6) && (h6 += 1);
              return r8 + Math.abs(100 * h6 / e8 / e8 - 50) / 5 * 10;
            }, o5), c4 = function() {
              for (var t8 = new Array(256), e8 = new Array(256), r8 = 0; r8 < 8; r8 += 1)
                t8[r8] = 1 << r8;
              for (r8 = 8; r8 < 256; r8 += 1)
                t8[r8] = t8[r8 - 4] ^ t8[r8 - 5] ^ t8[r8 - 6] ^ t8[r8 - 8];
              for (r8 = 0; r8 < 255; r8 += 1)
                e8[t8[r8]] = r8;
              return { glog: function(t9) {
                if (t9 < 1)
                  throw "glog(" + t9 + ")";
                return e8[t9];
              }, gexp: function(e9) {
                for (; e9 < 0; )
                  e9 += 255;
                for (; e9 >= 256; )
                  e9 -= 255;
                return t8[e9];
              } };
            }();
            function u5(t8, e8) {
              if (void 0 === t8.length)
                throw t8.length + "/" + e8;
              var r8 = function() {
                for (var r9 = 0; r9 < t8.length && 0 == t8[r9]; )
                  r9 += 1;
                for (var n8 = new Array(t8.length - r9 + e8), o6 = 0; o6 < t8.length - r9; o6 += 1)
                  n8[o6] = t8[o6 + r9];
                return n8;
              }(), n7 = { getAt: function(t9) {
                return r8[t9];
              }, getLength: function() {
                return r8.length;
              }, multiply: function(t9) {
                for (var e9 = new Array(n7.getLength() + t9.getLength() - 1), r9 = 0; r9 < n7.getLength(); r9 += 1)
                  for (var o6 = 0; o6 < t9.getLength(); o6 += 1)
                    e9[r9 + o6] ^= c4.gexp(c4.glog(n7.getAt(r9)) + c4.glog(t9.getAt(o6)));
                return u5(e9, 0);
              }, mod: function(t9) {
                if (n7.getLength() - t9.getLength() < 0)
                  return n7;
                for (var e9 = c4.glog(n7.getAt(0)) - c4.glog(t9.getAt(0)), r9 = new Array(n7.getLength()), o6 = 0; o6 < n7.getLength(); o6 += 1)
                  r9[o6] = n7.getAt(o6);
                for (o6 = 0; o6 < t9.getLength(); o6 += 1)
                  r9[o6] ^= c4.gexp(c4.glog(t9.getAt(o6)) + e9);
                return u5(r9, 0).mod(t9);
              } };
              return n7;
            }
            var h5 = function() {
              var t8 = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], e8 = function(t9, e9) {
                var r9 = {};
                return r9.totalCount = t9, r9.dataCount = e9, r9;
              }, r8 = { getRSBlocks: function(r9, n7) {
                var o6 = function(e9, r10) {
                  switch (r10) {
                    case a4.L:
                      return t8[4 * (e9 - 1) + 0];
                    case a4.M:
                      return t8[4 * (e9 - 1) + 1];
                    case a4.Q:
                      return t8[4 * (e9 - 1) + 2];
                    case a4.H:
                      return t8[4 * (e9 - 1) + 3];
                    default:
                      return;
                  }
                }(r9, n7);
                if (void 0 === o6)
                  throw "bad rs block @ typeNumber:" + r9 + "/errorCorrectionLevel:" + n7;
                for (var i5 = o6.length / 3, s5 = [], c5 = 0; c5 < i5; c5 += 1)
                  for (var u6 = o6[3 * c5 + 0], h6 = o6[3 * c5 + 1], d5 = o6[3 * c5 + 2], l6 = 0; l6 < u6; l6 += 1)
                    s5.push(e8(h6, d5));
                return s5;
              } };
              return r8;
            }(), d4 = function() {
              var t8 = [], e8 = 0, r8 = { getBuffer: function() {
                return t8;
              }, getAt: function(e9) {
                var r9 = Math.floor(e9 / 8);
                return 1 == (t8[r9] >>> 7 - e9 % 8 & 1);
              }, put: function(t9, e9) {
                for (var n7 = 0; n7 < e9; n7 += 1)
                  r8.putBit(1 == (t9 >>> e9 - n7 - 1 & 1));
              }, getLengthInBits: function() {
                return e8;
              }, putBit: function(r9) {
                var n7 = Math.floor(e8 / 8);
                t8.length <= n7 && t8.push(0), r9 && (t8[n7] |= 128 >>> e8 % 8), e8 += 1;
              } };
              return r8;
            }, l5 = function(t8) {
              var e8 = t8, r8 = { getMode: function() {
                return 1;
              }, getLength: function(t9) {
                return e8.length;
              }, write: function(t9) {
                for (var r9 = e8, o7 = 0; o7 + 2 < r9.length; )
                  t9.put(n7(r9.substring(o7, o7 + 3)), 10), o7 += 3;
                o7 < r9.length && (r9.length - o7 == 1 ? t9.put(n7(r9.substring(o7, o7 + 1)), 4) : r9.length - o7 == 2 && t9.put(n7(r9.substring(o7, o7 + 2)), 7));
              } }, n7 = function(t9) {
                for (var e9 = 0, r9 = 0; r9 < t9.length; r9 += 1)
                  e9 = 10 * e9 + o6(t9.charAt(r9));
                return e9;
              }, o6 = function(t9) {
                if ("0" <= t9 && t9 <= "9")
                  return t9.charCodeAt(0) - "0".charCodeAt(0);
                throw "illegal char :" + t9;
              };
              return r8;
            }, f5 = function(t8) {
              var e8 = t8, r8 = { getMode: function() {
                return 2;
              }, getLength: function(t9) {
                return e8.length;
              }, write: function(t9) {
                for (var r9 = e8, o6 = 0; o6 + 1 < r9.length; )
                  t9.put(45 * n7(r9.charAt(o6)) + n7(r9.charAt(o6 + 1)), 11), o6 += 2;
                o6 < r9.length && t9.put(n7(r9.charAt(o6)), 6);
              } }, n7 = function(t9) {
                if ("0" <= t9 && t9 <= "9")
                  return t9.charCodeAt(0) - "0".charCodeAt(0);
                if ("A" <= t9 && t9 <= "Z")
                  return t9.charCodeAt(0) - "A".charCodeAt(0) + 10;
                switch (t9) {
                  case " ":
                    return 36;
                  case "$":
                    return 37;
                  case "%":
                    return 38;
                  case "*":
                    return 39;
                  case "+":
                    return 40;
                  case "-":
                    return 41;
                  case ".":
                    return 42;
                  case "/":
                    return 43;
                  case ":":
                    return 44;
                  default:
                    throw "illegal char :" + t9;
                }
              };
              return r8;
            }, p5 = function(e8) {
              var r8 = t7.stringToBytes(e8);
              return { getMode: function() {
                return 4;
              }, getLength: function(t8) {
                return r8.length;
              }, write: function(t8) {
                for (var e9 = 0; e9 < r8.length; e9 += 1)
                  t8.put(r8[e9], 8);
              } };
            }, g4 = function(e8) {
              var r8 = t7.stringToBytesFuncs.SJIS;
              if (!r8)
                throw "sjis not supported.";
              !function(t8, e9) {
                var n8 = r8("\u53CB");
                if (2 != n8.length || 38726 != (n8[0] << 8 | n8[1]))
                  throw "sjis not supported.";
              }();
              var n7 = r8(e8), o6 = { getMode: function() {
                return 8;
              }, getLength: function(t8) {
                return ~~(n7.length / 2);
              }, write: function(t8) {
                for (var e9 = n7, r9 = 0; r9 + 1 < e9.length; ) {
                  var o7 = (255 & e9[r9]) << 8 | 255 & e9[r9 + 1];
                  if (33088 <= o7 && o7 <= 40956)
                    o7 -= 33088;
                  else {
                    if (!(57408 <= o7 && o7 <= 60351))
                      throw "illegal char at " + (r9 + 1) + "/" + o7;
                    o7 -= 49472;
                  }
                  o7 = 192 * (o7 >>> 8 & 255) + (255 & o7), t8.put(o7, 13), r9 += 2;
                }
                if (r9 < e9.length)
                  throw "illegal char at " + (r9 + 1);
              } };
              return o6;
            }, v5 = function() {
              var t8 = [], e8 = { writeByte: function(e9) {
                t8.push(255 & e9);
              }, writeShort: function(t9) {
                e8.writeByte(t9), e8.writeByte(t9 >>> 8);
              }, writeBytes: function(t9, r8, n7) {
                r8 = r8 || 0, n7 = n7 || t9.length;
                for (var o6 = 0; o6 < n7; o6 += 1)
                  e8.writeByte(t9[o6 + r8]);
              }, writeString: function(t9) {
                for (var r8 = 0; r8 < t9.length; r8 += 1)
                  e8.writeByte(t9.charCodeAt(r8));
              }, toByteArray: function() {
                return t8;
              }, toString: function() {
                var e9 = "";
                e9 += "[";
                for (var r8 = 0; r8 < t8.length; r8 += 1)
                  r8 > 0 && (e9 += ","), e9 += t8[r8];
                return e9 + "]";
              } };
              return e8;
            }, y5 = function(t8) {
              var e8 = t8, r8 = 0, n7 = 0, o6 = 0, i5 = { read: function() {
                for (; o6 < 8; ) {
                  if (r8 >= e8.length) {
                    if (0 == o6)
                      return -1;
                    throw "unexpected end of file./" + o6;
                  }
                  var t9 = e8.charAt(r8);
                  if (r8 += 1, "=" == t9)
                    return o6 = 0, -1;
                  t9.match(/^\s$/) || (n7 = n7 << 6 | a5(t9.charCodeAt(0)), o6 += 6);
                }
                var i6 = n7 >>> o6 - 8 & 255;
                return o6 -= 8, i6;
              } }, a5 = function(t9) {
                if (65 <= t9 && t9 <= 90)
                  return t9 - 65;
                if (97 <= t9 && t9 <= 122)
                  return t9 - 97 + 26;
                if (48 <= t9 && t9 <= 57)
                  return t9 - 48 + 52;
                if (43 == t9)
                  return 62;
                if (47 == t9)
                  return 63;
                throw "c:" + t9;
              };
              return i5;
            }, w6 = function(t8, e8, r8) {
              for (var n7 = function(t9, e9) {
                var r9 = t9, n8 = e9, o7 = new Array(t9 * e9), i6 = { setPixel: function(t10, e10, n9) {
                  o7[e10 * r9 + t10] = n9;
                }, write: function(t10) {
                  t10.writeString("GIF87a"), t10.writeShort(r9), t10.writeShort(n8), t10.writeByte(128), t10.writeByte(0), t10.writeByte(0), t10.writeByte(0), t10.writeByte(0), t10.writeByte(0), t10.writeByte(255), t10.writeByte(255), t10.writeByte(255), t10.writeString(","), t10.writeShort(0), t10.writeShort(0), t10.writeShort(r9), t10.writeShort(n8), t10.writeByte(0);
                  var e10 = a6(2);
                  t10.writeByte(2);
                  for (var o8 = 0; e10.length - o8 > 255; )
                    t10.writeByte(255), t10.writeBytes(e10, o8, 255), o8 += 255;
                  t10.writeByte(e10.length - o8), t10.writeBytes(e10, o8, e10.length - o8), t10.writeByte(0), t10.writeString(";");
                } }, a6 = function(t10) {
                  for (var e10 = 1 << t10, r10 = 1 + (1 << t10), n9 = t10 + 1, i7 = s6(), a7 = 0; a7 < e10; a7 += 1)
                    i7.add(String.fromCharCode(a7));
                  i7.add(String.fromCharCode(e10)), i7.add(String.fromCharCode(r10));
                  var c6, u7, h6, d5 = v5(), l6 = (c6 = d5, u7 = 0, h6 = 0, { write: function(t11, e11) {
                    if (t11 >>> e11 != 0)
                      throw "length over";
                    for (; u7 + e11 >= 8; )
                      c6.writeByte(255 & (t11 << u7 | h6)), e11 -= 8 - u7, t11 >>>= 8 - u7, h6 = 0, u7 = 0;
                    h6 |= t11 << u7, u7 += e11;
                  }, flush: function() {
                    u7 > 0 && c6.writeByte(h6);
                  } });
                  l6.write(e10, n9);
                  var f6 = 0, p6 = String.fromCharCode(o7[f6]);
                  for (f6 += 1; f6 < o7.length; ) {
                    var g5 = String.fromCharCode(o7[f6]);
                    f6 += 1, i7.contains(p6 + g5) ? p6 += g5 : (l6.write(i7.indexOf(p6), n9), i7.size() < 4095 && (i7.size() == 1 << n9 && (n9 += 1), i7.add(p6 + g5)), p6 = g5);
                  }
                  return l6.write(i7.indexOf(p6), n9), l6.write(r10, n9), l6.flush(), d5.toByteArray();
                }, s6 = function() {
                  var t10 = {}, e10 = 0, r10 = { add: function(n9) {
                    if (r10.contains(n9))
                      throw "dup key:" + n9;
                    t10[n9] = e10, e10 += 1;
                  }, size: function() {
                    return e10;
                  }, indexOf: function(e11) {
                    return t10[e11];
                  }, contains: function(e11) {
                    return void 0 !== t10[e11];
                  } };
                  return r10;
                };
                return i6;
              }(t8, e8), o6 = 0; o6 < e8; o6 += 1)
                for (var i5 = 0; i5 < t8; i5 += 1)
                  n7.setPixel(i5, o6, r8(i5, o6));
              var a5 = v5();
              n7.write(a5);
              for (var s5 = function() {
                var t9 = 0, e9 = 0, r9 = 0, n8 = "", o7 = {}, i6 = function(t10) {
                  n8 += String.fromCharCode(a6(63 & t10));
                }, a6 = function(t10) {
                  if (t10 < 0)
                    ;
                  else {
                    if (t10 < 26)
                      return 65 + t10;
                    if (t10 < 52)
                      return t10 - 26 + 97;
                    if (t10 < 62)
                      return t10 - 52 + 48;
                    if (62 == t10)
                      return 43;
                    if (63 == t10)
                      return 47;
                  }
                  throw "n:" + t10;
                };
                return o7.writeByte = function(n9) {
                  for (t9 = t9 << 8 | 255 & n9, e9 += 8, r9 += 1; e9 >= 6; )
                    i6(t9 >>> e9 - 6), e9 -= 6;
                }, o7.flush = function() {
                  if (e9 > 0 && (i6(t9 << 6 - e9), t9 = 0, e9 = 0), r9 % 3 != 0)
                    for (var o8 = 3 - r9 % 3, a7 = 0; a7 < o8; a7 += 1)
                      n8 += "=";
                }, o7.toString = function() {
                  return n8;
                }, o7;
              }(), c5 = a5.toByteArray(), u6 = 0; u6 < c5.length; u6 += 1)
                s5.writeByte(c5[u6]);
              return s5.flush(), "data:image/gif;base64," + s5;
            };
            return t7;
          }();
          o4.stringToBytesFuncs["UTF-8"] = function(t7) {
            return function(t8) {
              for (var e7 = [], r7 = 0; r7 < t8.length; r7++) {
                var n6 = t8.charCodeAt(r7);
                n6 < 128 ? e7.push(n6) : n6 < 2048 ? e7.push(192 | n6 >> 6, 128 | 63 & n6) : n6 < 55296 || n6 >= 57344 ? e7.push(224 | n6 >> 12, 128 | n6 >> 6 & 63, 128 | 63 & n6) : (r7++, n6 = 65536 + ((1023 & n6) << 10 | 1023 & t8.charCodeAt(r7)), e7.push(240 | n6 >> 18, 128 | n6 >> 12 & 63, 128 | n6 >> 6 & 63, 128 | 63 & n6));
              }
              return e7;
            }(t7);
          }, void 0 === (n5 = "function" == typeof (r6 = function() {
            return o4;
          }) ? r6.apply(e6, []) : r6) || (t6.exports = n5);
        } }, e5 = {};
        function r5(n5) {
          var o4 = e5[n5];
          if (void 0 !== o4)
            return o4.exports;
          var i4 = e5[n5] = { exports: {} };
          return t5[n5](i4, i4.exports, r5), i4.exports;
        }
        r5.n = (t6) => {
          var e6 = t6 && t6.__esModule ? () => t6.default : () => t6;
          return r5.d(e6, { a: e6 }), e6;
        }, r5.d = (t6, e6) => {
          for (var n5 in e6)
            r5.o(e6, n5) && !r5.o(t6, n5) && Object.defineProperty(t6, n5, { enumerable: true, get: e6[n5] });
        }, r5.o = (t6, e6) => Object.prototype.hasOwnProperty.call(t6, e6);
        var n4 = {};
        return (() => {
          "use strict";
          r5.d(n4, { default: () => V3 });
          var t6 = function() {
            return t6 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, t6.apply(this, arguments);
          }, e6 = function(t7, e7, r6) {
            if (r6 || 2 === arguments.length)
              for (var n5, o5 = 0, i5 = e7.length; o5 < i5; o5++)
                !n5 && o5 in e7 || (n5 || (n5 = Array.prototype.slice.call(e7, 0, o5)), n5[o5] = e7[o5]);
            return t7.concat(n5 || Array.prototype.slice.call(e7));
          }, o4 = function(t7) {
            return !!t7 && "object" == typeof t7 && !Array.isArray(t7);
          };
          function i4(r6) {
            for (var n5 = [], a5 = 1; a5 < arguments.length; a5++)
              n5[a5 - 1] = arguments[a5];
            if (!n5.length)
              return r6;
            var s5 = n5.shift();
            return void 0 !== s5 && o4(r6) && o4(s5) ? (r6 = t6({}, r6), Object.keys(s5).forEach(function(t7) {
              var e7 = r6[t7], n6 = s5[t7];
              Array.isArray(e7) && Array.isArray(n6) ? r6[t7] = n6 : o4(e7) && o4(n6) ? r6[t7] = i4(Object.assign({}, e7), n6) : r6[t7] = n6;
            }), i4.apply(void 0, e6([r6], n5, false))) : r6;
          }
          function a4(t7, e7) {
            var r6 = document.createElement("a");
            r6.download = e7, r6.href = t7, document.body.appendChild(r6), r6.click(), document.body.removeChild(r6);
          }
          function s4(t7) {
            var e7 = t7.originalHeight, r6 = t7.originalWidth, n5 = t7.maxHiddenDots, o5 = t7.maxHiddenAxisDots, i5 = t7.dotSize, a5 = { x: 0, y: 0 }, s5 = { x: 0, y: 0 };
            if (e7 <= 0 || r6 <= 0 || n5 <= 0 || i5 <= 0)
              return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
            var c5 = e7 / r6;
            return a5.x = Math.floor(Math.sqrt(n5 / c5)), a5.x <= 0 && (a5.x = 1), o5 && o5 < a5.x && (a5.x = o5), a5.x % 2 == 0 && a5.x--, s5.x = a5.x * i5, a5.y = 1 + 2 * Math.ceil((a5.x * c5 - 1) / 2), s5.y = Math.round(s5.x * c5), (a5.y * a5.x > n5 || o5 && o5 < a5.y) && (o5 && o5 < a5.y ? (a5.y = o5, a5.y % 2 == 0 && a5.x--) : a5.y -= 2, s5.y = a5.y * i5, a5.x = 1 + 2 * Math.ceil((a5.y / c5 - 1) / 2), s5.x = Math.round(s5.y / c5)), { height: s5.y, width: s5.x, hideYDots: a5.y, hideXDots: a5.x };
          }
          const c4 = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 }, u5 = "dots", h5 = "rounded", d4 = "classy", l5 = "classy-rounded", f5 = "extra-rounded";
          var p5 = function() {
            return p5 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, p5.apply(this, arguments);
          }, g4 = function() {
            function t7(t8) {
              var e7 = t8.context, r6 = t8.type;
              this._context = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              var o5, i5 = this._context;
              switch (this._type) {
                case u5:
                  o5 = this._drawDot;
                  break;
                case d4:
                  o5 = this._drawClassy;
                  break;
                case l5:
                  o5 = this._drawClassyRounded;
                  break;
                case h5:
                  o5 = this._drawRounded;
                  break;
                case f5:
                  o5 = this._drawExtraRounded;
                  break;
                default:
                  o5 = this._drawSquare;
              }
              o5.call(this, { x: t8, y: e7, size: r6, context: i5, getNeighbor: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = t8.draw, c5 = e7 + n5 / 2, u6 = r6 + n5 / 2;
              o5.translate(c5, u6), a5 && o5.rotate(a5), s5(), o5.closePath(), a5 && o5.rotate(-a5), o5.translate(-c5, -u6);
            }, t7.prototype._basicDot = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, 0, 2 * Math.PI);
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.rect(-e7 / 2, -e7 / 2, e7, e7);
              } }));
            }, t7.prototype._basicSideRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, -Math.PI / 2, Math.PI / 2), r6.lineTo(-e7 / 2, e7 / 2), r6.lineTo(-e7 / 2, -e7 / 2), r6.lineTo(0, -e7 / 2);
              } }));
            }, t7.prototype._basicCornerRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, -Math.PI / 2, 0), r6.lineTo(e7 / 2, e7 / 2), r6.lineTo(-e7 / 2, e7 / 2), r6.lineTo(-e7 / 2, -e7 / 2), r6.lineTo(0, -e7 / 2);
              } }));
            }, t7.prototype._basicCornerExtraRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(-e7 / 2, e7 / 2, e7, -Math.PI / 2, 0), r6.lineTo(-e7 / 2, e7 / 2), r6.lineTo(-e7 / 2, -e7 / 2);
              } }));
            }, t7.prototype._basicCornersRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, -Math.PI / 2, 0), r6.lineTo(e7 / 2, e7 / 2), r6.lineTo(0, e7 / 2), r6.arc(0, 0, e7 / 2, Math.PI / 2, Math.PI), r6.lineTo(-e7 / 2, -e7 / 2), r6.lineTo(0, -e7 / 2);
              } }));
            }, t7.prototype._basicCornersExtraRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(p5(p5({}, t8), { draw: function() {
                r6.arc(-e7 / 2, e7 / 2, e7, -Math.PI / 2, 0), r6.arc(e7 / 2, -e7 / 2, e7, Math.PI / 2, Math.PI);
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context;
              this._basicDot({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context;
              this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
            }, t7.prototype._drawRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.getNeighbor, a5 = i5 ? +i5(-1, 0) : 0, s5 = i5 ? +i5(1, 0) : 0, c5 = i5 ? +i5(0, -1) : 0, u6 = i5 ? +i5(0, 1) : 0, h6 = a5 + s5 + c5 + u6;
              if (0 !== h6)
                if (h6 > 2 || a5 && s5 || c5 && u6)
                  this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
                else {
                  if (2 === h6) {
                    var d5 = 0;
                    return a5 && c5 ? d5 = Math.PI / 2 : c5 && s5 ? d5 = Math.PI : s5 && u6 && (d5 = -Math.PI / 2), void this._basicCornerRounded({ x: e7, y: r6, size: n5, context: o5, rotation: d5 });
                  }
                  if (1 === h6)
                    return d5 = 0, c5 ? d5 = Math.PI / 2 : s5 ? d5 = Math.PI : u6 && (d5 = -Math.PI / 2), void this._basicSideRounded({ x: e7, y: r6, size: n5, context: o5, rotation: d5 });
                }
              else
                this._basicDot({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
            }, t7.prototype._drawExtraRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.getNeighbor, a5 = i5 ? +i5(-1, 0) : 0, s5 = i5 ? +i5(1, 0) : 0, c5 = i5 ? +i5(0, -1) : 0, u6 = i5 ? +i5(0, 1) : 0, h6 = a5 + s5 + c5 + u6;
              if (0 !== h6)
                if (h6 > 2 || a5 && s5 || c5 && u6)
                  this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
                else {
                  if (2 === h6) {
                    var d5 = 0;
                    return a5 && c5 ? d5 = Math.PI / 2 : c5 && s5 ? d5 = Math.PI : s5 && u6 && (d5 = -Math.PI / 2), void this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, context: o5, rotation: d5 });
                  }
                  if (1 === h6)
                    return d5 = 0, c5 ? d5 = Math.PI / 2 : s5 ? d5 = Math.PI : u6 && (d5 = -Math.PI / 2), void this._basicSideRounded({ x: e7, y: r6, size: n5, context: o5, rotation: d5 });
                }
              else
                this._basicDot({ x: e7, y: r6, size: n5, context: o5, rotation: 0 });
            }, t7.prototype._drawClassy = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.getNeighbor, a5 = i5 ? +i5(-1, 0) : 0, s5 = i5 ? +i5(1, 0) : 0, c5 = i5 ? +i5(0, -1) : 0, u6 = i5 ? +i5(0, 1) : 0;
              0 !== a5 + s5 + c5 + u6 ? a5 || c5 ? s5 || u6 ? this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: 0 }) : this._basicCornerRounded({ x: e7, y: r6, size: n5, context: o5, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: e7, y: r6, size: n5, context: o5, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e7, y: r6, size: n5, context: o5, rotation: Math.PI / 2 });
            }, t7.prototype._drawClassyRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.getNeighbor, a5 = i5 ? +i5(-1, 0) : 0, s5 = i5 ? +i5(1, 0) : 0, c5 = i5 ? +i5(0, -1) : 0, u6 = i5 ? +i5(0, 1) : 0;
              0 !== a5 + s5 + c5 + u6 ? a5 || c5 ? s5 || u6 ? this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: 0 }) : this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, context: o5, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, context: o5, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e7, y: r6, size: n5, context: o5, rotation: Math.PI / 2 });
            }, t7;
          }();
          const v5 = g4, y5 = "square", w6 = "extra-rounded";
          var _5 = function() {
            return _5 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, _5.apply(this, arguments);
          }, m5 = function() {
            function t7(t8) {
              var e7 = t8.context, r6 = t8.type;
              this._context = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              var o5, i5 = this._context;
              switch (this._type) {
                case y5:
                  o5 = this._drawSquare;
                  break;
                case w6:
                  o5 = this._drawExtraRounded;
                  break;
                default:
                  o5 = this._drawDot;
              }
              o5.call(this, { x: t8, y: e7, size: r6, context: i5, rotation: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = t8.draw, c5 = e7 + n5 / 2, u6 = r6 + n5 / 2;
              o5.translate(c5, u6), a5 && o5.rotate(a5), s5(), o5.closePath(), a5 && o5.rotate(-a5), o5.translate(-c5, -u6);
            }, t7.prototype._basicDot = function(t8) {
              var e7 = t8.size, r6 = t8.context, n5 = e7 / 7;
              this._rotateFigure(_5(_5({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, 0, 2 * Math.PI), r6.arc(0, 0, e7 / 2 - n5, 0, 2 * Math.PI);
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = t8.size, r6 = t8.context, n5 = e7 / 7;
              this._rotateFigure(_5(_5({}, t8), { draw: function() {
                r6.rect(-e7 / 2, -e7 / 2, e7, e7), r6.rect(-e7 / 2 + n5, -e7 / 2 + n5, e7 - 2 * n5, e7 - 2 * n5);
              } }));
            }, t7.prototype._basicExtraRounded = function(t8) {
              var e7 = t8.size, r6 = t8.context, n5 = e7 / 7;
              this._rotateFigure(_5(_5({}, t8), { draw: function() {
                r6.arc(-n5, -n5, 2.5 * n5, Math.PI, -Math.PI / 2), r6.lineTo(n5, -3.5 * n5), r6.arc(n5, -n5, 2.5 * n5, -Math.PI / 2, 0), r6.lineTo(3.5 * n5, -n5), r6.arc(n5, n5, 2.5 * n5, 0, Math.PI / 2), r6.lineTo(-n5, 3.5 * n5), r6.arc(-n5, n5, 2.5 * n5, Math.PI / 2, Math.PI), r6.lineTo(-3.5 * n5, -n5), r6.arc(-n5, -n5, 1.5 * n5, Math.PI, -Math.PI / 2), r6.lineTo(n5, -2.5 * n5), r6.arc(n5, -n5, 1.5 * n5, -Math.PI / 2, 0), r6.lineTo(2.5 * n5, -n5), r6.arc(n5, n5, 1.5 * n5, 0, Math.PI / 2), r6.lineTo(-n5, 2.5 * n5), r6.arc(-n5, n5, 1.5 * n5, Math.PI / 2, Math.PI), r6.lineTo(-2.5 * n5, -n5);
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation;
              this._basicDot({ x: e7, y: r6, size: n5, context: o5, rotation: i5 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation;
              this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: i5 });
            }, t7.prototype._drawExtraRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation;
              this._basicExtraRounded({ x: e7, y: r6, size: n5, context: o5, rotation: i5 });
            }, t7;
          }();
          const b3 = m5, x5 = "square";
          var M4 = function() {
            return M4 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, M4.apply(this, arguments);
          }, S3 = function() {
            function t7(t8) {
              var e7 = t8.context, r6 = t8.type;
              this._context = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              var o5 = this._context;
              (this._type === x5 ? this._drawSquare : this._drawDot).call(this, { x: t8, y: e7, size: r6, context: o5, rotation: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = t8.draw, c5 = e7 + n5 / 2, u6 = r6 + n5 / 2;
              o5.translate(c5, u6), a5 && o5.rotate(a5), s5(), o5.closePath(), a5 && o5.rotate(-a5), o5.translate(-c5, -u6);
            }, t7.prototype._basicDot = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(M4(M4({}, t8), { draw: function() {
                r6.arc(0, 0, e7 / 2, 0, 2 * Math.PI);
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = t8.size, r6 = t8.context;
              this._rotateFigure(M4(M4({}, t8), { draw: function() {
                r6.rect(-e7 / 2, -e7 / 2, e7, e7);
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation;
              this._basicDot({ x: e7, y: r6, size: n5, context: o5, rotation: i5 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.context, i5 = t8.rotation;
              this._basicSquare({ x: e7, y: r6, size: n5, context: o5, rotation: i5 });
            }, t7;
          }();
          const C4 = S3, P4 = "radial";
          var O4 = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], z4 = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
          const D4 = function() {
            function t7(t8) {
              this._canvas = document.createElement("canvas"), this._canvas.width = t8.width, this._canvas.height = t8.height, this._options = t8;
            }
            return Object.defineProperty(t7.prototype, "context", { get: function() {
              return this._canvas.getContext("2d");
            }, enumerable: false, configurable: true }), Object.defineProperty(t7.prototype, "width", { get: function() {
              return this._canvas.width;
            }, enumerable: false, configurable: true }), Object.defineProperty(t7.prototype, "height", { get: function() {
              return this._canvas.height;
            }, enumerable: false, configurable: true }), t7.prototype.getCanvas = function() {
              return this._canvas;
            }, t7.prototype.clear = function() {
              var t8 = this.context;
              t8 && t8.clearRect(0, 0, this._canvas.width, this._canvas.height);
            }, t7.prototype.drawQR = function(t8) {
              return e7 = this, r6 = void 0, o5 = function() {
                var e8, r7, n6, o6, i5, a5, u6, h6, d5, l6 = this;
                return function(t9, e9) {
                  var r8, n7, o7, i6, a6 = { label: 0, sent: function() {
                    if (1 & o7[0])
                      throw o7[1];
                    return o7[1];
                  }, trys: [], ops: [] };
                  return i6 = { next: s5(0), throw: s5(1), return: s5(2) }, "function" == typeof Symbol && (i6[Symbol.iterator] = function() {
                    return this;
                  }), i6;
                  function s5(i7) {
                    return function(s6) {
                      return function(i8) {
                        if (r8)
                          throw new TypeError("Generator is already executing.");
                        for (; a6; )
                          try {
                            if (r8 = 1, n7 && (o7 = 2 & i8[0] ? n7.return : i8[0] ? n7.throw || ((o7 = n7.return) && o7.call(n7), 0) : n7.next) && !(o7 = o7.call(n7, i8[1])).done)
                              return o7;
                            switch (n7 = 0, o7 && (i8 = [2 & i8[0], o7.value]), i8[0]) {
                              case 0:
                              case 1:
                                o7 = i8;
                                break;
                              case 4:
                                return a6.label++, { value: i8[1], done: false };
                              case 5:
                                a6.label++, n7 = i8[1], i8 = [0];
                                continue;
                              case 7:
                                i8 = a6.ops.pop(), a6.trys.pop();
                                continue;
                              default:
                                if (!((o7 = (o7 = a6.trys).length > 0 && o7[o7.length - 1]) || 6 !== i8[0] && 2 !== i8[0])) {
                                  a6 = 0;
                                  continue;
                                }
                                if (3 === i8[0] && (!o7 || i8[1] > o7[0] && i8[1] < o7[3])) {
                                  a6.label = i8[1];
                                  break;
                                }
                                if (6 === i8[0] && a6.label < o7[1]) {
                                  a6.label = o7[1], o7 = i8;
                                  break;
                                }
                                if (o7 && a6.label < o7[2]) {
                                  a6.label = o7[2], a6.ops.push(i8);
                                  break;
                                }
                                o7[2] && a6.ops.pop(), a6.trys.pop();
                                continue;
                            }
                            i8 = e9.call(t9, a6);
                          } catch (t10) {
                            i8 = [6, t10], n7 = 0;
                          } finally {
                            r8 = o7 = 0;
                          }
                        if (5 & i8[0])
                          throw i8[1];
                        return { value: i8[0] ? i8[1] : void 0, done: true };
                      }([i7, s6]);
                    };
                  }
                }(this, function(f6) {
                  switch (f6.label) {
                    case 0:
                      return e8 = t8.getModuleCount(), r7 = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, n6 = Math.floor(r7 / e8), o6 = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }, this._qr = t8, this._options.image ? [4, this.loadImage()] : [3, 2];
                    case 1:
                      if (f6.sent(), !this._image)
                        return [2];
                      i5 = this._options, a5 = i5.imageOptions, u6 = i5.qrOptions, h6 = a5.imageSize * c4[u6.errorCorrectionLevel], d5 = Math.floor(h6 * e8 * e8), o6 = s4({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: d5, maxHiddenAxisDots: e8 - 14, dotSize: n6 }), f6.label = 2;
                    case 2:
                      return this.clear(), this.drawBackground(), this.drawDots(function(t9, r8) {
                        var n7, i6, a6, s5, c5, u7;
                        return !(l6._options.imageOptions.hideBackgroundDots && t9 >= (e8 - o6.hideXDots) / 2 && t9 < (e8 + o6.hideXDots) / 2 && r8 >= (e8 - o6.hideYDots) / 2 && r8 < (e8 + o6.hideYDots) / 2 || (null === (n7 = O4[t9]) || void 0 === n7 ? void 0 : n7[r8]) || (null === (i6 = O4[t9 - e8 + 7]) || void 0 === i6 ? void 0 : i6[r8]) || (null === (a6 = O4[t9]) || void 0 === a6 ? void 0 : a6[r8 - e8 + 7]) || (null === (s5 = z4[t9]) || void 0 === s5 ? void 0 : s5[r8]) || (null === (c5 = z4[t9 - e8 + 7]) || void 0 === c5 ? void 0 : c5[r8]) || (null === (u7 = z4[t9]) || void 0 === u7 ? void 0 : u7[r8 - e8 + 7]));
                      }), this.drawCorners(), this._options.image && this.drawImage({ width: o6.width, height: o6.height, count: e8, dotSize: n6 }), [2];
                  }
                });
              }, new ((n5 = void 0) || (n5 = Promise))(function(t9, i5) {
                function a5(t10) {
                  try {
                    c5(o5.next(t10));
                  } catch (t11) {
                    i5(t11);
                  }
                }
                function s5(t10) {
                  try {
                    c5(o5.throw(t10));
                  } catch (t11) {
                    i5(t11);
                  }
                }
                function c5(e8) {
                  var r7;
                  e8.done ? t9(e8.value) : (r7 = e8.value, r7 instanceof n5 ? r7 : new n5(function(t10) {
                    t10(r7);
                  })).then(a5, s5);
                }
                c5((o5 = o5.apply(e7, r6 || [])).next());
              });
              var e7, r6, n5, o5;
            }, t7.prototype.drawBackground = function() {
              var t8 = this.context, e7 = this._options;
              if (t8) {
                if (e7.backgroundOptions.gradient) {
                  var r6 = e7.backgroundOptions.gradient, n5 = this._createGradient({ context: t8, options: r6, additionalRotation: 0, x: 0, y: 0, size: this._canvas.width > this._canvas.height ? this._canvas.width : this._canvas.height });
                  r6.colorStops.forEach(function(t9) {
                    var e8 = t9.offset, r7 = t9.color;
                    n5.addColorStop(e8, r7);
                  }), t8.fillStyle = n5;
                } else
                  e7.backgroundOptions.color && (t8.fillStyle = e7.backgroundOptions.color);
                t8.fillRect(0, 0, this._canvas.width, this._canvas.height);
              }
            }, t7.prototype.drawDots = function(t8) {
              var e7 = this;
              if (!this._qr)
                throw "QR code is not defined";
              var r6 = this.context;
              if (!r6)
                throw "QR code is not defined";
              var n5 = this._options, o5 = this._qr.getModuleCount();
              if (o5 > n5.width || o5 > n5.height)
                throw "The canvas is too small.";
              var i5 = Math.min(n5.width, n5.height) - 2 * n5.margin, a5 = Math.floor(i5 / o5), s5 = Math.floor((n5.width - o5 * a5) / 2), c5 = Math.floor((n5.height - o5 * a5) / 2), u6 = new v5({ context: r6, type: n5.dotsOptions.type });
              r6.beginPath();
              for (var h6 = function(r7) {
                for (var n6 = function(n7) {
                  return t8 && !t8(r7, n7) ? "continue" : d5._qr.isDark(r7, n7) ? void u6.draw(s5 + r7 * a5, c5 + n7 * a5, a5, function(i7, a6) {
                    return !(r7 + i7 < 0 || n7 + a6 < 0 || r7 + i7 >= o5 || n7 + a6 >= o5) && !(t8 && !t8(r7 + i7, n7 + a6)) && !!e7._qr && e7._qr.isDark(r7 + i7, n7 + a6);
                  }) : "continue";
                }, i6 = 0; i6 < o5; i6++)
                  n6(i6);
              }, d5 = this, l6 = 0; l6 < o5; l6++)
                h6(l6);
              if (n5.dotsOptions.gradient) {
                var f6 = n5.dotsOptions.gradient, p6 = this._createGradient({ context: r6, options: f6, additionalRotation: 0, x: s5, y: c5, size: o5 * a5 });
                f6.colorStops.forEach(function(t9) {
                  var e8 = t9.offset, r7 = t9.color;
                  p6.addColorStop(e8, r7);
                }), r6.fillStyle = r6.strokeStyle = p6;
              } else
                n5.dotsOptions.color && (r6.fillStyle = r6.strokeStyle = n5.dotsOptions.color);
              r6.fill("evenodd");
            }, t7.prototype.drawCorners = function(t8) {
              var e7 = this;
              if (!this._qr)
                throw "QR code is not defined";
              var r6 = this.context;
              if (!r6)
                throw "QR code is not defined";
              var n5 = this._options, o5 = this._qr.getModuleCount(), i5 = Math.min(n5.width, n5.height) - 2 * n5.margin, a5 = Math.floor(i5 / o5), s5 = 7 * a5, c5 = 3 * a5, u6 = Math.floor((n5.width - o5 * a5) / 2), h6 = Math.floor((n5.height - o5 * a5) / 2);
              [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(function(i6) {
                var d5, l6, f6, p6, g5, y6, w7, _6, m6, x6, M5 = i6[0], S4 = i6[1], P5 = i6[2];
                if (!t8 || t8(M5, S4)) {
                  var D5 = u6 + M5 * a5 * (o5 - 7), A6 = h6 + S4 * a5 * (o5 - 7);
                  if (null === (d5 = n5.cornersSquareOptions) || void 0 === d5 ? void 0 : d5.type) {
                    var I5 = new b3({ context: r6, type: null === (l6 = n5.cornersSquareOptions) || void 0 === l6 ? void 0 : l6.type });
                    r6.beginPath(), I5.draw(D5, A6, s5, P5);
                  } else {
                    var k6 = new v5({ context: r6, type: n5.dotsOptions.type });
                    r6.beginPath();
                    for (var q6 = function(t9) {
                      for (var e8 = function(e9) {
                        if (!(null === (f6 = O4[t9]) || void 0 === f6 ? void 0 : f6[e9]))
                          return "continue";
                        k6.draw(D5 + t9 * a5, A6 + e9 * a5, a5, function(r8, n6) {
                          var o6;
                          return !!(null === (o6 = O4[t9 + r8]) || void 0 === o6 ? void 0 : o6[e9 + n6]);
                        });
                      }, r7 = 0; r7 < O4[t9].length; r7++)
                        e8(r7);
                    }, R4 = 0; R4 < O4.length; R4++)
                      q6(R4);
                  }
                  if (null === (p6 = n5.cornersSquareOptions) || void 0 === p6 ? void 0 : p6.gradient) {
                    var B4 = n5.cornersSquareOptions.gradient, E7 = e7._createGradient({ context: r6, options: B4, additionalRotation: P5, x: D5, y: A6, size: s5 });
                    B4.colorStops.forEach(function(t9) {
                      var e8 = t9.offset, r7 = t9.color;
                      E7.addColorStop(e8, r7);
                    }), r6.fillStyle = r6.strokeStyle = E7;
                  } else
                    (null === (g5 = n5.cornersSquareOptions) || void 0 === g5 ? void 0 : g5.color) && (r6.fillStyle = r6.strokeStyle = n5.cornersSquareOptions.color);
                  if (r6.fill("evenodd"), null === (y6 = n5.cornersDotOptions) || void 0 === y6 ? void 0 : y6.type) {
                    var L5 = new C4({ context: r6, type: null === (w7 = n5.cornersDotOptions) || void 0 === w7 ? void 0 : w7.type });
                    r6.beginPath(), L5.draw(D5 + 2 * a5, A6 + 2 * a5, c5, P5);
                  } else {
                    k6 = new v5({ context: r6, type: n5.dotsOptions.type }), r6.beginPath();
                    var N5 = function(t9) {
                      for (var e8 = function(e9) {
                        if (!(null === (_6 = z4[t9]) || void 0 === _6 ? void 0 : _6[e9]))
                          return "continue";
                        k6.draw(D5 + t9 * a5, A6 + e9 * a5, a5, function(r8, n6) {
                          var o6;
                          return !!(null === (o6 = z4[t9 + r8]) || void 0 === o6 ? void 0 : o6[e9 + n6]);
                        });
                      }, r7 = 0; r7 < z4[t9].length; r7++)
                        e8(r7);
                    };
                    for (R4 = 0; R4 < z4.length; R4++)
                      N5(R4);
                  }
                  if (null === (m6 = n5.cornersDotOptions) || void 0 === m6 ? void 0 : m6.gradient) {
                    B4 = n5.cornersDotOptions.gradient;
                    var T6 = e7._createGradient({ context: r6, options: B4, additionalRotation: P5, x: D5 + 2 * a5, y: A6 + 2 * a5, size: c5 });
                    B4.colorStops.forEach(function(t9) {
                      var e8 = t9.offset, r7 = t9.color;
                      T6.addColorStop(e8, r7);
                    }), r6.fillStyle = r6.strokeStyle = T6;
                  } else
                    (null === (x6 = n5.cornersDotOptions) || void 0 === x6 ? void 0 : x6.color) && (r6.fillStyle = r6.strokeStyle = n5.cornersDotOptions.color);
                  r6.fill("evenodd");
                }
              });
            }, t7.prototype.loadImage = function() {
              var t8 = this;
              return new Promise(function(e7, r6) {
                var n5 = t8._options, o5 = new Image();
                if (!n5.image)
                  return r6("Image is not defined");
                "string" == typeof n5.imageOptions.crossOrigin && (o5.crossOrigin = n5.imageOptions.crossOrigin), t8._image = o5, o5.onload = function() {
                  e7();
                }, o5.src = n5.image;
              });
            }, t7.prototype.drawImage = function(t8) {
              var e7 = t8.width, r6 = t8.height, n5 = t8.count, o5 = t8.dotSize, i5 = this.context;
              if (!i5)
                throw "canvasContext is not defined";
              if (!this._image)
                throw "image is not defined";
              var a5 = this._options, s5 = Math.floor((a5.width - n5 * o5) / 2), c5 = Math.floor((a5.height - n5 * o5) / 2), u6 = s5 + a5.imageOptions.margin + (n5 * o5 - e7) / 2, h6 = c5 + a5.imageOptions.margin + (n5 * o5 - r6) / 2, d5 = e7 - 2 * a5.imageOptions.margin, l6 = r6 - 2 * a5.imageOptions.margin;
              i5.drawImage(this._image, u6, h6, d5 < 0 ? 0 : d5, l6 < 0 ? 0 : l6);
            }, t7.prototype._createGradient = function(t8) {
              var e7, r6 = t8.context, n5 = t8.options, o5 = t8.additionalRotation, i5 = t8.x, a5 = t8.y, s5 = t8.size;
              if (n5.type === P4)
                e7 = r6.createRadialGradient(i5 + s5 / 2, a5 + s5 / 2, 0, i5 + s5 / 2, a5 + s5 / 2, s5 / 2);
              else {
                var c5 = ((n5.rotation || 0) + o5) % (2 * Math.PI), u6 = (c5 + 2 * Math.PI) % (2 * Math.PI), h6 = i5 + s5 / 2, d5 = a5 + s5 / 2, l6 = i5 + s5 / 2, f6 = a5 + s5 / 2;
                u6 >= 0 && u6 <= 0.25 * Math.PI || u6 > 1.75 * Math.PI && u6 <= 2 * Math.PI ? (h6 -= s5 / 2, d5 -= s5 / 2 * Math.tan(c5), l6 += s5 / 2, f6 += s5 / 2 * Math.tan(c5)) : u6 > 0.25 * Math.PI && u6 <= 0.75 * Math.PI ? (d5 -= s5 / 2, h6 -= s5 / 2 / Math.tan(c5), f6 += s5 / 2, l6 += s5 / 2 / Math.tan(c5)) : u6 > 0.75 * Math.PI && u6 <= 1.25 * Math.PI ? (h6 += s5 / 2, d5 += s5 / 2 * Math.tan(c5), l6 -= s5 / 2, f6 -= s5 / 2 * Math.tan(c5)) : u6 > 1.25 * Math.PI && u6 <= 1.75 * Math.PI && (d5 += s5 / 2, h6 += s5 / 2 / Math.tan(c5), f6 -= s5 / 2, l6 -= s5 / 2 / Math.tan(c5)), e7 = r6.createLinearGradient(Math.round(h6), Math.round(d5), Math.round(l6), Math.round(f6));
              }
              return e7;
            }, t7;
          }();
          var A5 = function() {
            return A5 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, A5.apply(this, arguments);
          }, I4 = function() {
            function t7(t8) {
              var e7 = t8.svg, r6 = t8.type;
              this._svg = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              var o5;
              switch (this._type) {
                case u5:
                  o5 = this._drawDot;
                  break;
                case d4:
                  o5 = this._drawClassy;
                  break;
                case l5:
                  o5 = this._drawClassyRounded;
                  break;
                case h5:
                  o5 = this._drawRounded;
                  break;
                case f5:
                  o5 = this._drawExtraRounded;
                  break;
                default:
                  o5 = this._drawSquare;
              }
              o5.call(this, { x: t8, y: e7, size: r6, getNeighbor: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7, r6 = t8.x, n5 = t8.y, o5 = t8.size, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = r6 + o5 / 2, c5 = n5 + o5 / 2;
              (0, t8.draw)(), null === (e7 = this._element) || void 0 === e7 || e7.setAttribute("transform", "rotate(".concat(180 * a5 / Math.PI, ",").concat(s5, ",").concat(c5, ")"));
            }, t7.prototype._basicDot = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e7._element.setAttribute("cx", String(n5 + r6 / 2)), e7._element.setAttribute("cy", String(o5 + r6 / 2)), e7._element.setAttribute("r", String(r6 / 2));
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e7._element.setAttribute("x", String(n5)), e7._element.setAttribute("y", String(o5)), e7._element.setAttribute("width", String(r6)), e7._element.setAttribute("height", String(r6));
              } }));
            }, t7.prototype._basicSideRounded = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5) + "v ".concat(r6) + "h ".concat(r6 / 2) + "a ".concat(r6 / 2, " ").concat(r6 / 2, ", 0, 0, 0, 0 ").concat(-r6));
              } }));
            }, t7.prototype._basicCornerRounded = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5) + "v ".concat(r6) + "h ".concat(r6) + "v ".concat(-r6 / 2) + "a ".concat(r6 / 2, " ").concat(r6 / 2, ", 0, 0, 0, ").concat(-r6 / 2, " ").concat(-r6 / 2));
              } }));
            }, t7.prototype._basicCornerExtraRounded = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5) + "v ".concat(r6) + "h ".concat(r6) + "a ".concat(r6, " ").concat(r6, ", 0, 0, 0, ").concat(-r6, " ").concat(-r6));
              } }));
            }, t7.prototype._basicCornersRounded = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(A5(A5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5) + "v ".concat(r6 / 2) + "a ".concat(r6 / 2, " ").concat(r6 / 2, ", 0, 0, 0, ").concat(r6 / 2, " ").concat(r6 / 2) + "h ".concat(r6 / 2) + "v ".concat(-r6 / 2) + "a ".concat(r6 / 2, " ").concat(r6 / 2, ", 0, 0, 0, ").concat(-r6 / 2, " ").concat(-r6 / 2));
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size;
              this._basicDot({ x: e7, y: r6, size: n5, rotation: 0 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size;
              this._basicSquare({ x: e7, y: r6, size: n5, rotation: 0 });
            }, t7.prototype._drawRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.getNeighbor, i5 = o5 ? +o5(-1, 0) : 0, a5 = o5 ? +o5(1, 0) : 0, s5 = o5 ? +o5(0, -1) : 0, c5 = o5 ? +o5(0, 1) : 0, u6 = i5 + a5 + s5 + c5;
              if (0 !== u6)
                if (u6 > 2 || i5 && a5 || s5 && c5)
                  this._basicSquare({ x: e7, y: r6, size: n5, rotation: 0 });
                else {
                  if (2 === u6) {
                    var h6 = 0;
                    return i5 && s5 ? h6 = Math.PI / 2 : s5 && a5 ? h6 = Math.PI : a5 && c5 && (h6 = -Math.PI / 2), void this._basicCornerRounded({ x: e7, y: r6, size: n5, rotation: h6 });
                  }
                  if (1 === u6)
                    return h6 = 0, s5 ? h6 = Math.PI / 2 : a5 ? h6 = Math.PI : c5 && (h6 = -Math.PI / 2), void this._basicSideRounded({ x: e7, y: r6, size: n5, rotation: h6 });
                }
              else
                this._basicDot({ x: e7, y: r6, size: n5, rotation: 0 });
            }, t7.prototype._drawExtraRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.getNeighbor, i5 = o5 ? +o5(-1, 0) : 0, a5 = o5 ? +o5(1, 0) : 0, s5 = o5 ? +o5(0, -1) : 0, c5 = o5 ? +o5(0, 1) : 0, u6 = i5 + a5 + s5 + c5;
              if (0 !== u6)
                if (u6 > 2 || i5 && a5 || s5 && c5)
                  this._basicSquare({ x: e7, y: r6, size: n5, rotation: 0 });
                else {
                  if (2 === u6) {
                    var h6 = 0;
                    return i5 && s5 ? h6 = Math.PI / 2 : s5 && a5 ? h6 = Math.PI : a5 && c5 && (h6 = -Math.PI / 2), void this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, rotation: h6 });
                  }
                  if (1 === u6)
                    return h6 = 0, s5 ? h6 = Math.PI / 2 : a5 ? h6 = Math.PI : c5 && (h6 = -Math.PI / 2), void this._basicSideRounded({ x: e7, y: r6, size: n5, rotation: h6 });
                }
              else
                this._basicDot({ x: e7, y: r6, size: n5, rotation: 0 });
            }, t7.prototype._drawClassy = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.getNeighbor, i5 = o5 ? +o5(-1, 0) : 0, a5 = o5 ? +o5(1, 0) : 0, s5 = o5 ? +o5(0, -1) : 0, c5 = o5 ? +o5(0, 1) : 0;
              0 !== i5 + a5 + s5 + c5 ? i5 || s5 ? a5 || c5 ? this._basicSquare({ x: e7, y: r6, size: n5, rotation: 0 }) : this._basicCornerRounded({ x: e7, y: r6, size: n5, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: e7, y: r6, size: n5, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e7, y: r6, size: n5, rotation: Math.PI / 2 });
            }, t7.prototype._drawClassyRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.getNeighbor, i5 = o5 ? +o5(-1, 0) : 0, a5 = o5 ? +o5(1, 0) : 0, s5 = o5 ? +o5(0, -1) : 0, c5 = o5 ? +o5(0, 1) : 0;
              0 !== i5 + a5 + s5 + c5 ? i5 || s5 ? a5 || c5 ? this._basicSquare({ x: e7, y: r6, size: n5, rotation: 0 }) : this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: e7, y: r6, size: n5, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e7, y: r6, size: n5, rotation: Math.PI / 2 });
            }, t7;
          }();
          const k5 = I4;
          var q5 = function() {
            return q5 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, q5.apply(this, arguments);
          }, R3 = function() {
            function t7(t8) {
              var e7 = t8.svg, r6 = t8.type;
              this._svg = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              var o5;
              switch (this._type) {
                case y5:
                  o5 = this._drawSquare;
                  break;
                case w6:
                  o5 = this._drawExtraRounded;
                  break;
                default:
                  o5 = this._drawDot;
              }
              o5.call(this, { x: t8, y: e7, size: r6, rotation: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7, r6 = t8.x, n5 = t8.y, o5 = t8.size, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = r6 + o5 / 2, c5 = n5 + o5 / 2;
              (0, t8.draw)(), null === (e7 = this._element) || void 0 === e7 || e7.setAttribute("transform", "rotate(".concat(180 * a5 / Math.PI, ",").concat(s5, ",").concat(c5, ")"));
            }, t7.prototype._basicDot = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y, i5 = r6 / 7;
              this._rotateFigure(q5(q5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("clip-rule", "evenodd"), e7._element.setAttribute("d", "M ".concat(n5 + r6 / 2, " ").concat(o5) + "a ".concat(r6 / 2, " ").concat(r6 / 2, " 0 1 0 0.1 0") + "z" + "m 0 ".concat(i5) + "a ".concat(r6 / 2 - i5, " ").concat(r6 / 2 - i5, " 0 1 1 -0.1 0") + "Z");
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y, i5 = r6 / 7;
              this._rotateFigure(q5(q5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("clip-rule", "evenodd"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5) + "v ".concat(r6) + "h ".concat(r6) + "v ".concat(-r6) + "z" + "M ".concat(n5 + i5, " ").concat(o5 + i5) + "h ".concat(r6 - 2 * i5) + "v ".concat(r6 - 2 * i5) + "h ".concat(2 * i5 - r6) + "z");
              } }));
            }, t7.prototype._basicExtraRounded = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y, i5 = r6 / 7;
              this._rotateFigure(q5(q5({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e7._element.setAttribute("clip-rule", "evenodd"), e7._element.setAttribute("d", "M ".concat(n5, " ").concat(o5 + 2.5 * i5) + "v ".concat(2 * i5) + "a ".concat(2.5 * i5, " ").concat(2.5 * i5, ", 0, 0, 0, ").concat(2.5 * i5, " ").concat(2.5 * i5) + "h ".concat(2 * i5) + "a ".concat(2.5 * i5, " ").concat(2.5 * i5, ", 0, 0, 0, ").concat(2.5 * i5, " ").concat(2.5 * -i5) + "v ".concat(-2 * i5) + "a ".concat(2.5 * i5, " ").concat(2.5 * i5, ", 0, 0, 0, ").concat(2.5 * -i5, " ").concat(2.5 * -i5) + "h ".concat(-2 * i5) + "a ".concat(2.5 * i5, " ").concat(2.5 * i5, ", 0, 0, 0, ").concat(2.5 * -i5, " ").concat(2.5 * i5) + "M ".concat(n5 + 2.5 * i5, " ").concat(o5 + i5) + "h ".concat(2 * i5) + "a ".concat(1.5 * i5, " ").concat(1.5 * i5, ", 0, 0, 1, ").concat(1.5 * i5, " ").concat(1.5 * i5) + "v ".concat(2 * i5) + "a ".concat(1.5 * i5, " ").concat(1.5 * i5, ", 0, 0, 1, ").concat(1.5 * -i5, " ").concat(1.5 * i5) + "h ".concat(-2 * i5) + "a ".concat(1.5 * i5, " ").concat(1.5 * i5, ", 0, 0, 1, ").concat(1.5 * -i5, " ").concat(1.5 * -i5) + "v ".concat(-2 * i5) + "a ".concat(1.5 * i5, " ").concat(1.5 * i5, ", 0, 0, 1, ").concat(1.5 * i5, " ").concat(1.5 * -i5));
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.rotation;
              this._basicDot({ x: e7, y: r6, size: n5, rotation: o5 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.rotation;
              this._basicSquare({ x: e7, y: r6, size: n5, rotation: o5 });
            }, t7.prototype._drawExtraRounded = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.rotation;
              this._basicExtraRounded({ x: e7, y: r6, size: n5, rotation: o5 });
            }, t7;
          }();
          const B3 = R3;
          var E6 = function() {
            return E6 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, E6.apply(this, arguments);
          }, L4 = function() {
            function t7(t8) {
              var e7 = t8.svg, r6 = t8.type;
              this._svg = e7, this._type = r6;
            }
            return t7.prototype.draw = function(t8, e7, r6, n5) {
              (this._type === x5 ? this._drawSquare : this._drawDot).call(this, { x: t8, y: e7, size: r6, rotation: n5 });
            }, t7.prototype._rotateFigure = function(t8) {
              var e7, r6 = t8.x, n5 = t8.y, o5 = t8.size, i5 = t8.rotation, a5 = void 0 === i5 ? 0 : i5, s5 = r6 + o5 / 2, c5 = n5 + o5 / 2;
              (0, t8.draw)(), null === (e7 = this._element) || void 0 === e7 || e7.setAttribute("transform", "rotate(".concat(180 * a5 / Math.PI, ",").concat(s5, ",").concat(c5, ")"));
            }, t7.prototype._basicDot = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(E6(E6({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e7._element.setAttribute("cx", String(n5 + r6 / 2)), e7._element.setAttribute("cy", String(o5 + r6 / 2)), e7._element.setAttribute("r", String(r6 / 2));
              } }));
            }, t7.prototype._basicSquare = function(t8) {
              var e7 = this, r6 = t8.size, n5 = t8.x, o5 = t8.y;
              this._rotateFigure(E6(E6({}, t8), { draw: function() {
                e7._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e7._element.setAttribute("x", String(n5)), e7._element.setAttribute("y", String(o5)), e7._element.setAttribute("width", String(r6)), e7._element.setAttribute("height", String(r6));
              } }));
            }, t7.prototype._drawDot = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.rotation;
              this._basicDot({ x: e7, y: r6, size: n5, rotation: o5 });
            }, t7.prototype._drawSquare = function(t8) {
              var e7 = t8.x, r6 = t8.y, n5 = t8.size, o5 = t8.rotation;
              this._basicSquare({ x: e7, y: r6, size: n5, rotation: o5 });
            }, t7;
          }();
          const N4 = L4;
          var T5 = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], j4 = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
          const F4 = function() {
            function t7(t8) {
              this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(t8.width)), this._element.setAttribute("height", String(t8.height)), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._options = t8;
            }
            return Object.defineProperty(t7.prototype, "width", { get: function() {
              return this._options.width;
            }, enumerable: false, configurable: true }), Object.defineProperty(t7.prototype, "height", { get: function() {
              return this._options.height;
            }, enumerable: false, configurable: true }), t7.prototype.getElement = function() {
              return this._element;
            }, t7.prototype.clear = function() {
              var t8, e7 = this._element;
              this._element = e7.cloneNode(false), null === (t8 = null == e7 ? void 0 : e7.parentNode) || void 0 === t8 || t8.replaceChild(this._element, e7), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs);
            }, t7.prototype.drawQR = function(t8) {
              return e7 = this, r6 = void 0, o5 = function() {
                var e8, r7, n6, o6, i5, a5, u6, h6, d5, l6 = this;
                return function(t9, e9) {
                  var r8, n7, o7, i6, a6 = { label: 0, sent: function() {
                    if (1 & o7[0])
                      throw o7[1];
                    return o7[1];
                  }, trys: [], ops: [] };
                  return i6 = { next: s5(0), throw: s5(1), return: s5(2) }, "function" == typeof Symbol && (i6[Symbol.iterator] = function() {
                    return this;
                  }), i6;
                  function s5(i7) {
                    return function(s6) {
                      return function(i8) {
                        if (r8)
                          throw new TypeError("Generator is already executing.");
                        for (; a6; )
                          try {
                            if (r8 = 1, n7 && (o7 = 2 & i8[0] ? n7.return : i8[0] ? n7.throw || ((o7 = n7.return) && o7.call(n7), 0) : n7.next) && !(o7 = o7.call(n7, i8[1])).done)
                              return o7;
                            switch (n7 = 0, o7 && (i8 = [2 & i8[0], o7.value]), i8[0]) {
                              case 0:
                              case 1:
                                o7 = i8;
                                break;
                              case 4:
                                return a6.label++, { value: i8[1], done: false };
                              case 5:
                                a6.label++, n7 = i8[1], i8 = [0];
                                continue;
                              case 7:
                                i8 = a6.ops.pop(), a6.trys.pop();
                                continue;
                              default:
                                if (!((o7 = (o7 = a6.trys).length > 0 && o7[o7.length - 1]) || 6 !== i8[0] && 2 !== i8[0])) {
                                  a6 = 0;
                                  continue;
                                }
                                if (3 === i8[0] && (!o7 || i8[1] > o7[0] && i8[1] < o7[3])) {
                                  a6.label = i8[1];
                                  break;
                                }
                                if (6 === i8[0] && a6.label < o7[1]) {
                                  a6.label = o7[1], o7 = i8;
                                  break;
                                }
                                if (o7 && a6.label < o7[2]) {
                                  a6.label = o7[2], a6.ops.push(i8);
                                  break;
                                }
                                o7[2] && a6.ops.pop(), a6.trys.pop();
                                continue;
                            }
                            i8 = e9.call(t9, a6);
                          } catch (t10) {
                            i8 = [6, t10], n7 = 0;
                          } finally {
                            r8 = o7 = 0;
                          }
                        if (5 & i8[0])
                          throw i8[1];
                        return { value: i8[0] ? i8[1] : void 0, done: true };
                      }([i7, s6]);
                    };
                  }
                }(this, function(f6) {
                  switch (f6.label) {
                    case 0:
                      return e8 = t8.getModuleCount(), r7 = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, n6 = r7 / e8, o6 = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }, this._qr = t8, this._options.image ? [4, this.loadImage()] : [3, 2];
                    case 1:
                      if (f6.sent(), !this._image)
                        return [2];
                      i5 = this._options, a5 = i5.imageOptions, u6 = i5.qrOptions, h6 = a5.imageSize * c4[u6.errorCorrectionLevel], d5 = Math.floor(h6 * e8 * e8), o6 = s4({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: d5, maxHiddenAxisDots: e8 - 14, dotSize: n6 }), f6.label = 2;
                    case 2:
                      return this.clear(), this.drawBackground(), this.drawDots(function(t9, r8) {
                        var n7, i6, a6, s5, c5, u7;
                        return !(l6._options.imageOptions.hideBackgroundDots && t9 >= (e8 - o6.hideXDots) / 2 && t9 < (e8 + o6.hideXDots) / 2 && r8 >= (e8 - o6.hideYDots) / 2 && r8 < (e8 + o6.hideYDots) / 2 || (null === (n7 = T5[t9]) || void 0 === n7 ? void 0 : n7[r8]) || (null === (i6 = T5[t9 - e8 + 7]) || void 0 === i6 ? void 0 : i6[r8]) || (null === (a6 = T5[t9]) || void 0 === a6 ? void 0 : a6[r8 - e8 + 7]) || (null === (s5 = j4[t9]) || void 0 === s5 ? void 0 : s5[r8]) || (null === (c5 = j4[t9 - e8 + 7]) || void 0 === c5 ? void 0 : c5[r8]) || (null === (u7 = j4[t9]) || void 0 === u7 ? void 0 : u7[r8 - e8 + 7]));
                      }), this.drawCorners(), this._options.image && this.drawImage({ width: o6.width, height: o6.height, count: e8, dotSize: n6 }), [2];
                  }
                });
              }, new ((n5 = void 0) || (n5 = Promise))(function(t9, i5) {
                function a5(t10) {
                  try {
                    c5(o5.next(t10));
                  } catch (t11) {
                    i5(t11);
                  }
                }
                function s5(t10) {
                  try {
                    c5(o5.throw(t10));
                  } catch (t11) {
                    i5(t11);
                  }
                }
                function c5(e8) {
                  var r7;
                  e8.done ? t9(e8.value) : (r7 = e8.value, r7 instanceof n5 ? r7 : new n5(function(t10) {
                    t10(r7);
                  })).then(a5, s5);
                }
                c5((o5 = o5.apply(e7, r6 || [])).next());
              });
              var e7, r6, n5, o5;
            }, t7.prototype.drawBackground = function() {
              var t8, e7, r6 = this._element, n5 = this._options;
              if (r6) {
                var o5 = null === (t8 = n5.backgroundOptions) || void 0 === t8 ? void 0 : t8.gradient, i5 = null === (e7 = n5.backgroundOptions) || void 0 === e7 ? void 0 : e7.color;
                (o5 || i5) && this._createColor({ options: o5, color: i5, additionalRotation: 0, x: 0, y: 0, height: n5.height, width: n5.width, name: "background-color" });
              }
            }, t7.prototype.drawDots = function(t8) {
              var e7, r6, n5 = this;
              if (!this._qr)
                throw "QR code is not defined";
              var o5 = this._options, i5 = this._qr.getModuleCount();
              if (i5 > o5.width || i5 > o5.height)
                throw "The canvas is too small.";
              var a5 = (Math.min(o5.width, o5.height) - 2 * o5.margin) / i5, s5 = (o5.width - i5 * a5) / 2, c5 = (o5.height - i5 * a5) / 2, u6 = new k5({ svg: this._element, type: o5.dotsOptions.type });
              this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", "clip-path-dot-color"), this._dotsClipPath.style.transformOrigin = "center", this._dotsClipPath.style.transform = "rotate(90deg) scale(1, -1)", this._defs.appendChild(this._dotsClipPath), this._createColor({ options: null === (e7 = o5.dotsOptions) || void 0 === e7 ? void 0 : e7.gradient, color: o5.dotsOptions.color, additionalRotation: 0, x: s5, y: c5, height: i5 * a5, width: i5 * a5, name: "dot-color" });
              for (var h6 = function(e8) {
                for (var o6 = function(o7) {
                  return t8 && !t8(e8, o7) ? "continue" : (null === (r6 = d5._qr) || void 0 === r6 ? void 0 : r6.isDark(e8, o7)) ? (u6.draw(s5 + e8 * a5, c5 + o7 * a5, a5, function(r7, a6) {
                    return !(e8 + r7 < 0 || o7 + a6 < 0 || e8 + r7 >= i5 || o7 + a6 >= i5) && !(t8 && !t8(e8 + r7, o7 + a6)) && !!n5._qr && n5._qr.isDark(e8 + r7, o7 + a6);
                  }), void (u6._element && d5._dotsClipPath && d5._dotsClipPath.appendChild(u6._element))) : "continue";
                }, h7 = 0; h7 < i5; h7++)
                  o6(h7);
              }, d5 = this, l6 = 0; l6 < i5; l6++)
                h6(l6);
            }, t7.prototype.drawCorners = function() {
              var t8 = this;
              if (!this._qr)
                throw "QR code is not defined";
              var e7 = this._element, r6 = this._options;
              if (!e7)
                throw "Element code is not defined";
              var n5 = this._qr.getModuleCount(), o5 = (Math.min(r6.width, r6.height) - 2 * r6.margin) / n5, i5 = 7 * o5, a5 = 3 * o5, s5 = (r6.width - n5 * o5) / 2, c5 = (r6.height - n5 * o5) / 2;
              [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(function(e8) {
                var u6, h6, d5, l6, f6, p6, g5, v6, y6, w7, _6, m6, b4 = e8[0], x6 = e8[1], M5 = e8[2], S4 = s5 + b4 * o5 * (n5 - 7), C5 = c5 + x6 * o5 * (n5 - 7), P5 = t8._dotsClipPath, O5 = t8._dotsClipPath;
                if (((null === (u6 = r6.cornersSquareOptions) || void 0 === u6 ? void 0 : u6.gradient) || (null === (h6 = r6.cornersSquareOptions) || void 0 === h6 ? void 0 : h6.color)) && ((P5 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-".concat(b4, "-").concat(x6)), t8._defs.appendChild(P5), t8._cornersSquareClipPath = t8._cornersDotClipPath = O5 = P5, t8._createColor({ options: null === (d5 = r6.cornersSquareOptions) || void 0 === d5 ? void 0 : d5.gradient, color: null === (l6 = r6.cornersSquareOptions) || void 0 === l6 ? void 0 : l6.color, additionalRotation: M5, x: S4, y: C5, height: i5, width: i5, name: "corners-square-color-".concat(b4, "-").concat(x6) })), null === (f6 = r6.cornersSquareOptions) || void 0 === f6 ? void 0 : f6.type) {
                  var z5 = new B3({ svg: t8._element, type: r6.cornersSquareOptions.type });
                  z5.draw(S4, C5, i5, M5), z5._element && P5 && P5.appendChild(z5._element);
                } else
                  for (var D5 = new k5({ svg: t8._element, type: r6.dotsOptions.type }), A6 = function(t9) {
                    for (var e9 = function(e10) {
                      if (!(null === (p6 = T5[t9]) || void 0 === p6 ? void 0 : p6[e10]))
                        return "continue";
                      D5.draw(S4 + t9 * o5, C5 + e10 * o5, o5, function(r8, n6) {
                        var o6;
                        return !!(null === (o6 = T5[t9 + r8]) || void 0 === o6 ? void 0 : o6[e10 + n6]);
                      }), D5._element && P5 && P5.appendChild(D5._element);
                    }, r7 = 0; r7 < T5[t9].length; r7++)
                      e9(r7);
                  }, I5 = 0; I5 < T5.length; I5++)
                    A6(I5);
                if (((null === (g5 = r6.cornersDotOptions) || void 0 === g5 ? void 0 : g5.gradient) || (null === (v6 = r6.cornersDotOptions) || void 0 === v6 ? void 0 : v6.color)) && ((O5 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-".concat(b4, "-").concat(x6)), t8._defs.appendChild(O5), t8._cornersDotClipPath = O5, t8._createColor({ options: null === (y6 = r6.cornersDotOptions) || void 0 === y6 ? void 0 : y6.gradient, color: null === (w7 = r6.cornersDotOptions) || void 0 === w7 ? void 0 : w7.color, additionalRotation: M5, x: S4 + 2 * o5, y: C5 + 2 * o5, height: a5, width: a5, name: "corners-dot-color-".concat(b4, "-").concat(x6) })), null === (_6 = r6.cornersDotOptions) || void 0 === _6 ? void 0 : _6.type) {
                  var q6 = new N4({ svg: t8._element, type: r6.cornersDotOptions.type });
                  q6.draw(S4 + 2 * o5, C5 + 2 * o5, a5, M5), q6._element && O5 && O5.appendChild(q6._element);
                } else {
                  D5 = new k5({ svg: t8._element, type: r6.dotsOptions.type });
                  var R4 = function(t9) {
                    for (var e9 = function(e10) {
                      if (!(null === (m6 = j4[t9]) || void 0 === m6 ? void 0 : m6[e10]))
                        return "continue";
                      D5.draw(S4 + t9 * o5, C5 + e10 * o5, o5, function(r8, n6) {
                        var o6;
                        return !!(null === (o6 = j4[t9 + r8]) || void 0 === o6 ? void 0 : o6[e10 + n6]);
                      }), D5._element && O5 && O5.appendChild(D5._element);
                    }, r7 = 0; r7 < j4[t9].length; r7++)
                      e9(r7);
                  };
                  for (I5 = 0; I5 < j4.length; I5++)
                    R4(I5);
                }
              });
            }, t7.prototype.loadImage = function() {
              var t8 = this;
              return new Promise(function(e7, r6) {
                var n5 = t8._options, o5 = new Image();
                if (!n5.image)
                  return r6("Image is not defined");
                "string" == typeof n5.imageOptions.crossOrigin && (o5.crossOrigin = n5.imageOptions.crossOrigin), t8._image = o5, o5.onload = function() {
                  e7();
                }, o5.src = n5.image;
              });
            }, t7.prototype.drawImage = function(t8) {
              var e7 = t8.width, r6 = t8.height, n5 = t8.count, o5 = t8.dotSize, i5 = this._options, a5 = (i5.width - n5 * o5) / 2, s5 = (i5.height - n5 * o5) / 2, c5 = a5 + i5.imageOptions.margin + (n5 * o5 - e7) / 2, u6 = s5 + i5.imageOptions.margin + (n5 * o5 - r6) / 2, h6 = e7 - 2 * i5.imageOptions.margin, d5 = r6 - 2 * i5.imageOptions.margin, l6 = document.createElementNS("http://www.w3.org/2000/svg", "image");
              l6.setAttribute("href", i5.image || ""), l6.setAttribute("x", String(c5)), l6.setAttribute("y", String(u6)), l6.setAttribute("width", "".concat(h6, "px")), l6.setAttribute("height", "".concat(d5, "px")), this._element.appendChild(l6);
            }, t7.prototype._createColor = function(t8) {
              var e7 = t8.options, r6 = t8.color, n5 = t8.additionalRotation, o5 = t8.x, i5 = t8.y, a5 = t8.height, s5 = t8.width, c5 = t8.name, u6 = s5 > a5 ? s5 : a5, h6 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              if (h6.setAttribute("x", String(o5)), h6.setAttribute("y", String(i5)), h6.setAttribute("height", String(a5)), h6.setAttribute("width", String(s5)), h6.setAttribute("clip-path", "url('#clip-path-".concat(c5, "')")), e7) {
                var d5;
                if (e7.type === P4)
                  (d5 = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", c5), d5.setAttribute("gradientUnits", "userSpaceOnUse"), d5.setAttribute("fx", String(o5 + s5 / 2)), d5.setAttribute("fy", String(i5 + a5 / 2)), d5.setAttribute("cx", String(o5 + s5 / 2)), d5.setAttribute("cy", String(i5 + a5 / 2)), d5.setAttribute("r", String(u6 / 2));
                else {
                  var l6 = ((e7.rotation || 0) + n5) % (2 * Math.PI), f6 = (l6 + 2 * Math.PI) % (2 * Math.PI), p6 = o5 + s5 / 2, g5 = i5 + a5 / 2, v6 = o5 + s5 / 2, y6 = i5 + a5 / 2;
                  f6 >= 0 && f6 <= 0.25 * Math.PI || f6 > 1.75 * Math.PI && f6 <= 2 * Math.PI ? (p6 -= s5 / 2, g5 -= a5 / 2 * Math.tan(l6), v6 += s5 / 2, y6 += a5 / 2 * Math.tan(l6)) : f6 > 0.25 * Math.PI && f6 <= 0.75 * Math.PI ? (g5 -= a5 / 2, p6 -= s5 / 2 / Math.tan(l6), y6 += a5 / 2, v6 += s5 / 2 / Math.tan(l6)) : f6 > 0.75 * Math.PI && f6 <= 1.25 * Math.PI ? (p6 += s5 / 2, g5 += a5 / 2 * Math.tan(l6), v6 -= s5 / 2, y6 -= a5 / 2 * Math.tan(l6)) : f6 > 1.25 * Math.PI && f6 <= 1.75 * Math.PI && (g5 += a5 / 2, p6 += s5 / 2 / Math.tan(l6), y6 -= a5 / 2, v6 -= s5 / 2 / Math.tan(l6)), (d5 = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", c5), d5.setAttribute("gradientUnits", "userSpaceOnUse"), d5.setAttribute("x1", String(Math.round(p6))), d5.setAttribute("y1", String(Math.round(g5))), d5.setAttribute("x2", String(Math.round(v6))), d5.setAttribute("y2", String(Math.round(y6)));
                }
                e7.colorStops.forEach(function(t9) {
                  var e8 = t9.offset, r7 = t9.color, n6 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                  n6.setAttribute("offset", "".concat(100 * e8, "%")), n6.setAttribute("stop-color", r7), d5.appendChild(n6);
                }), h6.setAttribute("fill", "url('#".concat(c5, "')")), this._defs.appendChild(d5);
              } else
                r6 && h6.setAttribute("fill", r6);
              this._element.appendChild(h6);
            }, t7;
          }(), Q3 = "canvas";
          for (var H4 = {}, G4 = 0; G4 <= 40; G4++)
            H4[G4] = G4;
          const X3 = { type: Q3, width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: H4[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { hideBackgroundDots: true, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000" }, backgroundOptions: { color: "#fff" } };
          var U3 = function() {
            return U3 = Object.assign || function(t7) {
              for (var e7, r6 = 1, n5 = arguments.length; r6 < n5; r6++)
                for (var o5 in e7 = arguments[r6])
                  Object.prototype.hasOwnProperty.call(e7, o5) && (t7[o5] = e7[o5]);
              return t7;
            }, U3.apply(this, arguments);
          };
          function Y3(t7) {
            var e7 = U3({}, t7);
            if (!e7.colorStops || !e7.colorStops.length)
              throw "Field 'colorStops' is required in gradient";
            return e7.rotation ? e7.rotation = Number(e7.rotation) : e7.rotation = 0, e7.colorStops = e7.colorStops.map(function(t8) {
              return U3(U3({}, t8), { offset: Number(t8.offset) });
            }), e7;
          }
          function $4(t7) {
            var e7 = U3({}, t7);
            return e7.width = Number(e7.width), e7.height = Number(e7.height), e7.margin = Number(e7.margin), e7.imageOptions = U3(U3({}, e7.imageOptions), { hideBackgroundDots: Boolean(e7.imageOptions.hideBackgroundDots), imageSize: Number(e7.imageOptions.imageSize), margin: Number(e7.imageOptions.margin) }), e7.margin > Math.min(e7.width, e7.height) && (e7.margin = Math.min(e7.width, e7.height)), e7.dotsOptions = U3({}, e7.dotsOptions), e7.dotsOptions.gradient && (e7.dotsOptions.gradient = Y3(e7.dotsOptions.gradient)), e7.cornersSquareOptions && (e7.cornersSquareOptions = U3({}, e7.cornersSquareOptions), e7.cornersSquareOptions.gradient && (e7.cornersSquareOptions.gradient = Y3(e7.cornersSquareOptions.gradient))), e7.cornersDotOptions && (e7.cornersDotOptions = U3({}, e7.cornersDotOptions), e7.cornersDotOptions.gradient && (e7.cornersDotOptions.gradient = Y3(e7.cornersDotOptions.gradient))), e7.backgroundOptions && (e7.backgroundOptions = U3({}, e7.backgroundOptions), e7.backgroundOptions.gradient && (e7.backgroundOptions.gradient = Y3(e7.backgroundOptions.gradient))), e7;
          }
          var W3 = r5(192), Z4 = r5.n(W3), J3 = function(t7, e7, r6, n5) {
            return new (r6 || (r6 = Promise))(function(o5, i5) {
              function a5(t8) {
                try {
                  c5(n5.next(t8));
                } catch (t9) {
                  i5(t9);
                }
              }
              function s5(t8) {
                try {
                  c5(n5.throw(t8));
                } catch (t9) {
                  i5(t9);
                }
              }
              function c5(t8) {
                var e8;
                t8.done ? o5(t8.value) : (e8 = t8.value, e8 instanceof r6 ? e8 : new r6(function(t9) {
                  t9(e8);
                })).then(a5, s5);
              }
              c5((n5 = n5.apply(t7, e7 || [])).next());
            });
          }, K3 = function(t7, e7) {
            var r6, n5, o5, i5, a5 = { label: 0, sent: function() {
              if (1 & o5[0])
                throw o5[1];
              return o5[1];
            }, trys: [], ops: [] };
            return i5 = { next: s5(0), throw: s5(1), return: s5(2) }, "function" == typeof Symbol && (i5[Symbol.iterator] = function() {
              return this;
            }), i5;
            function s5(i6) {
              return function(s6) {
                return function(i7) {
                  if (r6)
                    throw new TypeError("Generator is already executing.");
                  for (; a5; )
                    try {
                      if (r6 = 1, n5 && (o5 = 2 & i7[0] ? n5.return : i7[0] ? n5.throw || ((o5 = n5.return) && o5.call(n5), 0) : n5.next) && !(o5 = o5.call(n5, i7[1])).done)
                        return o5;
                      switch (n5 = 0, o5 && (i7 = [2 & i7[0], o5.value]), i7[0]) {
                        case 0:
                        case 1:
                          o5 = i7;
                          break;
                        case 4:
                          return a5.label++, { value: i7[1], done: false };
                        case 5:
                          a5.label++, n5 = i7[1], i7 = [0];
                          continue;
                        case 7:
                          i7 = a5.ops.pop(), a5.trys.pop();
                          continue;
                        default:
                          if (!((o5 = (o5 = a5.trys).length > 0 && o5[o5.length - 1]) || 6 !== i7[0] && 2 !== i7[0])) {
                            a5 = 0;
                            continue;
                          }
                          if (3 === i7[0] && (!o5 || i7[1] > o5[0] && i7[1] < o5[3])) {
                            a5.label = i7[1];
                            break;
                          }
                          if (6 === i7[0] && a5.label < o5[1]) {
                            a5.label = o5[1], o5 = i7;
                            break;
                          }
                          if (o5 && a5.label < o5[2]) {
                            a5.label = o5[2], a5.ops.push(i7);
                            break;
                          }
                          o5[2] && a5.ops.pop(), a5.trys.pop();
                          continue;
                      }
                      i7 = e7.call(t7, a5);
                    } catch (t8) {
                      i7 = [6, t8], n5 = 0;
                    } finally {
                      r6 = o5 = 0;
                    }
                  if (5 & i7[0])
                    throw i7[1];
                  return { value: i7[0] ? i7[1] : void 0, done: true };
                }([i6, s6]);
              };
            }
          };
          const V3 = function() {
            function t7(t8) {
              this._options = t8 ? $4(i4(X3, t8)) : X3, this.update();
            }
            return t7._clearContainer = function(t8) {
              t8 && (t8.innerHTML = "");
            }, t7.prototype._getQRStylingElement = function(t8) {
              return void 0 === t8 && (t8 = "png"), J3(this, void 0, void 0, function() {
                var e7, r6, n5;
                return K3(this, function(o5) {
                  switch (o5.label) {
                    case 0:
                      if (!this._qr)
                        throw "QR code is empty";
                      return "svg" !== t8.toLowerCase() ? [3, 2] : (r6 = void 0, e7 = void 0, this._svg && this._svgDrawingPromise ? (e7 = this._svg, r6 = this._svgDrawingPromise) : (e7 = new F4(this._options), r6 = e7.drawQR(this._qr)), [4, r6]);
                    case 1:
                      return o5.sent(), [2, e7];
                    case 2:
                      return r6 = void 0, n5 = void 0, this._canvas && this._canvasDrawingPromise ? (n5 = this._canvas, r6 = this._canvasDrawingPromise) : (n5 = new D4(this._options), r6 = n5.drawQR(this._qr)), [4, r6];
                    case 3:
                      return o5.sent(), [2, n5];
                  }
                });
              });
            }, t7.prototype.update = function(e7) {
              t7._clearContainer(this._container), this._options = e7 ? $4(i4(this._options, e7)) : this._options, this._options.data && (this._qr = Z4()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(t8) {
                switch (true) {
                  case /^[0-9]*$/.test(t8):
                    return "Numeric";
                  case /^[0-9A-Z $%*+\-./:]*$/.test(t8):
                    return "Alphanumeric";
                  default:
                    return "Byte";
                }
              }(this._options.data)), this._qr.make(), this._options.type === Q3 ? (this._canvas = new D4(this._options), this._canvasDrawingPromise = this._canvas.drawQR(this._qr), this._svgDrawingPromise = void 0, this._svg = void 0) : (this._svg = new F4(this._options), this._svgDrawingPromise = this._svg.drawQR(this._qr), this._canvasDrawingPromise = void 0, this._canvas = void 0), this.append(this._container));
            }, t7.prototype.append = function(t8) {
              if (t8) {
                if ("function" != typeof t8.appendChild)
                  throw "Container should be a single DOM node";
                this._options.type === Q3 ? this._canvas && t8.appendChild(this._canvas.getCanvas()) : this._svg && t8.appendChild(this._svg.getElement()), this._container = t8;
              }
            }, t7.prototype.getRawData = function(t8) {
              return void 0 === t8 && (t8 = "png"), J3(this, void 0, void 0, function() {
                var e7, r6, n5;
                return K3(this, function(o5) {
                  switch (o5.label) {
                    case 0:
                      if (!this._qr)
                        throw "QR code is empty";
                      return [4, this._getQRStylingElement(t8)];
                    case 1:
                      return e7 = o5.sent(), "svg" === t8.toLowerCase() ? (r6 = new XMLSerializer(), n5 = r6.serializeToString(e7.getElement()), [2, new Blob(['<?xml version="1.0" standalone="no"?>\r\n' + n5], { type: "image/svg+xml" })]) : [2, new Promise(function(r7) {
                        return e7.getCanvas().toBlob(r7, "image/".concat(t8), 1);
                      })];
                  }
                });
              });
            }, t7.prototype.download = function(t8) {
              return J3(this, void 0, void 0, function() {
                var e7, r6, n5, o5, i5;
                return K3(this, function(s5) {
                  switch (s5.label) {
                    case 0:
                      if (!this._qr)
                        throw "QR code is empty";
                      return e7 = "png", r6 = "qr", "string" == typeof t8 ? (e7 = t8, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t8 && null !== t8 && (t8.name && (r6 = t8.name), t8.extension && (e7 = t8.extension)), [4, this._getQRStylingElement(e7)];
                    case 1:
                      return n5 = s5.sent(), "svg" === e7.toLowerCase() ? (o5 = new XMLSerializer(), i5 = '<?xml version="1.0" standalone="no"?>\r\n' + (i5 = o5.serializeToString(n5.getElement())), a4("data:image/svg+xml;charset=utf-8," + encodeURIComponent(i5), "".concat(r6, ".svg"))) : a4(n5.getCanvas().toDataURL("image/".concat(e7)), "".concat(r6, ".").concat(e7)), [2];
                  }
                });
              });
            }, t7;
          }();
        })(), n4.default;
      })();
    });
  }
});

// src/main.tsx
init_virtual_process_polyfill();
init_buffer();
var import_react20 = __toESM(require_react(), 1);
var ReactDOMClient = __toESM(require_client(), 1);

// src/App/App.tsx
init_virtual_process_polyfill();
init_buffer();

// src/common/Button/Button.tsx
init_virtual_process_polyfill();
init_buffer();
var import_classnames = __toESM(require_classnames(), 1);
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Button = import_react.default.memo(function Button2(props2) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
    onClick: props2.onClick,
    type: props2.type,
    className: (0, import_classnames.default)(
      "rounded-full py-4.5 px-9 transition-colors",
      { "pointer-events-none cursor-not-allowed opacity-20": props2.disabled },
      props2.className
    ),
    disabled: props2.disabled,
    children: props2.children
  });
});

// src/common/hooks/use-toggle.tsx
init_virtual_process_polyfill();
init_buffer();
var import_react2 = __toESM(require_react(), 1);
function useToggle(initialState = "off") {
  const [state, setState] = import_react2.default.useState(initialState);
  return {
    state,
    toggle: (s4 = state === "on" ? "off" : "on") => setState(s4)
  };
}

// src/const.tsx
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/client/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/core/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_virtual_process_polyfill();
init_buffer();
var import_bn = __toESM(require_bn());

// node_modules/@walletconnect/encoding/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer2.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer2.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad2 = padding.repeat(diff);
    result = left ? pad2 + str : str + pad2;
  }
  return result;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_virtual_process_polyfill();
init_buffer();
var import_js_sha3 = __toESM(require_sha3());

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
init_virtual_process_polyfill();
init_buffer();
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e5) => e5.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error2 = getErrorByCode(response.error.code);
    if (error2.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error2.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e5, url, type2) {
  return e5.message.includes("getaddrinfo ENOTFOUND") || e5.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e5;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
init_virtual_process_polyfill();
init_buffer();
var import_environment = __toESM(require_cjs3());
__reExport(env_exports, __toESM(require_cjs3()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports4, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
init_virtual_process_polyfill();
init_buffer();
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error2, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error2, data)
  };
}
function formatErrorMessage(error2, data) {
  if (typeof error2 === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error2 === "string") {
    error2 = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error2 });
  }
  if (typeof data !== "undefined") {
    error2.data = data;
  }
  if (isReservedErrorCode(error2.code)) {
    error2 = getErrorByCode(error2.code);
  }
  return error2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
init_virtual_process_polyfill();
init_buffer();
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x5) => x5.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
init_virtual_process_polyfill();
init_buffer();
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a4, b3) => {
    for (b3 = a4 = ""; a4++ < 36; b3 += a4 * 51 & 52 ? (a4 ^ 15 ? 8 ^ Math.random() * (a4 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b3;
  })();
  return result;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request3) {
  if (request3.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request3.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i4 = 0; i4 < address.length; i4++) {
    if (parseInt(hash[i4], 16) > 7) {
      checksum += address[i4].toUpperCase();
    } else {
      checksum += address[i4];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key2) => {
    if ((typeof txDataRPC[key2] === "undefined" || typeof txDataRPC[key2] === "string" && !txDataRPC[key2].trim().length) && prunable.includes(key2)) {
      delete txDataRPC[key2];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/payload.js
init_virtual_process_polyfill();
init_buffer();
function formatRpcError(error2) {
  const message = error2.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error2 && !error2.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error2.data) {
    result.data = error2.data;
  }
  return result;
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/session.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils = __toESM(require_query_string());
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path2 = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path3) {
    const separator = "@";
    const values = path3.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path2);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_virtual_process_polyfill();
init_buffer();
var import_bn2 = __toESM(require_bn2());

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_virtual_process_polyfill();
init_buffer();
var import_js_sha32 = __toESM(require_sha3());

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/payload.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/session.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils2 = __toESM(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString2(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString2(queryString) {
  return queryStringUtils2.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils2.stringify(queryParams);
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
init_virtual_process_polyfill();
init_buffer();
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS = typeof window.WebSocket !== "undefined" ? window.WebSocket : require_browser();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error2) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events2 = this._events.filter((event2) => event2.event === "message");
      if (events2 && events2.length) {
        events2.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e5) {
    const events2 = this._events.filter((event) => event.event === "error");
    if (events2 && events2.length) {
      events2.forEach((event) => event.callback(e5));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue3 = this._queue;
    queue3.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version5) {
  var _a2, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version5,
    env: "browser",
    host: ((_a2 = getLocation2()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version5,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
init_virtual_process_polyfill();
init_buffer();
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
init_virtual_process_polyfill();
init_buffer();
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x5) => x5.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error2 = new Error(payload.error.message);
        eventEmitter.callback(error2, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
init_virtual_process_polyfill();
init_buffer();
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname2 = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname2 = hostname2.split(":")[0];
  hostname2 = hostname2.split("?")[0];
  return hostname2;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key: key2 } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request3 = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request3.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request3);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error2) {
      endInstantRequest();
      throw error2;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error2, payload) => {
        if (error2) {
          return reject(error2);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request3 = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request3.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request3, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request3 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request3, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request3 = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request3);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request3 = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request3 = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request3 = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request3 = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request3 = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request3 = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request3);
    return result;
  }
  unsafeSend(request3, options) {
    this._sendRequest(request3, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request3, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request3.id, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request3, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request3.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request3.params) {
          request3.params[0] = parseTransactionData(request3.params[0]);
        }
        break;
      case "personal_sign":
        if (request3.params) {
          request3.params = parsePersonalSign(request3.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request3);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request3, options) {
    const callRequest = this._formatRequest(request3);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request3, errorMsg, options) {
    this._sendRequest(request3, options);
    this._subscribeToSessionResponse(request3.id, errorMsg);
  }
  _sendCallRequest(request3, options) {
    this._sendRequest(request3, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request: request3, options }]
    });
    return this._subscribeToCallResponse(request3.id);
  }
  _formatRequest(request3) {
    if (typeof request3.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request3.id === "undefined" ? payloadId2() : request3.id,
      jsonrpc: "2.0",
      method: request3.method,
      params: typeof request3.params === "undefined" ? [] : request3.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error2 = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error: error2 });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error2) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error2, payload) => {
      const { request: request3 } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request3.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error2, payload) => {
      if (error2) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error2.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version5 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version5}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return { handshakeTopic, bridge, key: key2 };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error2, payload) => {
      if (error2) {
        throw error2;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error3) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
init_virtual_process_polyfill();
init_buffer();
var env2 = __toESM(require_cjs3());
function randomBytes(length) {
  const browserCrypto = env2.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
init_virtual_process_polyfill();
init_buffer();
var env3 = __toESM(require_cjs3());

// node_modules/@walletconnect/crypto/dist/esm/constants/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
init_virtual_process_polyfill();
init_buffer();
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
init_virtual_process_polyfill();
init_buffer();
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
init_virtual_process_polyfill();
init_buffer();
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
init_virtual_process_polyfill();
init_buffer();
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type2) {
  return type2 === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type2) {
  return type2 === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type2 = AES_BROWSER_ALGO) {
  return env3.getSubtleCrypto().importKey("raw", buffer, getAlgo(type2), true, getOps(type2));
}
async function browserAesEncrypt(iv, key2, data) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key2, data) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env3.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env3.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key2, data) {
  return browserAesEncrypt(iv, key2, data);
}
function aesCbcDecrypt(iv, key2, data) {
  return browserAesDecrypt(iv, key2, data);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
init_virtual_process_polyfill();
init_buffer();
__reExport(env_exports2, __toESM(require_cjs3()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
init_virtual_process_polyfill();
init_buffer();
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding.length);
    result.set(plaintext);
    result.set(padding, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
init_virtual_process_polyfill();
init_buffer();
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i4 = 0; i4 < arr1.length; i4++) {
    res |= arr1[i4] ^ arr2[i4];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function hmacSha256Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key2, msg) {
  const result = await browserHmacSha512Sign(key2, msg);
  return result;
}
async function hmacSha512Verify(key2, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key2, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
init_virtual_process_polyfill();
init_buffer();
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_virtual_process_polyfill();
init_buffer();
var import_bn3 = __toESM(require_bn3());
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_virtual_process_polyfill();
init_buffer();
var import_js_sha33 = __toESM(require_sha3());

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/payload.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/session.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils3 = __toESM(require_query_string());

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key2, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key2) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error2) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports5,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var import_qrcode_modal = __toESM(require_cjs4());

// node_modules/@walletconnect/http-connection/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
var import_eventemitter3 = __toESM(require_eventemitter3());
var import_xhr2_cookies = __toESM(require_dist());

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_virtual_process_polyfill();
init_buffer();
var import_bn4 = __toESM(require_bn4());

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_virtual_process_polyfill();
init_buffer();
var import_js_sha34 = __toESM(require_sha3());

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/payload.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/session.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/http-connection/node_modules/@walletconnect/utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils4 = __toESM(require_query_string());

// node_modules/@walletconnect/http-connection/dist/esm/index.js
var XHR = getFromWindow2("XMLHttpRequest") || import_xhr2_cookies.XMLHttpRequest;
var HTTPConnection = class extends import_eventemitter3.default {
  constructor(url) {
    super();
    this.url = url;
  }
  formatError(payload, message, code = -1) {
    return {
      error: { message, code },
      id: payload.id,
      jsonrpc: payload.jsonrpc
    };
  }
  send(payload, internal) {
    return new Promise((resolve) => {
      if (payload.method === "eth_subscribe") {
        const error2 = this.formatError(payload, "Subscriptions are not supported by this HTTP endpoint");
        this.emit("error", error2);
        return resolve(error2);
      }
      const xhr2 = new XHR();
      let responded = false;
      const res = (err, result) => {
        if (!responded) {
          xhr2.abort();
          responded = true;
          if (internal) {
            internal(err, result);
          } else {
            const { id, jsonrpc } = payload;
            const response = err ? { id, jsonrpc, error: { message: err.message, code: err.code } } : { id, jsonrpc, result };
            this.emit("payload", response);
            resolve(response);
          }
        }
      };
      xhr2.open("POST", this.url, true);
      xhr2.setRequestHeader("Content-Type", "application/json");
      xhr2.timeout = 60 * 1e3;
      xhr2.onerror = res;
      xhr2.ontimeout = res;
      xhr2.onreadystatechange = () => {
        if (xhr2.readyState === 4) {
          try {
            const response = JSON.parse(xhr2.responseText);
            res(response.error, response.result);
          } catch (e5) {
            res(e5);
          }
        }
      };
      xhr2.send(JSON.stringify(payload));
    });
  }
};
var esm_default4 = HTTPConnection;

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/index.js
init_virtual_process_polyfill();
init_buffer();
init_esm2();

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/constants.js
init_virtual_process_polyfill();
init_buffer();
var signingMethods5 = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var infuraNetworks5 = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/encoding.js
init_virtual_process_polyfill();
init_buffer();
var import_bn5 = __toESM(require_bn5());
function convertUtf8ToHex5(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/ethereum.js
init_virtual_process_polyfill();
init_buffer();
var import_js_sha35 = __toESM(require_sha3());

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/misc.js
init_virtual_process_polyfill();
init_buffer();
var payloadId3 = payloadId;
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks5[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/validators.js
init_virtual_process_polyfill();
init_buffer();
function isEmptyArray5(array) {
  return !(array && array.length);
}
function isHexString6(value, length) {
  return isHexString(value, length);
}

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/ethereum.js
function parsePersonalSign2(params) {
  if (!isEmptyArray5(params) && !isHexString6(params[0])) {
    params[0] = convertUtf8ToHex5(params[0]);
  }
  return params;
}

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/payload.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/session.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@walletconnect/web3-provider/node_modules/@walletconnect/utils/dist/esm/url.js
init_virtual_process_polyfill();
init_buffer();
var queryStringUtils5 = __toESM(require_query_string());

// node_modules/@walletconnect/web3-provider/dist/esm/index.js
var ProviderEngine = require_web3_provider_engine();
var CacheSubprovider = require_cache();
var FixtureSubprovider = require_fixture();
var FilterSubprovider = require_filters();
var HookedWalletSubprovider = require_hooked_wallet();
var NonceSubprovider = require_nonce_tracker();
var SubscriptionsSubprovider = require_subscriptions();
var WalletConnectProvider = class extends ProviderEngine {
  constructor(opts) {
    super({ pollingInterval: opts.pollingInterval || 8e3 });
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModal = import_qrcode_modal.default;
    this.qrcodeModalOptions = void 0;
    this.rpc = null;
    this.infuraId = "";
    this.http = null;
    this.isConnecting = false;
    this.connected = false;
    this.connectCallbacks = [];
    this.accounts = [];
    this.chainId = 1;
    this.rpcUrl = "";
    this.enable = async () => {
      const wc = await this.getWalletConnector();
      if (wc) {
        this.start();
        this.subscribeWalletConnector();
        return wc.accounts;
      } else {
        throw new Error("Failed to connect to WalleConnect");
      }
    };
    this.request = async (payload) => {
      return this.send(payload);
    };
    this.send = async (payload, callback) => {
      if (typeof payload === "string") {
        const method = payload;
        let params = callback;
        if (method === "personal_sign") {
          params = parsePersonalSign2(params);
        }
        return this.sendAsyncPromise(method, params);
      }
      payload = Object.assign({ id: payloadId3(), jsonrpc: "2.0" }, payload);
      if (payload.method === "personal_sign") {
        payload.params = parsePersonalSign2(payload.params);
      }
      if (callback) {
        this.sendAsync(payload, callback);
        return;
      }
      return this.sendAsyncPromise(payload.method, payload.params);
    };
    this.onConnect = (callback) => {
      this.connectCallbacks.push(callback);
    };
    this.triggerConnect = (result) => {
      if (this.connectCallbacks && this.connectCallbacks.length) {
        this.connectCallbacks.forEach((callback) => callback(result));
      }
    };
    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || "https://bridge.walletconnect.org";
    this.qrcode = typeof opts.qrcode === "undefined" || opts.qrcode !== false;
    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;
    this.qrcodeModalOptions = opts.qrcodeModalOptions;
    this.wc = opts.connector || new esm_default3({
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? this.qrcodeModal : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    });
    this.rpc = opts.rpc || null;
    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== "string" || !opts.infuraId.trim())) {
      throw new Error("Missing one of the required parameters: rpc or infuraId");
    }
    this.infuraId = opts.infuraId || "";
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.initialize();
  }
  get isWalletConnect() {
    return true;
  }
  get connector() {
    return this.wc;
  }
  get walletMeta() {
    return this.wc.peerMeta;
  }
  async disconnect() {
    this.close();
  }
  async close() {
    const wc = await this.getWalletConnector({ disableSessionCreation: true });
    await wc.killSession();
    await this.onDisconnect();
  }
  async handleRequest(payload) {
    try {
      let response;
      let result = null;
      const wc = await this.getWalletConnector();
      switch (payload.method) {
        case "wc_killSession":
          await this.close();
          result = null;
          break;
        case "eth_accounts":
          result = wc.accounts;
          break;
        case "eth_coinbase":
          result = wc.accounts[0];
          break;
        case "eth_chainId":
          result = wc.chainId;
          break;
        case "net_version":
          result = wc.chainId;
          break;
        case "eth_uninstallFilter":
          this.sendAsync(payload, (_5) => _5);
          result = true;
          break;
        default:
          response = await this.handleOtherRequests(payload);
      }
      if (response) {
        return response;
      }
      return this.formatResponse(payload, result);
    } catch (error2) {
      this.emit("error", error2);
      throw error2;
    }
  }
  async handleOtherRequests(payload) {
    if (!signingMethods5.includes(payload.method) && payload.method.startsWith("eth_")) {
      return this.handleReadRequests(payload);
    }
    const wc = await this.getWalletConnector();
    const result = await wc.sendCustomRequest(payload);
    return this.formatResponse(payload, result);
  }
  async handleReadRequests(payload) {
    if (!this.http) {
      const error2 = new Error("HTTP Connection not available");
      this.emit("error", error2);
      throw error2;
    }
    return this.http.send(payload);
  }
  formatResponse(payload, result) {
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  getWalletConnector(opts = {}) {
    const { disableSessionCreation = false } = opts;
    return new Promise((resolve, reject) => {
      const wc = this.wc;
      if (this.isConnecting) {
        this.onConnect((x5) => resolve(x5));
      } else if (!wc.connected && !disableSessionCreation) {
        this.isConnecting = true;
        wc.on("modal_closed", () => {
          reject(new Error("User closed modal"));
        });
        wc.createSession({ chainId: this.chainId }).then(() => {
          wc.on("connect", (error2, payload) => {
            if (error2) {
              this.isConnecting = false;
              return reject(error2);
            }
            this.isConnecting = false;
            this.connected = true;
            if (payload) {
              this.updateState(payload.params[0]);
            }
            this.emit("connect");
            this.triggerConnect(wc);
            resolve(wc);
          });
        }).catch((error2) => {
          this.isConnecting = false;
          reject(error2);
        });
      } else {
        if (!this.connected) {
          this.connected = true;
          this.updateState(wc.session);
        }
        resolve(wc);
      }
    });
  }
  async subscribeWalletConnector() {
    const wc = await this.getWalletConnector();
    wc.on("disconnect", (error2) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.onDisconnect();
    });
    wc.on("session_update", (error2, payload) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.updateState(payload.params[0]);
    });
  }
  async onDisconnect() {
    await this.stop();
    this.emit("close", 1e3, "Connection closed");
    this.emit("disconnect", 1e3, "Connection disconnected");
    this.connected = false;
  }
  async updateState(sessionParams) {
    const { accounts, chainId, networkId, rpcUrl } = sessionParams;
    if (!this.accounts || accounts && this.accounts !== accounts) {
      this.accounts = accounts;
      this.emit("accountsChanged", accounts);
    }
    if (!this.chainId || chainId && this.chainId !== chainId) {
      this.chainId = chainId;
      this.emit("chainChanged", chainId);
    }
    if (!this.networkId || networkId && this.networkId !== networkId) {
      this.networkId = networkId;
      this.emit("networkChanged", networkId);
    }
    this.updateRpcUrl(this.chainId, rpcUrl || "");
  }
  updateRpcUrl(chainId, rpcUrl = "") {
    const rpc = { infuraId: this.infuraId, custom: this.rpc || void 0 };
    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);
    if (rpcUrl) {
      this.rpcUrl = rpcUrl;
      this.updateHttpConnection();
    } else {
      this.emit("error", new Error(`No RPC Url available for chainId: ${chainId}`));
    }
  }
  updateHttpConnection() {
    if (this.rpcUrl) {
      this.http = new esm_default4(this.rpcUrl);
      this.http.on("payload", (payload) => this.emit("payload", payload));
      this.http.on("error", (error2) => this.emit("error", error2));
    }
  }
  sendAsyncPromise(method, params) {
    return new Promise((resolve, reject) => {
      this.sendAsync({
        id: payloadId3(),
        jsonrpc: "2.0",
        method,
        params: params || []
      }, (error2, response) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve(response.result);
      });
    });
  }
  initialize() {
    this.updateRpcUrl(this.chainId);
    this.addProvider(new FixtureSubprovider({
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true,
      net_listening: true,
      web3_clientVersion: `WalletConnect/v1.x.x/javascript`
    }));
    this.addProvider(new CacheSubprovider());
    this.addProvider(new SubscriptionsSubprovider());
    this.addProvider(new FilterSubprovider());
    this.addProvider(new NonceSubprovider());
    this.addProvider(new HookedWalletSubprovider(this.configWallet()));
    this.addProvider({
      handleRequest: async (payload, next, end) => {
        try {
          const { error: error2, result } = await this.handleRequest(payload);
          end(error2, result);
        } catch (error2) {
          end(error2);
        }
      },
      setEngine: (_5) => _5
    });
  }
  configWallet() {
    return {
      getAccounts: async (cb) => {
        try {
          const wc = await this.getWalletConnector();
          const accounts = wc.accounts;
          if (accounts && accounts.length) {
            cb(null, accounts);
          } else {
            cb(new Error("Failed to get accounts"));
          }
        } catch (error2) {
          cb(error2);
        }
      },
      processMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signMessage([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processPersonalMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processSignTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.sendTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTypedMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTypedData([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      }
    };
  }
};
var esm_default5 = WalletConnectProvider;

// src/const.tsx
var provider = new esm_default5({
  rpc: {
    80001: "https://rpc-mumbai.maticvigil.com/"
  },
  clientMeta: {
    name: "meshaApp",
    description: "Biggest airdrop is here! World ID example app.",
    url: "https://github.com/worldcoin/world-id-example-airdrop-dapp",
    icons: [
      document.head.querySelector("link[rel~=icon]").href
    ]
  }
});
var ACTION_ID = process.env.WLD_ACTION_ID || "wid_staging_e98527aa60da41d731308fe094997c9c";
var CONTRACT_ADDRESS = process.env.WLD_CONTRACT_ADDRESS || "0x9573e4b5B032847aF3E07A960fDa9A04da24890c";

// src/utils.ts
init_virtual_process_polyfill();
init_buffer();
function midEllipsis(input, maxLength) {
  if (input.length <= maxLength) {
    return input;
  }
  const middle = Math.ceil(input.length / 2);
  const excess = Math.ceil((input.length - maxLength) / 2);
  return `${input.substring(0, middle - excess)}...${input.substring(
    middle + excess
  )}`;
}

// node_modules/@worldcoin/id/dist/index.js
init_virtual_process_polyfill();
init_buffer();
var f4 = __toESM(require_react(), 1);
var import_js_sha36 = __toESM(require_sha3(), 1);

// node_modules/@worldcoin/id/node_modules/@ethersproject/bytes/lib.esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@ethersproject/logger/lib.esm/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@ethersproject/logger/lib.esm/_version.js
init_virtual_process_polyfill();
init_buffer();
var version3 = "logger/5.7.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error2) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error2) {
    return error2.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version5) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version5,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i4 = 0; i4 < value.length; i4++) {
            hex += HEX[value[i4] >> 4];
            hex += HEX[value[i4] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error3) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error2 = new Error(message);
    error2.reason = reason;
    error2.code = code;
    Object.keys(params).forEach(function(key2) {
      error2[key2] = params[key2];
    });
    return error2;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version3);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version5) {
    return new Logger(version5);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@worldcoin/id/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_virtual_process_polyfill();
init_buffer();
var version4 = "bytes/5.6.1";

// node_modules/@worldcoin/id/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version4);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString7(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i4 = 0; i4 < value.length; i4++) {
    const v5 = value[i4];
    if (!isInteger(v5) || v5 < 0 || v5 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString7(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i4 = 0; i4 < hex.length; i4 += 2) {
      result.push(parseInt(hex.substring(i4, i4 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat3(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function isHexString7(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString7(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i4 = 0; i4 < value.length; i4++) {
      let v5 = value[i4];
      result += HexCharacters[(v5 & 240) >> 4] + HexCharacters[v5 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}

// node_modules/@stitches/react/dist/index.mjs
init_virtual_process_polyfill();
init_buffer();
var import_react3 = __toESM(require_react(), 1);
var e3 = "colors";
var t3 = "sizes";
var r3 = "space";
var n2 = { gap: r3, gridGap: r3, columnGap: r3, gridColumnGap: r3, rowGap: r3, gridRowGap: r3, inset: r3, insetBlock: r3, insetBlockEnd: r3, insetBlockStart: r3, insetInline: r3, insetInlineEnd: r3, insetInlineStart: r3, margin: r3, marginTop: r3, marginRight: r3, marginBottom: r3, marginLeft: r3, marginBlock: r3, marginBlockEnd: r3, marginBlockStart: r3, marginInline: r3, marginInlineEnd: r3, marginInlineStart: r3, padding: r3, paddingTop: r3, paddingRight: r3, paddingBottom: r3, paddingLeft: r3, paddingBlock: r3, paddingBlockEnd: r3, paddingBlockStart: r3, paddingInline: r3, paddingInlineEnd: r3, paddingInlineStart: r3, top: r3, right: r3, bottom: r3, left: r3, scrollMargin: r3, scrollMarginTop: r3, scrollMarginRight: r3, scrollMarginBottom: r3, scrollMarginLeft: r3, scrollMarginX: r3, scrollMarginY: r3, scrollMarginBlock: r3, scrollMarginBlockEnd: r3, scrollMarginBlockStart: r3, scrollMarginInline: r3, scrollMarginInlineEnd: r3, scrollMarginInlineStart: r3, scrollPadding: r3, scrollPaddingTop: r3, scrollPaddingRight: r3, scrollPaddingBottom: r3, scrollPaddingLeft: r3, scrollPaddingX: r3, scrollPaddingY: r3, scrollPaddingBlock: r3, scrollPaddingBlockEnd: r3, scrollPaddingBlockStart: r3, scrollPaddingInline: r3, scrollPaddingInlineEnd: r3, scrollPaddingInlineStart: r3, fontSize: "fontSizes", background: e3, backgroundColor: e3, backgroundImage: e3, borderImage: e3, border: e3, borderBlock: e3, borderBlockEnd: e3, borderBlockStart: e3, borderBottom: e3, borderBottomColor: e3, borderColor: e3, borderInline: e3, borderInlineEnd: e3, borderInlineStart: e3, borderLeft: e3, borderLeftColor: e3, borderRight: e3, borderRightColor: e3, borderTop: e3, borderTopColor: e3, caretColor: e3, color: e3, columnRuleColor: e3, fill: e3, outline: e3, outlineColor: e3, stroke: e3, textDecorationColor: e3, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t3, minBlockSize: t3, maxBlockSize: t3, inlineSize: t3, minInlineSize: t3, maxInlineSize: t3, width: t3, minWidth: t3, maxWidth: t3, height: t3, minHeight: t3, maxHeight: t3, flexBasis: t3, gridTemplateColumns: t3, gridTemplateRows: t3, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
var i3 = (e5, t5) => "function" == typeof t5 ? { "()": Function.prototype.toString.call(t5) } : t5;
var o3 = () => {
  const e5 = /* @__PURE__ */ Object.create(null);
  return (t5, r5, ...n4) => {
    const o4 = ((e6) => JSON.stringify(e6, i3))(t5);
    return o4 in e5 ? e5[o4] : e5[o4] = r5(t5, ...n4);
  };
};
var l3 = Symbol.for("sxs.internal");
var s3 = (e5, t5) => Object.defineProperties(e5, Object.getOwnPropertyDescriptors(t5));
var a3 = (e5) => {
  for (const t5 in e5)
    return true;
  return false;
};
var { hasOwnProperty: c3 } = Object.prototype;
var d3 = (e5) => e5.includes("-") ? e5 : e5.replace(/[A-Z]/g, (e6) => "-" + e6.toLowerCase());
var g3 = /\s+(?![^()]*\))/;
var p3 = (e5) => (t5) => e5(..."string" == typeof t5 ? String(t5).split(g3) : [t5]);
var u3 = { appearance: (e5) => ({ WebkitAppearance: e5, appearance: e5 }), backfaceVisibility: (e5) => ({ WebkitBackfaceVisibility: e5, backfaceVisibility: e5 }), backdropFilter: (e5) => ({ WebkitBackdropFilter: e5, backdropFilter: e5 }), backgroundClip: (e5) => ({ WebkitBackgroundClip: e5, backgroundClip: e5 }), boxDecorationBreak: (e5) => ({ WebkitBoxDecorationBreak: e5, boxDecorationBreak: e5 }), clipPath: (e5) => ({ WebkitClipPath: e5, clipPath: e5 }), content: (e5) => ({ content: e5.includes('"') || e5.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e5) ? e5 : `"${e5}"` }), hyphens: (e5) => ({ WebkitHyphens: e5, hyphens: e5 }), maskImage: (e5) => ({ WebkitMaskImage: e5, maskImage: e5 }), maskSize: (e5) => ({ WebkitMaskSize: e5, maskSize: e5 }), tabSize: (e5) => ({ MozTabSize: e5, tabSize: e5 }), textSizeAdjust: (e5) => ({ WebkitTextSizeAdjust: e5, textSizeAdjust: e5 }), userSelect: (e5) => ({ WebkitUserSelect: e5, userSelect: e5 }), marginBlock: p3((e5, t5) => ({ marginBlockStart: e5, marginBlockEnd: t5 || e5 })), marginInline: p3((e5, t5) => ({ marginInlineStart: e5, marginInlineEnd: t5 || e5 })), maxSize: p3((e5, t5) => ({ maxBlockSize: e5, maxInlineSize: t5 || e5 })), minSize: p3((e5, t5) => ({ minBlockSize: e5, minInlineSize: t5 || e5 })), paddingBlock: p3((e5, t5) => ({ paddingBlockStart: e5, paddingBlockEnd: t5 || e5 })), paddingInline: p3((e5, t5) => ({ paddingInlineStart: e5, paddingInlineEnd: t5 || e5 })) };
var h3 = /([\d.]+)([^]*)/;
var f3 = (e5, t5) => e5.length ? e5.reduce((e6, r5) => (e6.push(...t5.map((e7) => e7.includes("&") ? e7.replace(/&/g, /[ +>|~]/.test(r5) && /&.*&/.test(e7) ? `:is(${r5})` : r5) : r5 + " " + e7)), e6), []) : t5;
var m3 = (e5, t5) => e5 in b2 && "string" == typeof t5 ? t5.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t6, r5, n4, i4) => r5 + ("stretch" === n4 ? `-moz-available${i4};${d3(e5)}:${r5}-webkit-fill-available` : `-moz-fit-content${i4};${d3(e5)}:${r5}fit-content`) + i4) : String(t5);
var b2 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
var S2 = (e5) => e5 ? e5 + "-" : "";
var k3 = (e5, t5, r5) => e5.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e6, n4, i4, o4, l5) => "$" == o4 == !!i4 ? e6 : (n4 || "--" == o4 ? "calc(" : "") + "var(--" + ("$" === o4 ? S2(t5) + (l5.includes("$") ? "" : S2(r5)) + l5.replace(/\$/g, "-") : l5) + ")" + (n4 || "--" == o4 ? "*" + (n4 || "") + (i4 || "1") + ")" : ""));
var y3 = /\s*,\s*(?![^()]*\))/;
var B2 = Object.prototype.toString;
var $3 = (e5, t5, r5, n4, i4) => {
  let o4, l5, s4;
  const a4 = (e6, t6, r6) => {
    let c4, g4;
    const p5 = (e7) => {
      for (c4 in e7) {
        const R3 = 64 === c4.charCodeAt(0), z4 = R3 && Array.isArray(e7[c4]) ? e7[c4] : [e7[c4]];
        for (g4 of z4) {
          const e8 = /[A-Z]/.test($4 = c4) ? $4 : $4.replace(/-[^]/g, (e9) => e9[1].toUpperCase()), z5 = "object" == typeof g4 && g4 && g4.toString === B2 && (!n4.utils[e8] || !t6.length);
          if (e8 in n4.utils && !z5) {
            const t7 = n4.utils[e8];
            if (t7 !== l5) {
              l5 = t7, p5(t7(g4)), l5 = null;
              continue;
            }
          } else if (e8 in u3) {
            const t7 = u3[e8];
            if (t7 !== s4) {
              s4 = t7, p5(t7(g4)), s4 = null;
              continue;
            }
          }
          if (R3 && (b3 = c4.slice(1) in n4.media ? "@media " + n4.media[c4.slice(1)] : c4, c4 = b3.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e9, t7, r7, n5, i5, o5) => {
            const l6 = h3.test(t7), s5 = 0.0625 * (l6 ? -1 : 1), [a5, c5] = l6 ? [n5, t7] : [t7, n5];
            return "(" + ("=" === r7[0] ? "" : ">" === r7[0] === l6 ? "max-" : "min-") + a5 + ":" + ("=" !== r7[0] && 1 === r7.length ? c5.replace(h3, (e10, t8, n6) => Number(t8) + s5 * (">" === r7 ? 1 : -1) + n6) : c5) + (i5 ? ") and (" + (">" === i5[0] ? "min-" : "max-") + a5 + ":" + (1 === i5.length ? o5.replace(h3, (e10, t8, r8) => Number(t8) + s5 * (">" === i5 ? -1 : 1) + r8) : o5) : "") + ")";
          })), z5) {
            const e9 = R3 ? r6.concat(c4) : [...r6], n5 = R3 ? [...t6] : f3(t6, c4.split(y3));
            void 0 !== o4 && i4(x3(...o4)), o4 = void 0, a4(g4, n5, e9);
          } else
            void 0 === o4 && (o4 = [[], t6, r6]), c4 = R3 || 36 !== c4.charCodeAt(0) ? c4 : `--${S2(n4.prefix)}${c4.slice(1).replace(/\$/g, "-")}`, g4 = z5 ? g4 : "number" == typeof g4 ? g4 && e8 in I3 ? String(g4) + "px" : String(g4) : k3(m3(e8, null == g4 ? "" : g4), n4.prefix, n4.themeMap[e8]), o4[0].push(`${R3 ? `${c4} ` : `${d3(c4)}:`}${g4}`);
        }
      }
      var b3, $4;
    };
    p5(e6), void 0 !== o4 && i4(x3(...o4)), o4 = void 0;
  };
  a4(e5, t5, r5);
};
var x3 = (e5, t5, r5) => `${r5.map((e6) => `${e6}{`).join("")}${t5.length ? `${t5.join(",")}{` : ""}${e5.join(";")}${t5.length ? "}" : ""}${Array(r5.length ? r5.length + 1 : 0).join("}")}`;
var I3 = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
var R2 = (e5) => String.fromCharCode(e5 + (e5 > 25 ? 39 : 97));
var z3 = (e5) => ((e6) => {
  let t5, r5 = "";
  for (t5 = Math.abs(e6); t5 > 52; t5 = t5 / 52 | 0)
    r5 = R2(t5 % 52) + r5;
  return R2(t5 % 52) + r5;
})(((e6, t5) => {
  let r5 = t5.length;
  for (; r5; )
    e6 = 33 * e6 ^ t5.charCodeAt(--r5);
  return e6;
})(5381, JSON.stringify(e5)) >>> 0);
var W2 = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
var j3 = (e5) => {
  if (e5.href && !e5.href.startsWith(location.origin))
    return false;
  try {
    return !!e5.cssRules;
  } catch (e6) {
    return false;
  }
};
var E4 = (e5) => {
  let t5;
  const r5 = () => {
    const { cssRules: e6 } = t5.sheet;
    return [].map.call(e6, (r6, n5) => {
      const { cssText: i4 } = r6;
      let o4 = "";
      if (i4.startsWith("--sxs"))
        return "";
      if (e6[n5 - 1] && (o4 = e6[n5 - 1].cssText).startsWith("--sxs")) {
        if (!r6.cssRules.length)
          return "";
        for (const e7 in t5.rules)
          if (t5.rules[e7].group === r6)
            return `--sxs{--sxs:${[...t5.rules[e7].cache].join(" ")}}${i4}`;
        return r6.cssRules.length ? `${o4}${i4}` : "";
      }
      return i4;
    }).join("");
  }, n4 = () => {
    if (t5) {
      const { rules: e6, sheet: r6 } = t5;
      if (!r6.deleteRule) {
        for (; 3 === Object(Object(r6.cssRules)[0]).type; )
          r6.cssRules.splice(0, 1);
        r6.cssRules = [];
      }
      for (const t6 in e6)
        delete e6[t6];
    }
    const i4 = Object(e5).styleSheets || [];
    for (const e6 of i4)
      if (j3(e6)) {
        for (let i5 = 0, o5 = e6.cssRules; o5[i5]; ++i5) {
          const l6 = Object(o5[i5]);
          if (1 !== l6.type)
            continue;
          const s4 = Object(o5[i5 + 1]);
          if (4 !== s4.type)
            continue;
          ++i5;
          const { cssText: a4 } = l6;
          if (!a4.startsWith("--sxs"))
            continue;
          const c4 = a4.slice(14, -3).trim().split(/\s+/), d4 = W2[c4[0]];
          d4 && (t5 || (t5 = { sheet: e6, reset: n4, rules: {}, toString: r5 }), t5.rules[d4] = { group: s4, index: i5, cache: new Set(c4) });
        }
        if (t5)
          break;
      }
    if (!t5) {
      const i5 = (e6, t6) => ({ type: t6, cssRules: [], insertRule(e7, t7) {
        this.cssRules.splice(t7, 0, i5(e7, { import: 3, undefined: 1 }[(e7.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e6 ? `@media{${[].map.call(this.cssRules, (e7) => e7.cssText).join("")}}` : e6;
      } });
      t5 = { sheet: e5 ? (e5.head || e5).appendChild(document.createElement("style")).sheet : i5("", "text/css"), rules: {}, reset: n4, toString: r5 };
    }
    const { sheet: o4, rules: l5 } = t5;
    for (let e6 = W2.length - 1; e6 >= 0; --e6) {
      const t6 = W2[e6];
      if (!l5[t6]) {
        const r6 = W2[e6 + 1], n5 = l5[r6] ? l5[r6].index : o4.cssRules.length;
        o4.insertRule("@media{}", n5), o4.insertRule(`--sxs{--sxs:${e6}}`, n5), l5[t6] = { group: o4.cssRules[n5 + 1], index: n5, cache: /* @__PURE__ */ new Set([e6]) };
      }
      v3(l5[t6]);
    }
  };
  return n4(), t5;
};
var v3 = (e5) => {
  const t5 = e5.group;
  let r5 = t5.cssRules.length;
  e5.apply = (e6) => {
    try {
      t5.insertRule(e6, r5), ++r5;
    } catch (e7) {
    }
  };
};
var T4 = Symbol();
var w4 = o3();
var M3 = (e5, t5) => w4(e5, () => (...r5) => {
  let n4 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t6 of r5)
    if (null != t6)
      if (t6[l3]) {
        null == n4.type && (n4.type = t6[l3].type);
        for (const e6 of t6[l3].composers)
          n4.composers.add(e6);
      } else
        t6.constructor !== Object || t6.$$typeof ? null == n4.type && (n4.type = t6) : n4.composers.add(C3(t6, e5));
  return null == n4.type && (n4.type = "span"), n4.composers.size || n4.composers.add(["PJLV", {}, [], [], {}, []]), P3(e5, n4, t5);
});
var C3 = ({ variants: e5, compoundVariants: t5, defaultVariants: r5, ...n4 }, i4) => {
  const o4 = `${S2(i4.prefix)}c-${z3(n4)}`, l5 = [], s4 = [], d4 = /* @__PURE__ */ Object.create(null), g4 = [];
  for (const e6 in r5)
    d4[e6] = String(r5[e6]);
  if ("object" == typeof e5 && e5)
    for (const t6 in e5) {
      p5 = d4, u5 = t6, c3.call(p5, u5) || (d4[t6] = "undefined");
      const r6 = e5[t6];
      for (const e6 in r6) {
        const n5 = { [t6]: String(e6) };
        "undefined" === String(e6) && g4.push(t6);
        const i5 = r6[e6], o5 = [n5, i5, !a3(i5)];
        l5.push(o5);
      }
    }
  var p5, u5;
  if ("object" == typeof t5 && t5)
    for (const e6 of t5) {
      let { css: t6, ...r6 } = e6;
      t6 = "object" == typeof t6 && t6 || {};
      for (const e7 in r6)
        r6[e7] = String(r6[e7]);
      const n5 = [r6, t6, !a3(t6)];
      s4.push(n5);
    }
  return [o4, n4, l5, s4, d4, g4];
};
var P3 = (e5, t5, r5) => {
  const [n4, i4, o4, a4] = L3(t5.composers), c4 = "function" == typeof t5.type || t5.type.$$typeof ? ((e6) => {
    function t6() {
      for (let r6 = 0; r6 < t6[T4].length; r6++) {
        const [n5, i5] = t6[T4][r6];
        e6.rules[n5].apply(i5);
      }
      return t6[T4] = [], null;
    }
    return t6[T4] = [], t6.rules = {}, W2.forEach((e7) => t6.rules[e7] = { apply: (r6) => t6[T4].push([e7, r6]) }), t6;
  })(r5) : null, d4 = (c4 || r5).rules, g4 = `.${n4}${i4.length > 1 ? `:where(.${i4.slice(1).join(".")})` : ""}`, p5 = (l5) => {
    l5 = "object" == typeof l5 && l5 || A4;
    const { css: s4, ...p6 } = l5, u5 = {};
    for (const e6 in o4)
      if (delete p6[e6], e6 in l5) {
        let t6 = l5[e6];
        "object" == typeof t6 && t6 ? u5[e6] = { "@initial": o4[e6], ...t6 } : (t6 = String(t6), u5[e6] = "undefined" !== t6 || a4.has(e6) ? t6 : o4[e6]);
      } else
        u5[e6] = o4[e6];
    const h5 = /* @__PURE__ */ new Set([...i4]);
    for (const [n5, i5, o5, l6] of t5.composers) {
      r5.rules.styled.cache.has(n5) || (r5.rules.styled.cache.add(n5), $3(i5, [`.${n5}`], [], e5, (e6) => {
        d4.styled.apply(e6);
      }));
      const t6 = O2(o5, u5, e5.media), s5 = O2(l6, u5, e5.media, true);
      for (const i6 of t6)
        if (void 0 !== i6)
          for (const [t7, o6, l7] of i6) {
            const i7 = `${n5}-${z3(o6)}-${t7}`;
            h5.add(i7);
            const s6 = (l7 ? r5.rules.resonevar : r5.rules.onevar).cache, a5 = l7 ? d4.resonevar : d4.onevar;
            s6.has(i7) || (s6.add(i7), $3(o6, [`.${i7}`], [], e5, (e6) => {
              a5.apply(e6);
            }));
          }
      for (const t7 of s5)
        if (void 0 !== t7)
          for (const [i6, o6] of t7) {
            const t8 = `${n5}-${z3(o6)}-${i6}`;
            h5.add(t8), r5.rules.allvar.cache.has(t8) || (r5.rules.allvar.cache.add(t8), $3(o6, [`.${t8}`], [], e5, (e6) => {
              d4.allvar.apply(e6);
            }));
          }
    }
    if ("object" == typeof s4 && s4) {
      const t6 = `${n4}-i${z3(s4)}-css`;
      h5.add(t6), r5.rules.inline.cache.has(t6) || (r5.rules.inline.cache.add(t6), $3(s4, [`.${t6}`], [], e5, (e6) => {
        d4.inline.apply(e6);
      }));
    }
    for (const e6 of String(l5.className || "").trim().split(/\s+/))
      e6 && h5.add(e6);
    const f5 = p6.className = [...h5].join(" ");
    return { type: t5.type, className: f5, selector: g4, props: p6, toString: () => f5, deferredInjector: c4 };
  };
  return s3(p5, { className: n4, selector: g4, [l3]: t5, toString: () => (r5.rules.styled.cache.has(n4) || p5(), n4) });
};
var L3 = (e5) => {
  let t5 = "";
  const r5 = [], n4 = {}, i4 = [];
  for (const [o4, , , , l5, s4] of e5) {
    "" === t5 && (t5 = o4), r5.push(o4), i4.push(...s4);
    for (const e6 in l5) {
      const t6 = l5[e6];
      (void 0 === n4[e6] || "undefined" !== t6 || s4.includes(t6)) && (n4[e6] = t6);
    }
  }
  return [t5, r5, n4, new Set(i4)];
};
var O2 = (e5, t5, r5, n4) => {
  const i4 = [];
  e:
    for (let [o4, l5, s4] of e5) {
      if (s4)
        continue;
      let e6, a4 = 0, c4 = false;
      for (e6 in o4) {
        const n5 = o4[e6];
        let i5 = t5[e6];
        if (i5 !== n5) {
          if ("object" != typeof i5 || !i5)
            continue e;
          {
            let e7, t6, o5 = 0;
            for (const l6 in i5) {
              if (n5 === String(i5[l6])) {
                if ("@initial" !== l6) {
                  const e8 = l6.slice(1);
                  (t6 = t6 || []).push(e8 in r5 ? r5[e8] : l6.replace(/^@media ?/, "")), c4 = true;
                }
                a4 += o5, e7 = true;
              }
              ++o5;
            }
            if (t6 && t6.length && (l5 = { ["@media " + t6.join(", ")]: l5 }), !e7)
              continue e;
          }
        }
      }
      (i4[a4] = i4[a4] || []).push([n4 ? "cv" : `${e6}-${o4[e6]}`, l5, c4]);
    }
  return i4;
};
var A4 = {};
var N3 = o3();
var D3 = (e5, t5) => N3(e5, () => (...r5) => {
  const n4 = () => {
    for (let n5 of r5) {
      n5 = "object" == typeof n5 && n5 || {};
      let r6 = z3(n5);
      if (!t5.rules.global.cache.has(r6)) {
        if (t5.rules.global.cache.add(r6), "@import" in n5) {
          let e6 = [].indexOf.call(t5.sheet.cssRules, t5.rules.themed.group) - 1;
          for (let r7 of [].concat(n5["@import"]))
            r7 = r7.includes('"') || r7.includes("'") ? r7 : `"${r7}"`, t5.sheet.insertRule(`@import ${r7};`, e6++);
          delete n5["@import"];
        }
        $3(n5, [], [], e5, (e6) => {
          t5.rules.global.apply(e6);
        });
      }
    }
    return "";
  };
  return s3(n4, { toString: n4 });
});
var H3 = o3();
var V2 = (e5, t5) => H3(e5, () => (r5) => {
  const n4 = `${S2(e5.prefix)}k-${z3(r5)}`, i4 = () => {
    if (!t5.rules.global.cache.has(n4)) {
      t5.rules.global.cache.add(n4);
      const i5 = [];
      $3(r5, [], [], e5, (e6) => i5.push(e6));
      const o4 = `@keyframes ${n4}{${i5.join("")}}`;
      t5.rules.global.apply(o4);
    }
    return n4;
  };
  return s3(i4, { get name() {
    return i4();
  }, toString: i4 });
});
var G2 = class {
  constructor(e5, t5, r5, n4) {
    this.token = null == e5 ? "" : String(e5), this.value = null == t5 ? "" : String(t5), this.scale = null == r5 ? "" : String(r5), this.prefix = null == n4 ? "" : String(n4);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S2(this.prefix) + S2(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
};
var F3 = o3();
var J2 = (e5, t5) => F3(e5, () => (r5, n4) => {
  n4 = "object" == typeof r5 && r5 || Object(n4);
  const i4 = `.${r5 = (r5 = "string" == typeof r5 ? r5 : "") || `${S2(e5.prefix)}t-${z3(n4)}`}`, o4 = {}, l5 = [];
  for (const t6 in n4) {
    o4[t6] = {};
    for (const r6 in n4[t6]) {
      const i5 = `--${S2(e5.prefix)}${t6}-${r6}`, s5 = k3(String(n4[t6][r6]), e5.prefix, t6);
      o4[t6][r6] = new G2(r6, s5, t6, e5.prefix), l5.push(`${i5}:${s5}`);
    }
  }
  const s4 = () => {
    if (l5.length && !t5.rules.themed.cache.has(r5)) {
      t5.rules.themed.cache.add(r5);
      const i5 = `${n4 === e5.theme ? ":root," : ""}.${r5}{${l5.join(";")}}`;
      t5.rules.themed.apply(i5);
    }
    return r5;
  };
  return { ...o4, get className() {
    return s4();
  }, selector: i4, toString: s4 };
});
var U2 = o3();
var X2;
var Y2 = o3();
var q3 = (e5) => {
  const t5 = ((e6) => {
    let t6 = false;
    const r5 = U2(e6, (e7) => {
      t6 = true;
      const r6 = "prefix" in (e7 = "object" == typeof e7 && e7 || {}) ? String(e7.prefix) : "", i4 = "object" == typeof e7.media && e7.media || {}, o4 = "object" == typeof e7.root ? e7.root || null : globalThis.document || null, l5 = "object" == typeof e7.theme && e7.theme || {}, s4 = { prefix: r6, media: i4, theme: l5, themeMap: "object" == typeof e7.themeMap && e7.themeMap || { ...n2 }, utils: "object" == typeof e7.utils && e7.utils || {} }, a4 = E4(o4), c4 = { css: M3(s4, a4), globalCss: D3(s4, a4), keyframes: V2(s4, a4), createTheme: J2(s4, a4), reset() {
        a4.reset(), c4.theme.toString();
      }, theme: {}, sheet: a4, config: s4, prefix: r6, getCssText: a4.toString, toString: a4.toString };
      return String(c4.theme = c4.createTheme(l5)), c4;
    });
    return t6 || r5.reset(), r5;
  })(e5);
  return t5.styled = (({ config: e6, sheet: t6 }) => Y2(e6, () => {
    const r5 = M3(e6, t6);
    return (...e7) => {
      const t7 = r5(...e7), n4 = t7[l3].type, i4 = import_react3.default.forwardRef((e8, r6) => {
        const i5 = e8 && e8.as || n4, { props: o4, deferredInjector: l5 } = t7(e8);
        return delete o4.as, o4.ref = r6, l5 ? import_react3.default.createElement(import_react3.default.Fragment, null, import_react3.default.createElement(i5, o4), import_react3.default.createElement(l5, null)) : import_react3.default.createElement(i5, o4);
      });
      return i4.className = t7.className, i4.displayName = `Styled.${n4.displayName || n4.name || n4}`, i4.selector = t7.selector, i4.toString = () => t7.selector, i4[l3] = t7[l3], i4;
    };
  }))(t5), t5;
};
var K2 = () => X2 || (X2 = q3());
var Q2 = (...e5) => K2().createTheme(...e5);
var _4 = (...e5) => K2().globalCss(...e5);
var ee = (...e5) => K2().keyframes(...e5);
var re = (...e5) => K2().styled(...e5);

// node_modules/kea/lib/index.esm.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/redux/es/redux.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
init_virtual_process_polyfill();
init_buffer();
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}

// node_modules/redux/es/redux.js
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type2 = typeof val;
  switch (type2) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type2;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate2(val))
    return "date";
  if (isError2(val))
    return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type2.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError2(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate2(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners3 = currentListeners = nextListeners;
    for (var i4 = 0; i4 < listeners3.length; i4++) {
      var listener = listeners3[i4];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
var legacy_createStore = createStore;
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e5) {
  }
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a4, b3) {
    return function() {
      return a4(b3.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore3) {
    return function() {
      var store = createStore3.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
function isCrushed() {
}
if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
  warning('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
}

// node_modules/kea/lib/index.esm.js
var React3 = __toESM(require_react());
var import_react4 = __toESM(require_react());

// node_modules/reselect/es/index.js
init_virtual_process_polyfill();
init_buffer();

// node_modules/reselect/es/defaultMemoize.js
init_virtual_process_polyfill();
init_buffer();
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals3) {
  var entry;
  return {
    get: function get3(key2) {
      if (entry && equals3(entry.key, key2)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key2, value) {
      entry = {
        key: key2,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals3) {
  var entries = [];
  function get3(key2) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals3(key2, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key2, value) {
    if (get3(key2) === NOT_FOUND) {
      entries.unshift({
        key: key2,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get: get3,
    put,
    getEntries,
    clear
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a4, b3) {
  return a4 === b3;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    var length = prev.length;
    for (var i4 = 0; i4 < length; i4++) {
      if (!equalityCheck(prev[i4], next[i4])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache.clear();
  };
  return memoized;
}

// node_modules/reselect/es/index.js
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector = memoize(function dependenciesChecker() {
      var params = [];
      var length = dependencies.length;
      for (var i4 = 0; i4 < length; i4++) {
        params.push(dependencies[i4].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  };
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(defaultMemoize);

// node_modules/kea/lib/index.esm.js
function isLogicWrapper(logic) {
  return "_isKea" in logic;
}
function isBuiltLogic(logic) {
  return "_isKeaBuild" in logic;
}
var shallowCompare = function shallowCompare2(obj1, obj2) {
  var keys1 = Object.keys(obj1);
  var keys2 = Object.keys(obj2);
  return keys1.length === keys2.length && keys1.every(function(key2) {
    return obj2.hasOwnProperty(key2) && obj1[key2] === obj2[key2];
  });
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key2 = sourceKeys[i4];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _unsupportedIterableToArray(o4, minLen) {
  if (!o4)
    return;
  if (typeof o4 === "string")
    return _arrayLikeToArray(o4, minLen);
  var n4 = Object.prototype.toString.call(o4).slice(8, -1);
  if (n4 === "Object" && o4.constructor)
    n4 = o4.constructor.name;
  if (n4 === "Map" || n4 === "Set")
    return Array.from(o4);
  if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
    return _arrayLikeToArray(o4, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
    arr2[i4] = arr[i4];
  return arr2;
}
function _createForOfIteratorHelperLoose(o4, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o4[Symbol.iterator] || o4["@@iterator"];
  if (it)
    return (it = it.call(o4)).next.bind(it);
  if (Array.isArray(o4) || (it = _unsupportedIterableToArray(o4)) || allowArrayLike && o4 && typeof o4.length === "number") {
    if (it)
      o4 = it;
    var i4 = 0;
    return function() {
      if (i4 >= o4.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o4[i4++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var reservedKeys = {
  key: true,
  path: true,
  pathString: true,
  props: true,
  inputs: true,
  wrapper: true,
  wrap: true,
  build: true,
  mount: true,
  unmount: true,
  isMounted: true,
  findMounted: true,
  extend: true
};
function activatePlugin(pluginToActivate) {
  var plugin = typeof pluginToActivate === "function" ? pluginToActivate() : pluginToActivate;
  var _getContext = getContext(), plugins = _getContext.plugins;
  if (!plugin.name) {
    throw new Error("[KEA] Tried to activate a plugin without a name!");
  }
  if (plugins.activated.find(function(p5) {
    return p5.name === plugin.name;
  })) {
    throw new Error('[KEA] Tried to activate plugin "' + plugin.name + '", but it was already installed!');
  }
  plugins.activated.push(plugin);
  if (plugin.defaults) {
    var fields = Object.keys(typeof plugin.defaults === "function" ? plugin.defaults() : plugin.defaults);
    for (var _i2 = 0, _fields = fields; _i2 < _fields.length; _i2++) {
      var key2 = _fields[_i2];
      if (true) {
        if (plugins.logicFields[key2] || reservedKeys[key2]) {
          console.error('[KEA] Plugin "' + plugin.name + '" redefines logic field "' + key2 + '". Previously defined by ' + (plugins.logicFields[key2] || "core"));
        }
      }
      plugins.logicFields[key2] = plugin.name;
    }
  }
  if (plugin.events) {
    for (var _i22 = 0, _Object$keys = Object.keys(plugin.events); _i22 < _Object$keys.length; _i22++) {
      var _key = _Object$keys[_i22];
      if (!plugins.events[_key]) {
        plugins.events[_key] = [];
      }
      plugins.events[_key].push(plugin.events[_key]);
    }
    plugin.events.afterPlugin && plugin.events.afterPlugin();
  }
}
function runPlugins(key2) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  var _getContext2 = getContext(), plugins = _getContext2.plugins, debug2 = _getContext2.options.debug;
  if (debug2) {
    var _console;
    (_console = console).log.apply(_console, ["[KEA] Event: " + key2].concat(args));
  }
  if (plugins && plugins.events[key2]) {
    plugins.events[key2].forEach(function(pluginFunction) {
      pluginFunction.apply(void 0, args);
    });
  }
}
var ATTACH_REDUCER$1 = "@KEA/ATTACH_REDUCER";
var DETACH_REDUCER$1 = "@KEA/DETACH_REDUCER";
var defaultState = {};
function initRootReducerTree(pathStart) {
  var _getContext = getContext(), _getContext$reducers = _getContext.reducers, tree = _getContext$reducers.tree, whitelist = _getContext$reducers.whitelist;
  if (!tree[pathStart]) {
    if (whitelist && !whitelist[pathStart]) {
      throw new Error(`[KEA] Can not start reducer's path with "` + pathStart + '"! Please add it to the whitelist');
    }
    tree[pathStart] = {};
    regenerateRootReducer(pathStart);
  }
}
function attachReducer(logic) {
  var path2 = logic.path, reducer = logic.reducer;
  var _getContext3 = getContext(), tree = _getContext3.reducers.tree, attachStrategy = _getContext3.options.attachStrategy, store = _getContext3.store;
  var pathStart = path2[0].toString();
  initRootReducerTree(pathStart);
  var pointer = tree;
  for (var i4 = 0; i4 < path2.length; i4++) {
    var pathPart = path2[i4].toString();
    if (i4 === path2.length - 1) {
      if (pointer[pathPart]) {
        if (i4 === 0 && typeof pointer[pathPart] === "object" && Object.keys(pointer[pathPart]).length === 0)
          ;
        else if (typeof pointer[pathPart] !== "function") {
          console.error('[KEA] Can not add reducer to "' + path2.join(".") + '". There is something in the way:', pointer[pathPart]);
          return;
        }
      }
      pointer[pathPart] = reducer;
    } else {
      if (!pointer[pathPart]) {
        pointer[pathPart] = {};
      }
      pointer = pointer[pathPart];
    }
  }
  regenerateRootReducer(pathStart);
  if (attachStrategy === "dispatch" || attachStrategy === "replace") {
    runPlugins("beforeAttach", logic);
    if (attachStrategy === "dispatch") {
      store && store.dispatch({
        type: ATTACH_REDUCER$1,
        payload: {
          path: path2,
          reducer
        }
      });
    } else if (attachStrategy === "replace") {
      store && store.replaceReducer(createReduxStoreReducer());
    }
    runPlugins("afterAttach", logic);
  }
}
function detachReducer(logic) {
  var path2 = logic.path;
  var _getContext4 = getContext(), tree = _getContext4.reducers.tree, detachStrategy = _getContext4.options.detachStrategy, store = _getContext4.store;
  var pathStart = path2[0].toString();
  if (detachStrategy === "persist") {
    return;
  }
  var detached = false;
  for (var i4 = path2.length - 2; i4 >= 0; i4--) {
    var pointerToHere = tree;
    for (var j4 = 0; j4 <= i4; j4++) {
      pointerToHere = pointerToHere && pointerToHere[path2[j4].toString()] || void 0;
    }
    if (pointerToHere) {
      if (Object.keys(pointerToHere).length === 0)
        ;
      else if (Object.keys(pointerToHere).length >= 1 && i4 === path2.length - 2 && typeof pointerToHere[path2[i4 + 1].toString()] === "function") {
        delete pointerToHere[path2[i4 + 1].toString()];
        detached = true;
      } else if (detached && Object.keys(pointerToHere).length >= 1 && i4 < path2.length - 2 && Object.keys(pointerToHere[path2[i4 + 1].toString()]).length === 0) {
        delete pointerToHere[path2[i4 + 1].toString()];
      } else {
        break;
      }
    }
  }
  regenerateRootReducer(pathStart);
  if (detached) {
    if (detachStrategy === "dispatch" || detachStrategy === "replace") {
      runPlugins("beforeDetach", logic);
      if (detachStrategy === "dispatch") {
        store && store.dispatch({
          type: DETACH_REDUCER$1,
          payload: {
            path: path2
          }
        });
      } else if (detachStrategy === "replace") {
        store && store.replaceReducer(createReduxStoreReducer());
      }
      runPlugins("afterDetach", logic);
    }
  }
}
function regenerateRootReducer(pathStart) {
  var _getContext5 = getContext(), _getContext5$reducers = _getContext5.reducers, tree = _getContext5$reducers.tree, roots = _getContext5$reducers.roots, whitelist = _getContext5$reducers.whitelist;
  if (pathStart !== "kea" && !whitelist && typeof tree[pathStart] === "object" && Object.keys(tree[pathStart]).length === 0) {
    delete roots[pathStart];
  } else {
    roots[pathStart] = recursiveCreateReducer(tree[pathStart]);
  }
  regenerateCombinedReducer();
}
function recursiveCreateReducer(treeNode) {
  if (typeof treeNode === "function") {
    return treeNode;
  }
  var children = {};
  Object.keys(treeNode).forEach(function(key2) {
    if (typeof treeNode[key2] !== "undefined") {
      children[key2] = recursiveCreateReducer(treeNode[key2]);
    }
  });
  if (Object.keys(children).length > 0) {
    return combineKeaReducers(children);
  } else {
    var emptyObj = {};
    return function() {
      return emptyObj;
    };
  }
}
function combineKeaReducers(reducers2) {
  return function combination(state, action, fullState) {
    if (state === void 0) {
      state = {};
    }
    var reducerKeys = Object.keys(reducers2);
    var stateChanged = Object.keys(state).length !== reducerKeys.length;
    var nextState = {};
    for (var _i2 = 0, _reducerKeys = reducerKeys; _i2 < _reducerKeys.length; _i2++) {
      var key2 = _reducerKeys[_i2];
      var reducer = reducers2[key2];
      var previousKeyState = state[key2];
      var nextKeyState = reducer(previousKeyState, action, fullState || state);
      if (typeof nextKeyState === "undefined") {
        throw new Error('[KEA] Reducer "' + key2 + '" returned undefined for action "' + (action && action.type) + '"');
      }
      nextState[key2] = nextKeyState;
      stateChanged = stateChanged || nextKeyState !== previousKeyState;
    }
    return stateChanged ? nextState : state;
  };
}
function regenerateCombinedReducer() {
  var _getContext$reducers2 = getContext().reducers, redux = _getContext$reducers2.redux, roots = _getContext$reducers2.roots;
  var reducers2 = _extends({}, redux, roots);
  getContext().reducers.combined = combineKeaReducers(reducers2);
}
function createReduxStoreReducer() {
  regenerateCombinedReducer();
  return function(state, action) {
    var _getContext$reducers$, _getContext$reducers3;
    if (state === void 0) {
      state = defaultState;
    }
    return (_getContext$reducers$ = (_getContext$reducers3 = getContext().reducers).combined) === null || _getContext$reducers$ === void 0 ? void 0 : _getContext$reducers$.call(_getContext$reducers3, state, action, state);
  };
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
var e4 = import_react4.default;
function h4(a4, b3) {
  return a4 === b3 && (0 !== a4 || 1 / a4 === 1 / b3) || a4 !== a4 && b3 !== b3;
}
var k4 = "function" === typeof Object.is ? Object.is : h4;
var l4 = e4.useState;
var m4 = e4.useEffect;
var n3 = e4.useLayoutEffect;
var p4 = e4.useDebugValue;
function q4(a4, b3) {
  var d4 = b3(), f5 = l4({ inst: { value: d4, getSnapshot: b3 } }), c4 = f5[0].inst, g4 = f5[1];
  n3(function() {
    c4.value = d4;
    c4.getSnapshot = b3;
    r4(c4) && g4({ inst: c4 });
  }, [a4, d4, b3]);
  m4(function() {
    r4(c4) && g4({ inst: c4 });
    return a4(function() {
      r4(c4) && g4({ inst: c4 });
    });
  }, [a4]);
  p4(d4);
  return d4;
}
function r4(a4) {
  var b3 = a4.getSnapshot;
  a4 = a4.value;
  try {
    var d4 = b3();
    return !k4(a4, d4);
  } catch (f5) {
    return true;
  }
}
function t4(a4, b3) {
  return b3();
}
var u4 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t4 : q4;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e4.useSyncExternalStore ? e4.useSyncExternalStore : u4;
var useSyncExternalStoreShim_development = {};
if (true) {
  (function() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    }
    var React8 = import_react4.default;
    var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error2(format3) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning("error", format3, args);
        }
      }
    }
    function printWarning(level, format3, args) {
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== "") {
          format3 += "%s";
          args = args.concat([stack]);
        }
        var argsWithFormat = args.map(function(item) {
          return String(item);
        });
        argsWithFormat.unshift("Warning: " + format3);
        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }
    function is(x5, y5) {
      return x5 === y5 && (x5 !== 0 || 1 / x5 === 1 / y5) || x5 !== x5 && y5 !== y5;
    }
    var objectIs = typeof Object.is === "function" ? Object.is : is;
    var useState = React8.useState, useEffect2 = React8.useEffect, useLayoutEffect = React8.useLayoutEffect, useDebugValue = React8.useDebugValue;
    var didWarnOld18Alpha = false;
    var didWarnUncachedGetSnapshot = false;
    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      {
        if (!didWarnOld18Alpha) {
          if (React8.startTransition !== void 0) {
            didWarnOld18Alpha = true;
            error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
          }
        }
      }
      var value = getSnapshot();
      {
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          if (!objectIs(value, cachedValue)) {
            error2("The result of getSnapshot should be cached to avoid an infinite loop");
            didWarnUncachedGetSnapshot = true;
          }
        }
      }
      var _useState = useState({
        inst: {
          value,
          getSnapshot
        }
      }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect(function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({
            inst
          });
        }
      }, [subscribe, value, getSnapshot]);
      useEffect2(function() {
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({
            inst
          });
        }
        var handleStoreChange = function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        };
        return subscribe(handleStoreChange);
      }, [subscribe]);
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      var prevValue = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(prevValue, nextValue);
      } catch (error3) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
      return getSnapshot();
    }
    var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isServerEnvironment = !canUseDOM;
    var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
    var useSyncExternalStore$2 = React8.useSyncExternalStore !== void 0 ? React8.useSyncExternalStore : shim2;
    useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }
  })();
}
if (false) {
  shim.exports = useSyncExternalStoreShim_production_min;
} else {
  shim.exports = useSyncExternalStoreShim_development;
}
var pauseCounter = 0;
var isPaused = function isPaused2() {
  return pauseCounter !== 0;
};
var getStoreState$1 = function getStoreState() {
  return getContext().store.getState();
};
function useSelector(selector) {
  return shim.exports.useSyncExternalStore(getContext().store.subscribe, function() {
    return selector(getStoreState$1());
  });
}
function useValues(logic) {
  var builtLogic = useMountedLogic(logic);
  return (0, import_react4.useMemo)(function() {
    var response = {};
    var _loop = function _loop2() {
      var key2 = _Object$keys[_i2];
      Object.defineProperty(response, key2, {
        get: function get3() {
          return useSelector(builtLogic.selectors[key2]);
        }
      });
    };
    for (var _i2 = 0, _Object$keys = Object.keys(builtLogic.selectors); _i2 < _Object$keys.length; _i2++) {
      _loop();
    }
    return response;
  }, [builtLogic.pathString]);
}
function useAllValues(logic) {
  var builtLogic = useMountedLogic(logic);
  var response = {};
  for (var _i2 = 0, _Object$keys2 = Object.keys(builtLogic.selectors); _i2 < _Object$keys2.length; _i2++) {
    var key2 = _Object$keys2[_i2];
    response[key2] = useSelector(builtLogic.selectors[key2]);
  }
  return response;
}
function useActions(logic) {
  var builtLogic = useMountedLogic(logic);
  return builtLogic["actions"];
}
var blankContext = /* @__PURE__ */ (0, import_react4.createContext)(void 0);
function useMountedLogic(logic) {
  var builtLogicContext = isLogicWrapper(logic) ? getContext().react.contexts.get(logic) : null;
  var defaultBuiltLogic = (0, import_react4.useContext)(builtLogicContext || blankContext);
  var builtLogic = isLogicWrapper(logic) ? defaultBuiltLogic || logic.build() : logic;
  var unmount = (0, import_react4.useRef)(void 0);
  if (!unmount.current) {
    batchChanges(function() {
      unmount.current = builtLogic.mount();
    });
  }
  var pathString = (0, import_react4.useRef)(builtLogic.pathString);
  if (pathString.current !== builtLogic.pathString) {
    batchChanges(function() {
      var _unmount$current;
      (_unmount$current = unmount.current) === null || _unmount$current === void 0 ? void 0 : _unmount$current.call(unmount);
      unmount.current = builtLogic.mount();
      pathString.current = builtLogic.pathString;
    });
  }
  (0, import_react4.useEffect)(function useMountedLogicEffect() {
    if (!unmount.current) {
      batchChanges(function() {
        unmount.current = builtLogic.mount();
        pathString.current = builtLogic.pathString;
      });
    }
    return function useMountedLogicEffectCleanup() {
      batchChanges(function() {
        unmount.current && unmount.current();
        unmount.current = void 0;
      });
    };
  }, []);
  return builtLogic;
}
var timeout;
function batchChanges(callback) {
  var previousState = getStoreState$1();
  pauseCounter += 1;
  try {
    callback();
  } catch (e5) {
  } finally {
    pauseCounter -= 1;
  }
  var newState = getStoreState$1();
  if (previousState !== newState) {
    timeout && window.clearTimeout(timeout);
    timeout = window.setTimeout(function() {
      return getContext().store.dispatch({
        type: "@KEA/FLUSH"
      });
    }, 0);
  }
}
var reduxDevToolsCompose = typeof window !== "undefined" && window["__REDUX_DEVTOOLS_EXTENSION_COMPOSE__"] ? window["__REDUX_DEVTOOLS_EXTENSION_COMPOSE__"] : compose;
var createDefaultOptions = function createDefaultOptions2() {
  return {
    paths: [],
    reducers: {},
    preloadedState: void 0,
    middleware: [],
    compose: reduxDevToolsCompose,
    enhancers: [],
    plugins: []
  };
};
function createStore2(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var context2 = getContext();
  if (!context2) {
    console.error("[KEA] Can not create a store without a Kea context.");
    return;
  }
  if (context2["__store"]) {
    console.error("[KEA] Already attached to a store! Exiting. Please reset the kea context before creating a store.");
    return;
  }
  var options = _extends({}, createDefaultOptions(), opts);
  context2.reducers.redux = _extends({}, options.reducers);
  runPlugins("beforeReduxStore", options);
  if (options.middleware.length > 0) {
    options.enhancers = [applyMiddleware.apply(void 0, options.middleware)].concat(options.enhancers);
  }
  var composeEnchancer = options.compose || compose;
  var finalCreateStore = composeEnchancer.apply(void 0, [pauseListenersEnhancer].concat(options.enhancers))(legacy_createStore);
  if (options.paths && options.paths.length > 0) {
    context2.reducers.whitelist = {};
    options.paths.forEach(function(pathStart) {
      context2.reducers.whitelist[pathStart] = true;
      initRootReducerTree(pathStart);
    });
  } else {
    initRootReducerTree("kea");
  }
  var store = finalCreateStore(createReduxStoreReducer(), _extends({}, options.preloadedState));
  context2["__store"] = store;
  runPlugins("afterReduxStore", options, store);
  return store;
}
var pauseListenersEnhancer = function pauseListenersEnhancer2(createStore3) {
  return function(reducer, initialState) {
    var store = createStore3(reducer, initialState);
    var storeSubscribe = store.subscribe;
    store.subscribe = function(observer) {
      var pausedObserver = function pausedObserver2() {
        if (!isPaused()) {
          observer();
        }
      };
      return storeSubscribe(pausedObserver);
    };
    return store;
  };
};
var _excluded = ["plugins", "createStore", "defaults"];
var context;
function getContext() {
  return context;
}
var getStoreState2 = function getStoreState3() {
  return getContext().store.getState();
};
function setContext(newContext) {
  context = newContext;
}
var contextId = 0;
function openContext(options, initial) {
  if (options === void 0) {
    options = {};
  }
  if (initial === void 0) {
    initial = false;
  }
  if (context) {
    console.error("[KEA] overwriting already opened context. This may lead to errors.");
  }
  var _options = options, plugins = _options.plugins, _options$createStore = _options.createStore, createStoreOptions = _options$createStore === void 0 ? true : _options$createStore, defaults3 = _options.defaults, otherOptions = _objectWithoutPropertiesLoose(_options, _excluded);
  var newContext = {
    contextId: "kea-context-" + contextId++,
    plugins: {
      activated: [],
      events: {},
      logicFields: {},
      contexts: {}
    },
    inputCounter: 0,
    reducerDefaults: defaults3,
    wrapperContexts: /* @__PURE__ */ new WeakMap(),
    buildHeap: [],
    mount: {
      counter: {},
      mounted: {}
    },
    react: {
      contexts: /* @__PURE__ */ new WeakMap()
    },
    reducers: {
      tree: {},
      roots: {},
      redux: {},
      whitelist: false,
      combined: void 0
    },
    store: void 0,
    __store: void 0,
    options: _extends({
      debug: false,
      proxyFields: true,
      flatDefaults: false,
      attachStrategy: "dispatch",
      detachStrategy: "dispatch",
      defaultPath: ["kea", "logic"]
    }, otherOptions)
  };
  Object.defineProperty(newContext, "store", {
    get: function get3() {
      var store = newContext["__store"];
      if (!store && createStoreOptions) {
        return createStore2(typeof createStoreOptions === "object" ? createStoreOptions : {});
      }
      return store;
    },
    set: function set(store) {
      newContext["__store"] = store;
    }
  });
  setContext(newContext);
  activatePlugin(corePlugin);
  runPlugins("afterOpenContext", newContext, options);
  if (plugins) {
    for (var _iterator = _createForOfIteratorHelperLoose(plugins), _step; !(_step = _iterator()).done; ) {
      var plugin = _step.value;
      activatePlugin(plugin);
    }
  }
  if (!initial && createStoreOptions) {
    context.store;
  }
  return context;
}
function closeContext() {
  if (context) {
    runPlugins("beforeCloseContext", context);
  }
  context = void 0;
}
function resetContext(options, initial) {
  if (options === void 0) {
    options = {};
  }
  if (initial === void 0) {
    initial = false;
  }
  if (context) {
    closeContext();
  }
  return openContext(options, initial);
}
function getPluginContext(name) {
  var _getContext = getContext(), plugins = _getContext.plugins;
  if (!plugins.contexts[name]) {
    plugins.contexts[name] = {};
  }
  return plugins.contexts[name];
}
function setPluginContext(name, pluginContext) {
  var _getContext2 = getContext(), plugins = _getContext2.plugins;
  plugins.contexts[name] = pluginContext;
}
function events(input) {
  return function(logic) {
    var events2 = typeof input === "function" ? input(logic) : input;
    var _loop = function _loop2() {
      var key2 = _Object$keys[_i2];
      var event = events2[key2];
      var newEvent = Array.isArray(event) ? function(props2, oldProps) {
        return event.forEach(function(e5) {
          return e5(props2, oldProps);
        });
      } : event;
      if (logic.events[key2]) {
        var oldEvent = logic.events[key2];
        logic.events[key2] = function(props2, oldProps) {
          oldEvent === null || oldEvent === void 0 ? void 0 : oldEvent(props2, oldProps);
          newEvent === null || newEvent === void 0 ? void 0 : newEvent(props2, oldProps);
        };
      } else if (newEvent) {
        logic.events[key2] = newEvent;
      }
    };
    for (var _i2 = 0, _Object$keys = Object.keys(events2); _i2 < _Object$keys.length; _i2++) {
      _loop();
    }
  };
}
function afterMount(input) {
  return events(function(logic) {
    return {
      afterMount: function afterMount2() {
        return input(logic);
      }
    };
  });
}
function beforeUnmount(input) {
  return events(function(logic) {
    return {
      beforeUnmount: function beforeUnmount2() {
        return input(logic);
      }
    };
  });
}
function propsChanged(input) {
  return events(function(logic) {
    return {
      propsChanged: function propsChanged2(props2, oldProps) {
        return input(logic, oldProps);
      }
    };
  });
}
var LISTENERS_BREAKPOINT = "kea-listeners breakpoint broke";
function listeners2(input) {
  return function(logic) {
    var _logic$cache, _logic$cache$listener;
    if (!logic.listeners) {
      logic.listeners = {};
      afterMount(function() {
        addListeners(logic);
      })(logic);
      beforeUnmount(function() {
        removeListeners(logic);
        if (logic.cache.listenerBreakpointCounter) {
          for (var _i3 = 0, _Object$keys = Object.keys(logic.cache.listenerBreakpointCounter); _i3 < _Object$keys.length; _i3++) {
            var key2 = _Object$keys[_i3];
            logic.cache.listenerBreakpointCounter[key2] += 1;
          }
        }
      })(logic);
    }
    (_logic$cache$listener = (_logic$cache = logic.cache).listenerBreakpointCounter) !== null && _logic$cache$listener !== void 0 ? _logic$cache$listener : _logic$cache.listenerBreakpointCounter = {};
    var listeners3 = typeof input === "function" ? input(logic) : input;
    var _getContext = getContext(), contextId2 = _getContext.contextId;
    var _loop = function _loop2() {
      var actionKey = _Object$keys2[_i2];
      var listenerArray = Array.isArray(listeners3[actionKey]) ? listeners3[actionKey] : [listeners3[actionKey]];
      var key2 = actionKey;
      if (typeof logic.actions[key2] !== "undefined") {
        key2 = logic.actions[key2].toString();
      }
      var start = logic.listeners[key2] ? logic.listeners[key2].length : 0;
      var listenerWrapperArray = listenerArray.map(function(listener, index) {
        var listenerKey = contextId2 + "/" + key2 + "/" + (start + index);
        return function(action, previousState) {
          var breakCounter = (logic.cache.listenerBreakpointCounter[listenerKey] || 0) + 1;
          logic.cache.listenerBreakpointCounter[listenerKey] = breakCounter;
          var throwIfCalled = function throwIfCalled2() {
            if (logic.cache.listenerBreakpointCounter[listenerKey] !== breakCounter || contextId2 !== getContext().contextId) {
              throw new Error(LISTENERS_BREAKPOINT);
            }
          };
          var breakpoint = function breakpoint2(ms2) {
            if (typeof ms2 !== "undefined") {
              return new Promise(function(resolve) {
                return setTimeout(resolve, ms2);
              }).then(function() {
                throwIfCalled();
              });
            } else {
              throwIfCalled();
            }
          };
          var response;
          try {
            response = listener(action.payload, breakpoint, action, previousState);
            if (response && response.then && typeof response.then === "function") {
              trackPendingListener(logic, actionKey, response);
              return response["catch"](function(e5) {
                if (e5.message !== LISTENERS_BREAKPOINT) {
                  throw e5;
                }
              });
            }
          } catch (e5) {
            if (e5.message !== LISTENERS_BREAKPOINT) {
              throw e5;
            }
          }
          return response;
        };
      });
      if (logic.listeners[key2]) {
        logic.listeners[key2] = [].concat(logic.listeners[key2], listenerWrapperArray);
      } else {
        logic.listeners[key2] = listenerWrapperArray;
      }
    };
    for (var _i2 = 0, _Object$keys2 = Object.keys(listeners3); _i2 < _Object$keys2.length; _i2++) {
      _loop();
    }
  };
}
function sharedListeners(input) {
  return function(logic) {
    logic.sharedListeners = _extends({}, logic.sharedListeners || {}, typeof input === "function" ? input(logic) : input);
  };
}
function addListeners(logic) {
  var _logic$listeners;
  var _getPluginContext = getPluginContext("listeners"), byPath = _getPluginContext.byPath, byAction = _getPluginContext.byAction;
  byPath[logic.pathString] = (_logic$listeners = logic.listeners) !== null && _logic$listeners !== void 0 ? _logic$listeners : {};
  for (var _i3 = 0, _Object$entries = Object.entries((_logic$listeners2 = logic.listeners) !== null && _logic$listeners2 !== void 0 ? _logic$listeners2 : {}); _i3 < _Object$entries.length; _i3++) {
    var _logic$listeners2, _logic$actionTypes$ke;
    var _Object$entries$_i = _Object$entries[_i3], key2 = _Object$entries$_i[0], listenerArray = _Object$entries$_i[1];
    var type2 = (_logic$actionTypes$ke = logic.actionTypes[key2]) !== null && _logic$actionTypes$ke !== void 0 ? _logic$actionTypes$ke : key2;
    if (!byAction[type2]) {
      byAction[type2] = {};
    }
    byAction[type2][logic.pathString] = listenerArray;
  }
}
function removeListeners(logic) {
  var _getPluginContext2 = getPluginContext("listeners"), byPath = _getPluginContext2.byPath, byAction = _getPluginContext2.byAction;
  for (var _i4 = 0, _Object$keys3 = Object.keys((_logic$listeners3 = logic.listeners) !== null && _logic$listeners3 !== void 0 ? _logic$listeners3 : {}); _i4 < _Object$keys3.length; _i4++) {
    var _logic$listeners3, _logic$actionTypes$ke2;
    var key2 = _Object$keys3[_i4];
    var type2 = (_logic$actionTypes$ke2 = logic.actionTypes[key2]) !== null && _logic$actionTypes$ke2 !== void 0 ? _logic$actionTypes$ke2 : key2;
    if (byAction[type2]) {
      delete byAction[type2][logic.pathString];
      if (Object.keys(byAction[type2]).length === 0) {
        delete byAction[type2];
      }
    }
  }
  delete byPath[logic.pathString];
}
function trackPendingListener(logic, actionKey, response) {
  var _getPluginContext3 = getPluginContext("listeners"), pendingPromises = _getPluginContext3.pendingPromises;
  pendingPromises.set(response, [logic, actionKey]);
  var remove = function remove2() {
    pendingPromises["delete"](response);
  };
  response.then(remove)["catch"](remove);
}
function actions(input) {
  return function(logic) {
    var actions2 = typeof input === "function" ? input(logic) : input;
    var _loop = function _loop2() {
      var _Object$entries$_i = _Object$entries[_i2], key2 = _Object$entries$_i[0], payloadCreator = _Object$entries$_i[1];
      var actionCreator = typeof payloadCreator === "function" && "_isKeaAction" in payloadCreator ? payloadCreator : createActionCreator(createActionType(key2, logic.pathString), payloadCreator !== null && payloadCreator !== void 0 ? payloadCreator : true);
      var type2 = actionCreator.toString();
      logic.actionCreators[key2] = actionCreator;
      logic.actions[key2] = function() {
        var builtAction = actionCreator.apply(void 0, arguments);
        getContext().store.dispatch(builtAction);
      };
      logic.actions[key2].toString = function() {
        return type2;
      };
      logic.actionKeys[type2] = key2;
      logic.actionTypes[key2] = type2;
    };
    for (var _i2 = 0, _Object$entries = Object.entries(actions2); _i2 < _Object$entries.length; _i2++) {
      _loop();
    }
  };
}
function createActionCreator(type2, payloadCreator) {
  var action = function action2() {
    return {
      type: type2,
      payload: typeof payloadCreator === "function" ? payloadCreator.apply(void 0, arguments) : {
        value: true
      }
    };
  };
  action.toString = function() {
    return type2;
  };
  action._isKeaAction = true;
  return action;
}
function createActionType(key2, pathString) {
  var toSpaces = function toSpaces2(key3) {
    return key3.replace(/(?:^|\.?)([A-Z])/g, function(x5, y5) {
      return " " + y5.toLowerCase();
    }).replace(/^ /, "");
  };
  return toSpaces(key2) + " (" + pathString + ")";
}
function connect(input) {
  return function(logic) {
    var props2 = logic.props || {};
    var connect2 = typeof input === "function" ? input(props2) : input;
    var connectLogic = Array.isArray(connect2) ? connect2 : "_isKeaBuild" in connect2 || "_isKea" in connect2 ? [connect2] : connect2.logic;
    if (connectLogic) {
      for (var _iterator = _createForOfIteratorHelperLoose(connectLogic), _step; !(_step = _iterator()).done; ) {
        var otherLogic = _step.value;
        if ("_isKea" in otherLogic) {
          otherLogic = otherLogic(props2);
        }
        addConnection(logic, otherLogic);
      }
    }
    if ("_isKeaBuild" in connect2 || "_isKea" in connect2 || Array.isArray(connect2)) {
      return;
    }
    if (connect2.actions) {
      var response = deconstructMapping(connect2.actions);
      var _loop = function _loop3() {
        var _step2$value = _step2.value, otherLogic2 = _step2$value[0], from3 = _step2$value[1], to2 = _step2$value[2];
        if (true) {
          if (typeof otherLogic2 !== "function" && typeof otherLogic2 !== "object") {
            throw new Error('[KEA] Logic "' + logic.pathString + '" can not connect to ' + typeof otherLogic2 + ' to request action "' + from3 + '"');
          }
        }
        if (isLogicWrapper(otherLogic2)) {
          otherLogic2 = otherLogic2.build(props2);
        }
        if (isBuiltLogic(otherLogic2)) {
          addConnection(logic, otherLogic2);
          if (getContext().buildHeap.includes(otherLogic2)) {
            logic.actionCreators[to2] = function() {
              var _otherLogic$actionCre;
              return (_otherLogic$actionCre = otherLogic2.actionCreators)[from3].apply(_otherLogic$actionCre, arguments);
            };
            logic.actionCreators[to2].toString = function() {
              return createActionType(from3, otherLogic2.pathString);
            };
            logic.actionTypes[to2] = logic.actionCreators[to2].toString();
          } else {
            logic.actionCreators[to2] = otherLogic2.actionCreators[from3];
            logic.actionTypes[to2] = otherLogic2.actionTypes[from3];
          }
        } else {
          logic.actionCreators[to2] = otherLogic2[from3];
          if (logic.actionCreators[to2]._isKeaAction) {
            logic.actionTypes[to2] = logic.actionCreators[to2].toString();
          } else {
            logic.actionTypes[to2] = logic.actionCreators[to2]().type;
          }
        }
        logic.actionKeys[logic.actionTypes[to2]] = to2;
        if (typeof logic.actionCreators[to2] === "undefined") {
          throw new Error('[KEA] Logic "' + logic.pathString + '", connecting to action "' + from3 + `" returns 'undefined'`);
        }
        logic.actions[to2] = function() {
          var _logic$actionCreators;
          var builtAction = (_logic$actionCreators = logic.actionCreators)[to2].apply(_logic$actionCreators, arguments);
          getContext().store.dispatch(builtAction);
        };
        logic.actions[to2].toString = function() {
          return logic.actionTypes[to2];
        };
      };
      for (var _iterator2 = _createForOfIteratorHelperLoose(response), _step2; !(_step2 = _iterator2()).done; ) {
        _loop();
      }
    }
    if (connect2.values) {
      var _response = deconstructMapping(connect2.values);
      var _loop2 = function _loop22() {
        var _step3$value = _step3.value, otherLogic2 = _step3$value[0], from3 = _step3$value[1], to2 = _step3$value[2];
        if (true) {
          if (typeof otherLogic2 !== "function" && typeof otherLogic2 !== "object") {
            throw new Error('[KEA] Logic "' + logic.pathString + '" can not connect to ' + typeof otherLogic2 + ' to request prop "' + from3 + '"');
          }
        }
        if (isLogicWrapper(otherLogic2)) {
          otherLogic2 = otherLogic2(props2);
        }
        if (isBuiltLogic(otherLogic2)) {
          addConnection(logic, otherLogic2);
          var selector = from3 === "*" ? otherLogic2.selector : otherLogic2.selectors[from3];
          var throwError = function throwError2() {
            throw new Error('Connected selector "' + to2 + '" on logic "' + logic.pathString + '" is undefined.');
          };
          if (selector) {
            logic.selectors[to2] = selector;
          } else if (getContext().buildHeap.includes(otherLogic2)) {
            logic.selectors[to2] = function(state, props3) {
              return otherLogic2.selectors[from3] ? otherLogic2.selectors[from3](state, props3) : throwError();
            };
          } else {
            throwError();
          }
        } else if (typeof otherLogic2 === "function") {
          logic.selectors[to2] = from3 === "*" ? otherLogic2 : function(state, props3) {
            var values = otherLogic2(state, props3);
            return values && values[from3];
          };
        }
        if (logic.selectors[to2] && !logic.values.hasOwnProperty(to2)) {
          Object.defineProperty(logic.values, to2, {
            get: function get3() {
              return logic.selectors[to2](getStoreState2(), logic.props);
            },
            enumerable: true
          });
        }
      };
      for (var _iterator3 = _createForOfIteratorHelperLoose(_response), _step3; !(_step3 = _iterator3()).done; ) {
        _loop2();
      }
    }
  };
}
function deconstructMapping(mapping) {
  if (mapping.length % 2 === 1) {
    console.error(mapping);
    throw new Error("[KEA] Uneven mapping given to connect");
  }
  var response = [];
  for (var i4 = 0; i4 < mapping.length; i4 += 2) {
    var logic = mapping[i4];
    var array = mapping[i4 + 1];
    if (!Array.isArray(array)) {
      console.error(mapping);
      throw new Error("[KEA] Invalid mapping given to connect. Make sure every second element is an array!");
    }
    for (var j4 = 0; j4 < array.length; j4++) {
      if (array[j4].includes(" as ")) {
        var parts = array[j4].split(" as ");
        response.push([logic, parts[0], parts[1]]);
      } else {
        response.push([logic, array[j4], array[j4]]);
      }
    }
  }
  return response;
}
function addConnection(logic, otherLogic) {
  if (!otherLogic.connections || Object.keys(otherLogic.connections).length === 0) {
    return;
  }
  if (logic.connections[otherLogic.pathString]) {
    return;
  }
  Object.keys(otherLogic.connections).forEach(function(path2) {
    if (!logic.connections[path2]) {
      logic.connections[path2] = otherLogic.connections[path2];
    }
  });
}
function defaults(input) {
  return function(logic) {
    var defaults3 = typeof input === "function" ? input(logic) : input;
    if (typeof defaults3 === "function") {
      logic.defaults["*"] = defaults3;
    } else if (typeof defaults3 === "object") {
      var contextDefaults = getContextDefaults(logic);
      for (var _i2 = 0, _Object$entries = Object.entries(defaults3); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _Object$entries[_i2], key2 = _Object$entries$_i[0], value = _Object$entries$_i[1];
        logic.defaults[key2] = contextDefaults && typeof contextDefaults[key2] !== "undefined" ? contextDefaults[key2] : value;
      }
    } else {
      throw new Error('[KEA] Unknown defaults of type "' + typeof defaults3 + '" for logic "' + logic.pathString + '"');
    }
  };
}
function getContextDefaults(logic) {
  var _getContext = getContext(), reducerDefaults = _getContext.reducerDefaults;
  if (reducerDefaults && !("_keaAutomaticPath" in logic.path)) {
    if (getContext().options.flatDefaults) {
      if (reducerDefaults[logic.pathString]) {
        return reducerDefaults[logic.pathString];
      }
    } else {
      for (var _iterator = _createForOfIteratorHelperLoose(logic.path), _step; !(_step = _iterator()).done; ) {
        var part = _step.value;
        reducerDefaults = reducerDefaults[part.toString()];
        if (typeof reducerDefaults !== "object") {
          return;
        }
      }
      return reducerDefaults;
    }
  }
}
function selectors(input) {
  return function(logic) {
    var selectorInputs = typeof input === "function" ? input(logic) : input;
    var builtSelectors = {};
    var _loop = function _loop3() {
      var key2 = _Object$keys[_i2];
      if (typeof logic.selectors[key2] !== "undefined") {
        throw new Error('[KEA] Logic "' + logic.pathString + '" selector "' + key2 + '" already exists');
      }
      addSelectorAndValue(logic, key2, function() {
        return builtSelectors[key2].apply(builtSelectors, arguments);
      });
    };
    for (var _i2 = 0, _Object$keys = Object.keys(selectorInputs); _i2 < _Object$keys.length; _i2++) {
      _loop();
    }
    var _loop2 = function _loop22() {
      var entry = _Object$entries[_i22];
      var key2 = entry[0], _entry$ = entry[1], input2 = _entry$[0], func = _entry$[1], memoizeOptions = _entry$[2];
      var args = input2(logic.selectors);
      if (args.filter(function(a4) {
        return typeof a4 !== "function";
      }).length > 0) {
        var argTypes = args.map(function(a4) {
          return typeof a4;
        }).join(", ");
        var msg = '[KEA] Logic "' + logic.pathString + '", selector "' + key2 + '" has incorrect input: [' + argTypes + "].";
        throw new Error(msg);
      }
      builtSelectors[key2] = createSelector(args, func, {
        memoizeOptions
      });
      addSelectorAndValue(logic, key2, function(state, props2) {
        if (state === void 0) {
          state = getStoreState2();
        }
        if (props2 === void 0) {
          props2 = logic.props;
        }
        return builtSelectors[key2](state, props2);
      });
      if (!logic.values.hasOwnProperty(key2)) {
        Object.defineProperty(logic.values, key2, {
          get: function get3() {
            return logic.selectors[key2](getStoreState2(), logic.props);
          },
          enumerable: true
        });
      }
    };
    for (var _i22 = 0, _Object$entries = Object.entries(selectorInputs); _i22 < _Object$entries.length; _i22++) {
      _loop2();
    }
  };
}
function addSelectorAndValue(logic, key2, selector) {
  logic.selectors[key2] = selector;
  if (!logic.values.hasOwnProperty(key2)) {
    Object.defineProperty(logic.values, key2, {
      get: function get3() {
        return logic.selectors[key2](getStoreState2(), logic.props);
      },
      enumerable: true
    });
  }
}
function rootReducer() {
  return function(logic) {
    logic.reducer = function(state, action, fullState) {
      return combineKeaReducers(logic.reducers)(state, action, fullState);
    };
    if (!logic.selector) {
      rootSelector()(logic);
    }
  };
}
function rootSelector() {
  return function(logic) {
    logic.selector = function(state) {
      if (state === void 0) {
        state = getStoreState2();
      }
      return pathSelector(logic.path, state);
    };
  };
}
function reducers(input) {
  return function(logic) {
    var reducers2 = typeof input === "function" ? input(logic) : input;
    if (!logic.reducer) {
      rootReducer()(logic);
    }
    if (!logic.selector) {
      rootSelector()(logic);
    }
    var contextDefaults = getContextDefaults(logic);
    var _loop = function _loop2() {
      var _logic$cache, _logic$cache$reducers, _logic$cache$reducers2, _logic$cache$reducers3;
      var _Object$entries$_i = _Object$entries[_i2], key2 = _Object$entries$_i[0], object = _Object$entries$_i[1];
      var initialValue = void 0;
      var reducerOptions = void 0;
      var reducer = void 0;
      if (Array.isArray(object)) {
        var _object$, _object$Math$max;
        initialValue = (_object$ = object[0]) !== null && _object$ !== void 0 ? _object$ : null;
        reducer = (_object$Math$max = object[Math.max(1, object.length - 1)]) !== null && _object$Math$max !== void 0 ? _object$Math$max : {};
        if (object.length === 3) {
          reducerOptions = object[1];
        }
      } else if (typeof object === "object") {
        initialValue = null;
        reducer = object;
      } else {
        throw new Error('[KEA] Logic "' + logic.pathString + '" reducer "' + key2 + '" is set to unsupported value');
      }
      if (reducerOptions) {
        var _logic$reducerOptions;
        logic.reducerOptions[key2] = _extends({}, (_logic$reducerOptions = logic.reducerOptions[key2]) !== null && _logic$reducerOptions !== void 0 ? _logic$reducerOptions : {}, reducerOptions);
      }
      if (typeof logic.defaults[key2] === "undefined") {
        if (contextDefaults && typeof contextDefaults[key2] !== "undefined") {
          logic.defaults[key2] = contextDefaults[key2];
        } else if (typeof logic.defaults["*"] === "function") {
          logic.defaults[key2] = function(state, props2) {
            var v5 = logic.defaults["*"](state, props2)[key2];
            return typeof v5 === "undefined" ? initialValue : typeof v5 === "function" ? v5(state, props2) : v5;
          };
        } else {
          logic.defaults[key2] = initialValue;
        }
      }
      (_logic$cache$reducers = (_logic$cache = logic.cache).reducers) !== null && _logic$cache$reducers !== void 0 ? _logic$cache$reducers : _logic$cache.reducers = {};
      (_logic$cache$reducers3 = (_logic$cache$reducers2 = logic.cache.reducers)[key2]) !== null && _logic$cache$reducers3 !== void 0 ? _logic$cache$reducers3 : _logic$cache$reducers2[key2] = {};
      var mapping = logic.cache.reducers[key2];
      for (var _i22 = 0, _Object$keys = Object.keys((_reducer = reducer) !== null && _reducer !== void 0 ? _reducer : {}); _i22 < _Object$keys.length; _i22++) {
        var _reducer;
        var _key = _Object$keys[_i22];
        var mappingKey = logic.actions[_key] ? logic.actions[_key].toString() : _key;
        mapping[mappingKey] = reducer[_key];
      }
      if (typeof mapping["undefined"] !== "undefined" && typeof logic.actions["undefined"] === "undefined") {
        throw new Error('[KEA] Logic "' + logic.pathString + '" reducer "' + key2 + '" is waiting for an action that is undefined: [' + Object.keys(mapping).join(", ") + "]");
      }
      if (!logic.reducers[key2] && logic.selectors[key2]) {
        throw new Error('[KEA] Logic "' + logic.pathString + `" can't add reducer "` + key2 + '" because a selector with the same name exists.');
      }
      if (Object.keys(mapping).length === 0) {
        logic.reducers[key2] = function() {
          return logic.defaults[key2];
        };
      } else {
        logic.reducers[key2] = function(state, action, fullState) {
          if (typeof state === "undefined") {
            state = getDefaultState(logic.defaults[key2], fullState, key2, logic);
          }
          if (mapping[action.type]) {
            return mapping[action.type](state, action.payload, action.meta);
          } else if (logic.actionKeys[action.type] && mapping[logic.actionKeys[action.type]]) {
            return mapping[logic.actionKeys[action.type]](state, action.payload, action.meta);
          } else {
            return state;
          }
        };
      }
      if (!logic.selectors[key2]) {
        addSelectorAndValue(logic, key2, createSelector(logic.selector, function(state) {
          return state[key2];
        }));
      }
    };
    for (var _i2 = 0, _Object$entries = Object.entries(reducers2); _i2 < _Object$entries.length; _i2++) {
      _loop();
    }
  };
}
function getDefaultState(defaultValue, fullState, key2, logic) {
  if (typeof defaultValue === "function") {
    if (fullState) {
      return defaultValue(fullState, logic.props);
    } else {
      if (true) {
        console.error(`[KEA] Store not initialized and can't get default value of "` + key2 + '" in "' + logic.pathString + '"');
      }
      return void 0;
    }
  }
  return defaultValue;
}
function pathSelector(path2, state) {
  return [state].concat(path2).reduce(function(v5, a4) {
    if (a4 in v5) {
      return v5[a4];
    }
    throw new Error('[KEA] Can not find path "' + path2.join(".") + '" in the store.');
  });
}
function key(input) {
  return function(logic) {
    var key2 = input(logic.props);
    if (typeof logic.keyBuilder !== "undefined") {
      throw new Error('[KEA] Already defined key builder for logic "' + logic.pathString + '".');
    }
    if (typeof key2 === "undefined") {
      throw new Error('[KEA] Undefined key for logic "' + logic.pathString + '"');
    }
    if (Object.keys(logic.actions).length > 0) {
      throw new Error('[KEA] Can not add key to logic "' + logic.pathString + '" after adding actions: ' + Object.keys(logic.actions).join(", "));
    }
    logic.key = key2;
    logic.keyBuilder = input;
    var isAutomaticPath = "_keaAutomaticPath" in logic.path;
    logic.path = [].concat(logic.path, [logic.key]);
    logic.pathString = logic.path.join(".");
    if (isAutomaticPath) {
      logic.path["_keaAutomaticPath"] = true;
    }
  };
}
function props(input) {
  return function(logic) {
    var newProps = _extends({}, input, logic.props);
    if (!shallowCompare(logic.props, newProps)) {
      logic.props = newProps;
    }
  };
}
function path(input) {
  return function(logic) {
    if (logic.path && !("_keaAutomaticPath" in logic.path)) {
      return;
    }
    if (Object.keys(logic.actions).length > 0) {
      throw new Error('[KEA] Can not add path to logic "' + logic.pathString + '" after adding actions: ' + Object.keys(logic.actions).join(", "));
    }
    if (typeof input === "function") {
      logic.path = input(logic.key).filter(function(l5) {
        return typeof l5 !== "undefined";
      });
    } else {
      logic.path = typeof logic.key !== "undefined" ? [].concat(input, [logic.key]) : input;
    }
    logic.pathString = logic.path.join(".");
  };
}
var corePlugin = {
  name: "core",
  defaults: function defaults2() {
    return {
      actionCreators: {},
      actionKeys: {},
      actionTypes: {},
      actions: {},
      cache: {},
      connections: {},
      defaults: {},
      listeners: void 0,
      reducers: {},
      reducer: void 0,
      reducerOptions: {},
      selector: void 0,
      selectors: {},
      sharedListeners: void 0,
      values: {},
      events: {}
    };
  },
  events: {
    afterPlugin: function afterPlugin() {
      setPluginContext("listeners", {
        byAction: {},
        byPath: {},
        pendingPromises: /* @__PURE__ */ new Map()
      });
    },
    beforeReduxStore: function beforeReduxStore(options) {
      options.middleware.push(function(store) {
        return function(next) {
          return function(action) {
            var previousState = store.getState();
            var response = next(action);
            var _getPluginContext = getPluginContext("listeners"), byAction = _getPluginContext.byAction;
            var listeners3 = byAction[action.type];
            if (listeners3) {
              for (var _i2 = 0, _Object$values = Object.values(listeners3); _i2 < _Object$values.length; _i2++) {
                var listenerArray = _Object$values[_i2];
                for (var _iterator = _createForOfIteratorHelperLoose(listenerArray), _step; !(_step = _iterator()).done; ) {
                  var innerListener = _step.value;
                  innerListener(action, previousState);
                }
              }
            }
            return response;
          };
        };
      });
    },
    legacyBuild: function legacyBuild(logic, input) {
      "connect" in input && input.connect && connect(input.connect)(logic);
      runPlugins("legacyBuildAfterConnect", logic, input);
      "actions" in input && input.actions && actions(input.actions)(logic);
      "defaults" in input && input.defaults && defaults(input.defaults)(logic);
      runPlugins("legacyBuildAfterDefaults", logic, input);
      "reducers" in input && input.reducers && reducers(input.reducers)(logic);
      "selectors" in input && input.selectors && selectors(input.selectors)(logic);
      "sharedListeners" in input && sharedListeners(input.sharedListeners)(logic);
      "listeners" in input && input.listeners && listeners2(input.listeners)(logic);
      "events" in input && input.events && events(input.events)(logic);
    }
  }
};
function mountLogic(logic, count) {
  if (count === void 0) {
    count = 1;
  }
  var _getContext = getContext(), _getContext$mount = _getContext.mount, counter = _getContext$mount.counter, mounted = _getContext$mount.mounted;
  var pathStrings = Object.keys(logic.connections).filter(function(k5) {
    return k5 !== logic.pathString;
  }).concat([logic.pathString]);
  for (var _iterator = _createForOfIteratorHelperLoose(pathStrings), _step; !(_step = _iterator()).done; ) {
    var pathString = _step.value;
    counter[pathString] = (counter[pathString] || 0) + count;
    if (counter[pathString] === count) {
      var _connectedLogic$event, _connectedLogic$event2, _connectedLogic$event3, _connectedLogic$event4;
      var connectedLogic = logic.connections[pathString];
      if (typeof connectedLogic === "undefined") {
        throw new Error('[KEA] Can not find connected logic at "' + pathString + '". Got "undefined" instead of the logic when trying to mount "' + logic.pathString + '".');
      }
      runPlugins("beforeMount", connectedLogic);
      (_connectedLogic$event = (_connectedLogic$event2 = connectedLogic.events).beforeMount) === null || _connectedLogic$event === void 0 ? void 0 : _connectedLogic$event.call(_connectedLogic$event2);
      mounted[pathString] = connectedLogic;
      if (connectedLogic.reducer) {
        attachReducer(connectedLogic);
      }
      runPlugins("afterMount", connectedLogic);
      (_connectedLogic$event3 = (_connectedLogic$event4 = connectedLogic.events).afterMount) === null || _connectedLogic$event3 === void 0 ? void 0 : _connectedLogic$event3.call(_connectedLogic$event4);
    }
  }
}
function unmountLogic(logic) {
  var _getContext2 = getContext(), _getContext2$mount = _getContext2.mount, counter = _getContext2$mount.counter, mounted = _getContext2$mount.mounted;
  var pathStrings = Object.keys(logic.connections).filter(function(k5) {
    return k5 !== logic.pathString;
  }).concat([logic.pathString]).reverse();
  for (var _iterator2 = _createForOfIteratorHelperLoose(pathStrings), _step2; !(_step2 = _iterator2()).done; ) {
    var pathString = _step2.value;
    counter[pathString] = (counter[pathString] || 0) - 1;
    if (counter[pathString] === 0) {
      var _connectedLogic$event5, _connectedLogic$event6, _connectedLogic$event7, _connectedLogic$event8, _getContext$wrapperCo;
      var connectedLogic = logic.connections[pathString];
      runPlugins("beforeUnmount", connectedLogic);
      (_connectedLogic$event5 = (_connectedLogic$event6 = connectedLogic.events).beforeUnmount) === null || _connectedLogic$event5 === void 0 ? void 0 : _connectedLogic$event5.call(_connectedLogic$event6);
      delete mounted[pathString];
      delete counter[pathString];
      if (connectedLogic.reducer) {
        detachReducer(connectedLogic);
      }
      runPlugins("afterUnmount", connectedLogic);
      (_connectedLogic$event7 = (_connectedLogic$event8 = connectedLogic.events).afterUnmount) === null || _connectedLogic$event7 === void 0 ? void 0 : _connectedLogic$event7.call(_connectedLogic$event8);
      (_getContext$wrapperCo = getContext().wrapperContexts.get(logic.wrapper)) === null || _getContext$wrapperCo === void 0 ? void 0 : _getContext$wrapperCo.builtLogics["delete"](logic.key);
    }
  }
}
function applyInputToLogic(logic, input) {
  runPlugins("beforeLogic", logic, input);
  if (typeof input === "function") {
    input(logic);
  } else {
    "props" in input && props(input.props)(logic);
    "key" in input && typeof input.key !== "undefined" && key(input.key)(logic);
    "path" in input && input.path && path(input.path)(logic);
    if (input.inherit) {
      for (var _iterator = _createForOfIteratorHelperLoose(input.inherit), _step; !(_step = _iterator()).done; ) {
        var inheritLogic = _step.value;
        for (var _iterator2 = _createForOfIteratorHelperLoose(inheritLogic.inputs), _step2; !(_step2 = _iterator2()).done; ) {
          var inheritInput = _step2.value;
          applyInputToLogic(logic, inheritInput);
        }
      }
    }
    runPlugins("legacyBuild", logic, input);
    if (input.extend) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(input.extend), _step3; !(_step3 = _iterator3()).done; ) {
        var innerInput = _step3.value;
        applyInputToLogic(logic, innerInput);
      }
    }
  }
  runPlugins("afterLogic", logic, input);
  return logic;
}
function getBuiltLogic(wrapper, props2) {
  var wrapperContext = getWrapperContext(wrapper);
  if (wrapperContext.isBuilding) {
    throw new Error("[KEA] Circular build detected.");
  }
  var cachedLogic = getCachedBuiltLogic(wrapper, props2);
  if (cachedLogic) {
    var oldProps = cachedLogic.props;
    if (props2 && (!cachedLogic.props || cachedLogic.props !== props2 && !shallowCompare(cachedLogic.props, props2))) {
      cachedLogic.props = _extends({}, cachedLogic.props, props2);
    }
    if (oldProps !== cachedLogic.props && cachedLogic.events.propsChanged) {
      batchChanges(function() {
        var _cachedLogic$events$p, _cachedLogic$events;
        (_cachedLogic$events$p = (_cachedLogic$events = cachedLogic.events).propsChanged) === null || _cachedLogic$events$p === void 0 ? void 0 : _cachedLogic$events$p.call(_cachedLogic$events, cachedLogic.props, oldProps);
      });
    }
    return cachedLogic;
  }
  var uniqueId = ++getContext().inputCounter;
  var path2 = [].concat(getContext().options.defaultPath, [uniqueId]);
  path2["_keaAutomaticPath"] = true;
  wrapperContext.isBuilding = true;
  var logic = {
    _isKeaBuild: true,
    key: void 0,
    keyBuilder: void 0,
    path: path2,
    pathString: path2.join("."),
    props: props2 !== null && props2 !== void 0 ? props2 : {},
    wrapper,
    extend: function extend(input2) {
      return applyInputToLogic(logic, input2);
    },
    mount: function mount() {
      if (wrapperContext.isBuilding) {
        throw new Error('[KEA] Tried to mount logic "' + logic.pathString + '" before it finished building');
      }
      mountLogic(logic);
      var unmounted = false;
      return function() {
        if (unmounted) {
          throw new Error('[KEA] Tried to unmount logic "' + logic.pathString + '" for a second time');
        }
        unmountLogic(logic);
        unmounted = true;
      };
    },
    unmount: function unmount() {
      return unmountLogic(logic);
    },
    isMounted: function isMounted() {
      var counter = getContext().mount.counter[logic.pathString];
      return typeof counter === "number" && counter > 0;
    }
  };
  var _getContext = getContext(), buildHeap = _getContext.buildHeap;
  try {
    buildHeap.push(logic);
    for (var _iterator4 = _createForOfIteratorHelperLoose(getContext().plugins.activated), _step4; !(_step4 = _iterator4()).done; ) {
      var plugin = _step4.value;
      if (plugin.defaults) {
        var newLogicProperties = typeof plugin.defaults === "function" ? plugin.defaults() : plugin.defaults;
        Object.assign(logic, newLogicProperties);
      }
    }
    runPlugins("beforeBuild", logic, wrapper.inputs);
    for (var _iterator5 = _createForOfIteratorHelperLoose(wrapper.inputs), _step5; !(_step5 = _iterator5()).done; ) {
      var input = _step5.value;
      applyInputToLogic(logic, input);
    }
    logic.connections[logic.pathString] = logic;
    wrapperContext.keyBuilder = logic.keyBuilder;
    wrapperContext.builtLogics.set(logic.key, logic);
    runPlugins("afterBuild", logic, wrapper.inputs);
  } catch (e5) {
    throw e5;
  } finally {
    wrapperContext.isBuilding = false;
    buildHeap.pop();
  }
  if (buildHeap.length > 0) {
    if (!buildHeap[buildHeap.length - 1].connections[logic.pathString]) {
      addConnection(buildHeap[buildHeap.length - 1], logic);
    }
  }
  return logic;
}
function getCachedBuiltLogic(wrapper, props2) {
  var _wrapperContext$keyBu;
  var wrapperContext = getWrapperContext(wrapper);
  var builtLogic = wrapperContext.builtLogics.get(wrapperContext === null || wrapperContext === void 0 ? void 0 : (_wrapperContext$keyBu = wrapperContext.keyBuilder) === null || _wrapperContext$keyBu === void 0 ? void 0 : _wrapperContext$keyBu.call(wrapperContext, props2 !== null && props2 !== void 0 ? props2 : {}));
  return builtLogic !== null && builtLogic !== void 0 ? builtLogic : null;
}
function getWrapperContext(wrapper) {
  var _getContext2 = getContext(), wrapperContexts = _getContext2.wrapperContexts;
  var wrapperContext = wrapperContexts.get(wrapper);
  if (!wrapperContext) {
    wrapperContext = {
      keyBuilder: void 0,
      builtLogics: /* @__PURE__ */ new Map(),
      isBuilding: false
    };
    wrapperContexts.set(wrapper, wrapperContext);
  }
  return wrapperContext;
}
function wrapComponent(Component, wrapper) {
  runPlugins("beforeWrap", wrapper, Component);
  injectActionsIntoClass(Component);
  var Kea = function Kea2(props2) {
    var _props$actions;
    var logic = wrapper.build(props2);
    var values = useAllValues(logic);
    var actions2 = _extends({}, (_props$actions = props2.actions) !== null && _props$actions !== void 0 ? _props$actions : {}, useActions(logic));
    runPlugins("beforeRender", logic, props2);
    return /* @__PURE__ */ React3.createElement(Component, _extends({}, props2, values, {
      dispatch: getContext().store.dispatch,
      actions: actions2
    }));
  };
  Kea._wrapper = wrapper;
  Kea._wrappedComponent = Component;
  runPlugins("afterWrap", wrapper, Component, Kea);
  return Kea;
}
function injectActionsIntoClass(Component) {
  function isStateless(Component2) {
    return typeof Component2 === "function" && !(Component2.prototype && Component2.prototype.isReactComponent);
  }
  if (!isStateless(Component)) {
    if (!Object.getOwnPropertyDescriptor(Component.prototype, "actions")) {
      Object.defineProperty(Component.prototype, "actions", {
        get: function actions2() {
          return this.props.actions;
        }
      });
    }
  }
}
function kea(input) {
  var wrapper = function wrapper2(props2) {
    if (typeof props2 === "object" || typeof props2 === "undefined") {
      return wrapper2.build(props2);
    }
    return wrapper2.wrap(props2);
  };
  wrapper._isKea = true;
  wrapper.inputs = Array.isArray(input) ? input : [input];
  wrapper.wrap = function(Component) {
    return wrapComponent(Component, wrapper);
  };
  wrapper.build = function(props2) {
    return getBuiltLogic(wrapper, props2);
  };
  wrapper.mount = function() {
    return wrapper.build().mount();
  };
  wrapper.unmount = function() {
    return wrapper.build().unmount();
  };
  wrapper.isMounted = function(props2) {
    var builtLogic = getCachedBuiltLogic(wrapper, props2);
    if (!builtLogic) {
      return false;
    }
    var counter = getContext().mount.counter[builtLogic.pathString];
    return typeof counter === "number" && counter > 0;
  };
  wrapper.findMounted = function(props2) {
    return wrapper.isMounted(props2) ? getCachedBuiltLogic(wrapper, props2) : null;
  };
  wrapper.extend = function(extendedInput) {
    var wrapperContext = getContext().wrapperContexts.get(wrapper);
    if (wrapperContext) {
      throw new Error("[KEA] Can not extend logic once it has been built.");
    }
    if (Array.isArray(extendedInput)) {
      wrapper.inputs = wrapper.inputs.concat(extendedInput);
    } else {
      wrapper.inputs.push(extendedInput);
    }
    return wrapper;
  };
  if (getContext().options.proxyFields) {
    proxyFields(wrapper);
  }
  return wrapper;
}
function proxyFieldToLogic(wrapper, key2) {
  if (!wrapper.hasOwnProperty(key2)) {
    Object.defineProperty(wrapper, key2, {
      get: function get3() {
        var logic = wrapper.findMounted();
        if (!logic && getContext().buildHeap.length > 0) {
          logic = wrapper.build();
        }
        if (logic) {
          return logic[key2];
        } else {
          throw new Error(unmountedActionError(String(key2), wrapper.build().pathString));
        }
      }
    });
  }
}
function proxyFields(wrapper) {
  var reservedProxiedKeys = ["path", "pathString", "props"];
  for (var _i2 = 0, _reservedProxiedKeys = reservedProxiedKeys; _i2 < _reservedProxiedKeys.length; _i2++) {
    var key2 = _reservedProxiedKeys[_i2];
    proxyFieldToLogic(wrapper, key2);
  }
  for (var _i22 = 0, _Object$keys = Object.keys(getContext().plugins.logicFields); _i22 < _Object$keys.length; _i22++) {
    var _key = _Object$keys[_i22];
    proxyFieldToLogic(wrapper, _key);
  }
}
function unmountedActionError(key2, path2) {
  return '[KEA] Can not access "' + key2 + '" on logic "' + path2 + '" because it is not mounted!\nThis can happen in several situations:\n- You may need to add the "connect(otherLogic)" logic builder, or "useMountedLogic(otherLogic)" hook to make sure the logic is mounted.\n- If "otherLogic" is undefined, your bundler may import and execute code in an unfavourable order. Switch to a function: "connect(() => otherLogic)" \n- It may be that the logic has already unmounted. Do you have a listener that is missing a breakpoint?';
}
resetContext({}, true);

// node_modules/@worldcoin/id/dist/index.js
var import_posthog_js_lite = __toESM(require_src3(), 1);
var import_js_sha37 = __toESM(require_sha3(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_server = __toESM(require_server_browser(), 1);
var import_qr_code_styling_new = __toESM(require_qr_code_styling(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var Ua = Object.create;
var Oe = Object.defineProperty;
var Ha = Object.defineProperties;
var Na = Object.getOwnPropertyDescriptor;
var Wa = Object.getOwnPropertyDescriptors;
var Fa = Object.getOwnPropertyNames;
var wi = Object.getOwnPropertySymbols;
var qa = Object.getPrototypeOf;
var Ci = Object.prototype.hasOwnProperty;
var Va = Object.prototype.propertyIsEnumerable;
var xi = (e5, t5, r5) => t5 in e5 ? Oe(e5, t5, { enumerable: true, configurable: true, writable: true, value: r5 }) : e5[t5] = r5;
var Vt = (e5, t5) => {
  for (var r5 in t5 || (t5 = {}))
    Ci.call(t5, r5) && xi(e5, r5, t5[r5]);
  if (wi)
    for (var r5 of wi(t5))
      Va.call(t5, r5) && xi(e5, r5, t5[r5]);
  return e5;
};
var _i = (e5, t5) => Ha(e5, Wa(t5));
var Be = (e5, t5) => () => (e5 && (t5 = e5(e5 = 0)), t5);
var Dt = (e5, t5) => () => (t5 || e5((t5 = { exports: {} }).exports, t5), t5.exports);
var ve = (e5, t5) => {
  for (var r5 in t5)
    Oe(e5, r5, { get: t5[r5], enumerable: true });
};
var Gr = (e5, t5, r5, o4) => {
  if (t5 && typeof t5 == "object" || typeof t5 == "function")
    for (let i4 of Fa(t5))
      !Ci.call(e5, i4) && i4 !== r5 && Oe(e5, i4, { get: () => t5[i4], enumerable: !(o4 = Na(t5, i4)) || o4.enumerable });
  return e5;
};
var O3 = (e5, t5, r5) => (Gr(e5, t5, "default"), r5 && Gr(r5, t5, "default"));
var Zt = (e5, t5, r5) => (r5 = e5 != null ? Ua(qa(e5)) : {}, Gr(t5 || !e5 || !e5.__esModule ? Oe(r5, "default", { value: e5, enumerable: true }) : r5, e5));
var y4 = Be(() => {
});
var w5 = Be(() => {
});
function Ei() {
  jr = true;
  for (var e5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t5 = 0, r5 = e5.length; t5 < r5; ++t5)
    $t[t5] = e5[t5], Wt[e5.charCodeAt(t5)] = t5;
  Wt["-".charCodeAt(0)] = 62, Wt["_".charCodeAt(0)] = 63;
}
function Ga(e5) {
  jr || Ei();
  var t5, r5, o4, i4, p5, m5, M4 = e5.length;
  if (M4 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  p5 = e5[M4 - 2] === "=" ? 2 : e5[M4 - 1] === "=" ? 1 : 0, m5 = new Za(M4 * 3 / 4 - p5), o4 = p5 > 0 ? M4 - 4 : M4;
  var b3 = 0;
  for (t5 = 0, r5 = 0; t5 < o4; t5 += 4, r5 += 3)
    i4 = Wt[e5.charCodeAt(t5)] << 18 | Wt[e5.charCodeAt(t5 + 1)] << 12 | Wt[e5.charCodeAt(t5 + 2)] << 6 | Wt[e5.charCodeAt(t5 + 3)], m5[b3++] = i4 >> 16 & 255, m5[b3++] = i4 >> 8 & 255, m5[b3++] = i4 & 255;
  return p5 === 2 ? (i4 = Wt[e5.charCodeAt(t5)] << 2 | Wt[e5.charCodeAt(t5 + 1)] >> 4, m5[b3++] = i4 & 255) : p5 === 1 && (i4 = Wt[e5.charCodeAt(t5)] << 10 | Wt[e5.charCodeAt(t5 + 1)] << 4 | Wt[e5.charCodeAt(t5 + 2)] >> 2, m5[b3++] = i4 >> 8 & 255, m5[b3++] = i4 & 255), m5;
}
function $a(e5) {
  return $t[e5 >> 18 & 63] + $t[e5 >> 12 & 63] + $t[e5 >> 6 & 63] + $t[e5 & 63];
}
function ja(e5, t5, r5) {
  for (var o4, i4 = [], p5 = t5; p5 < r5; p5 += 3)
    o4 = (e5[p5] << 16) + (e5[p5 + 1] << 8) + e5[p5 + 2], i4.push($a(o4));
  return i4.join("");
}
function Mi(e5) {
  jr || Ei();
  for (var t5, r5 = e5.length, o4 = r5 % 3, i4 = "", p5 = [], m5 = 16383, M4 = 0, b3 = r5 - o4; M4 < b3; M4 += m5)
    p5.push(ja(e5, M4, M4 + m5 > b3 ? b3 : M4 + m5));
  return o4 === 1 ? (t5 = e5[r5 - 1], i4 += $t[t5 >> 2], i4 += $t[t5 << 4 & 63], i4 += "==") : o4 === 2 && (t5 = (e5[r5 - 2] << 8) + e5[r5 - 1], i4 += $t[t5 >> 10], i4 += $t[t5 >> 4 & 63], i4 += $t[t5 << 2 & 63], i4 += "="), p5.push(i4), p5.join("");
}
function De() {
  return v4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function zt(e5, t5) {
  if (De() < t5)
    throw new RangeError("Invalid typed array length");
  return v4.TYPED_ARRAY_SUPPORT ? (e5 = new Uint8Array(t5), e5.__proto__ = v4.prototype) : (e5 === null && (e5 = new v4(t5)), e5.length = t5), e5;
}
function v4(e5, t5, r5) {
  if (!v4.TYPED_ARRAY_SUPPORT && !(this instanceof v4))
    return new v4(e5, t5, r5);
  if (typeof e5 == "number") {
    if (typeof t5 == "string")
      throw new Error("If encoding is specified then the first argument must be a string");
    return Yr(this, e5);
  }
  return ki(this, e5, t5, r5);
}
function ki(e5, t5, r5, o4) {
  if (typeof t5 == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && t5 instanceof ArrayBuffer ? za(e5, t5, r5, o4) : typeof t5 == "string" ? Ja(e5, t5, r5) : Qa(e5, t5);
}
function Ti(e5) {
  if (typeof e5 != "number")
    throw new TypeError('"size" argument must be a number');
  if (e5 < 0)
    throw new RangeError('"size" argument must not be negative');
}
function Ya(e5, t5, r5, o4) {
  return Ti(t5), t5 <= 0 ? zt(e5, t5) : r5 !== void 0 ? typeof o4 == "string" ? zt(e5, t5).fill(r5, o4) : zt(e5, t5).fill(r5) : zt(e5, t5);
}
function Yr(e5, t5) {
  if (Ti(t5), e5 = zt(e5, t5 < 0 ? 0 : Jr(t5) | 0), !v4.TYPED_ARRAY_SUPPORT)
    for (var r5 = 0; r5 < t5; ++r5)
      e5[r5] = 0;
  return e5;
}
function Ja(e5, t5, r5) {
  if ((typeof r5 != "string" || r5 === "") && (r5 = "utf8"), !v4.isEncoding(r5))
    throw new TypeError('"encoding" must be a valid string encoding');
  var o4 = Ii(t5, r5) | 0;
  e5 = zt(e5, o4);
  var i4 = e5.write(t5, r5);
  return i4 !== o4 && (e5 = e5.slice(0, i4)), e5;
}
function $r(e5, t5) {
  var r5 = t5.length < 0 ? 0 : Jr(t5.length) | 0;
  e5 = zt(e5, r5);
  for (var o4 = 0; o4 < r5; o4 += 1)
    e5[o4] = t5[o4] & 255;
  return e5;
}
function za(e5, t5, r5, o4) {
  if (t5.byteLength, r5 < 0 || t5.byteLength < r5)
    throw new RangeError("'offset' is out of bounds");
  if (t5.byteLength < r5 + (o4 || 0))
    throw new RangeError("'length' is out of bounds");
  return r5 === void 0 && o4 === void 0 ? t5 = new Uint8Array(t5) : o4 === void 0 ? t5 = new Uint8Array(t5, r5) : t5 = new Uint8Array(t5, r5, o4), v4.TYPED_ARRAY_SUPPORT ? (e5 = t5, e5.__proto__ = v4.prototype) : e5 = $r(e5, t5), e5;
}
function Qa(e5, t5) {
  if (jt(t5)) {
    var r5 = Jr(t5.length) | 0;
    return e5 = zt(e5, r5), e5.length === 0 || t5.copy(e5, 0, 0, r5), e5;
  }
  if (t5) {
    if (typeof ArrayBuffer < "u" && t5.buffer instanceof ArrayBuffer || "length" in t5)
      return typeof t5.length != "number" || g0(t5.length) ? zt(e5, 0) : $r(e5, t5);
    if (t5.type === "Buffer" && Array.isArray(t5.data))
      return $r(e5, t5.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function Jr(e5) {
  if (e5 >= De())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + De().toString(16) + " bytes");
  return e5 | 0;
}
function jt(e5) {
  return !!(e5 != null && e5._isBuffer);
}
function Ii(e5, t5) {
  if (jt(e5))
    return e5.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e5) || e5 instanceof ArrayBuffer))
    return e5.byteLength;
  typeof e5 != "string" && (e5 = "" + e5);
  var r5 = e5.length;
  if (r5 === 0)
    return 0;
  for (var o4 = false; ; )
    switch (t5) {
      case "ascii":
      case "latin1":
      case "binary":
        return r5;
      case "utf8":
      case "utf-8":
      case void 0:
        return Pe(e5).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return r5 * 2;
      case "hex":
        return r5 >>> 1;
      case "base64":
        return Pi(e5).length;
      default:
        if (o4)
          return Pe(e5).length;
        t5 = ("" + t5).toLowerCase(), o4 = true;
    }
}
function Ka(e5, t5, r5) {
  var o4 = false;
  if ((t5 === void 0 || t5 < 0) && (t5 = 0), t5 > this.length || ((r5 === void 0 || r5 > this.length) && (r5 = this.length), r5 <= 0) || (r5 >>>= 0, t5 >>>= 0, r5 <= t5))
    return "";
  for (e5 || (e5 = "utf8"); ; )
    switch (e5) {
      case "hex":
        return f0(this, t5, r5);
      case "utf8":
      case "utf-8":
        return Ri(this, t5, r5);
      case "ascii":
        return s0(this, t5, r5);
      case "latin1":
      case "binary":
        return a0(this, t5, r5);
      case "base64":
        return i0(this, t5, r5);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return u0(this, t5, r5);
      default:
        if (o4)
          throw new TypeError("Unknown encoding: " + e5);
        e5 = (e5 + "").toLowerCase(), o4 = true;
    }
}
function de(e5, t5, r5) {
  var o4 = e5[t5];
  e5[t5] = e5[r5], e5[r5] = o4;
}
function Ai(e5, t5, r5, o4, i4) {
  if (e5.length === 0)
    return -1;
  if (typeof r5 == "string" ? (o4 = r5, r5 = 0) : r5 > 2147483647 ? r5 = 2147483647 : r5 < -2147483648 && (r5 = -2147483648), r5 = +r5, isNaN(r5) && (r5 = i4 ? 0 : e5.length - 1), r5 < 0 && (r5 = e5.length + r5), r5 >= e5.length) {
    if (i4)
      return -1;
    r5 = e5.length - 1;
  } else if (r5 < 0)
    if (i4)
      r5 = 0;
    else
      return -1;
  if (typeof t5 == "string" && (t5 = v4.from(t5, o4)), jt(t5))
    return t5.length === 0 ? -1 : Si(e5, t5, r5, o4, i4);
  if (typeof t5 == "number")
    return t5 = t5 & 255, v4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i4 ? Uint8Array.prototype.indexOf.call(e5, t5, r5) : Uint8Array.prototype.lastIndexOf.call(e5, t5, r5) : Si(e5, [t5], r5, o4, i4);
  throw new TypeError("val must be string, number or Buffer");
}
function Si(e5, t5, r5, o4, i4) {
  var p5 = 1, m5 = e5.length, M4 = t5.length;
  if (o4 !== void 0 && (o4 = String(o4).toLowerCase(), o4 === "ucs2" || o4 === "ucs-2" || o4 === "utf16le" || o4 === "utf-16le")) {
    if (e5.length < 2 || t5.length < 2)
      return -1;
    p5 = 2, m5 /= 2, M4 /= 2, r5 /= 2;
  }
  function b3(P4, kt) {
    return p5 === 1 ? P4[kt] : P4.readUInt16BE(kt * p5);
  }
  var R3;
  if (i4) {
    var L4 = -1;
    for (R3 = r5; R3 < m5; R3++)
      if (b3(e5, R3) === b3(t5, L4 === -1 ? 0 : R3 - L4)) {
        if (L4 === -1 && (L4 = R3), R3 - L4 + 1 === M4)
          return L4 * p5;
      } else
        L4 !== -1 && (R3 -= R3 - L4), L4 = -1;
  } else
    for (r5 + M4 > m5 && (r5 = m5 - M4), R3 = r5; R3 >= 0; R3--) {
      for (var T5 = true, D4 = 0; D4 < M4; D4++)
        if (b3(e5, R3 + D4) !== b3(t5, D4)) {
          T5 = false;
          break;
        }
      if (T5)
        return R3;
    }
  return -1;
}
function Xa(e5, t5, r5, o4) {
  r5 = Number(r5) || 0;
  var i4 = e5.length - r5;
  o4 ? (o4 = Number(o4), o4 > i4 && (o4 = i4)) : o4 = i4;
  var p5 = t5.length;
  if (p5 % 2 !== 0)
    throw new TypeError("Invalid hex string");
  o4 > p5 / 2 && (o4 = p5 / 2);
  for (var m5 = 0; m5 < o4; ++m5) {
    var M4 = parseInt(t5.substr(m5 * 2, 2), 16);
    if (isNaN(M4))
      return m5;
    e5[r5 + m5] = M4;
  }
  return m5;
}
function t0(e5, t5, r5, o4) {
  return Ne(Pe(t5, e5.length - r5), e5, r5, o4);
}
function Li(e5, t5, r5, o4) {
  return Ne(p0(t5), e5, r5, o4);
}
function e0(e5, t5, r5, o4) {
  return Li(e5, t5, r5, o4);
}
function r0(e5, t5, r5, o4) {
  return Ne(Pi(t5), e5, r5, o4);
}
function n0(e5, t5, r5, o4) {
  return Ne(m0(t5, e5.length - r5), e5, r5, o4);
}
function i0(e5, t5, r5) {
  return t5 === 0 && r5 === e5.length ? Mi(e5) : Mi(e5.slice(t5, r5));
}
function Ri(e5, t5, r5) {
  r5 = Math.min(e5.length, r5);
  for (var o4 = [], i4 = t5; i4 < r5; ) {
    var p5 = e5[i4], m5 = null, M4 = p5 > 239 ? 4 : p5 > 223 ? 3 : p5 > 191 ? 2 : 1;
    if (i4 + M4 <= r5) {
      var b3, R3, L4, T5;
      switch (M4) {
        case 1:
          p5 < 128 && (m5 = p5);
          break;
        case 2:
          b3 = e5[i4 + 1], (b3 & 192) === 128 && (T5 = (p5 & 31) << 6 | b3 & 63, T5 > 127 && (m5 = T5));
          break;
        case 3:
          b3 = e5[i4 + 1], R3 = e5[i4 + 2], (b3 & 192) === 128 && (R3 & 192) === 128 && (T5 = (p5 & 15) << 12 | (b3 & 63) << 6 | R3 & 63, T5 > 2047 && (T5 < 55296 || T5 > 57343) && (m5 = T5));
          break;
        case 4:
          b3 = e5[i4 + 1], R3 = e5[i4 + 2], L4 = e5[i4 + 3], (b3 & 192) === 128 && (R3 & 192) === 128 && (L4 & 192) === 128 && (T5 = (p5 & 15) << 18 | (b3 & 63) << 12 | (R3 & 63) << 6 | L4 & 63, T5 > 65535 && T5 < 1114112 && (m5 = T5));
      }
    }
    m5 === null ? (m5 = 65533, M4 = 1) : m5 > 65535 && (m5 -= 65536, o4.push(m5 >>> 10 & 1023 | 55296), m5 = 56320 | m5 & 1023), o4.push(m5), i4 += M4;
  }
  return o0(o4);
}
function o0(e5) {
  var t5 = e5.length;
  if (t5 <= bi)
    return String.fromCharCode.apply(String, e5);
  for (var r5 = "", o4 = 0; o4 < t5; )
    r5 += String.fromCharCode.apply(String, e5.slice(o4, o4 += bi));
  return r5;
}
function s0(e5, t5, r5) {
  var o4 = "";
  r5 = Math.min(e5.length, r5);
  for (var i4 = t5; i4 < r5; ++i4)
    o4 += String.fromCharCode(e5[i4] & 127);
  return o4;
}
function a0(e5, t5, r5) {
  var o4 = "";
  r5 = Math.min(e5.length, r5);
  for (var i4 = t5; i4 < r5; ++i4)
    o4 += String.fromCharCode(e5[i4]);
  return o4;
}
function f0(e5, t5, r5) {
  var o4 = e5.length;
  (!t5 || t5 < 0) && (t5 = 0), (!r5 || r5 < 0 || r5 > o4) && (r5 = o4);
  for (var i4 = "", p5 = t5; p5 < r5; ++p5)
    i4 += d0(e5[p5]);
  return i4;
}
function u0(e5, t5, r5) {
  for (var o4 = e5.slice(t5, r5), i4 = "", p5 = 0; p5 < o4.length; p5 += 2)
    i4 += String.fromCharCode(o4[p5] + o4[p5 + 1] * 256);
  return i4;
}
function Tt(e5, t5, r5) {
  if (e5 % 1 !== 0 || e5 < 0)
    throw new RangeError("offset is not uint");
  if (e5 + t5 > r5)
    throw new RangeError("Trying to access beyond buffer length");
}
function Pt(e5, t5, r5, o4, i4, p5) {
  if (!jt(e5))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t5 > i4 || t5 < p5)
    throw new RangeError('"value" argument is out of bounds');
  if (r5 + o4 > e5.length)
    throw new RangeError("Index out of range");
}
function Ue(e5, t5, r5, o4) {
  t5 < 0 && (t5 = 65535 + t5 + 1);
  for (var i4 = 0, p5 = Math.min(e5.length - r5, 2); i4 < p5; ++i4)
    e5[r5 + i4] = (t5 & 255 << 8 * (o4 ? i4 : 1 - i4)) >>> (o4 ? i4 : 1 - i4) * 8;
}
function He(e5, t5, r5, o4) {
  t5 < 0 && (t5 = 4294967295 + t5 + 1);
  for (var i4 = 0, p5 = Math.min(e5.length - r5, 4); i4 < p5; ++i4)
    e5[r5 + i4] = t5 >>> (o4 ? i4 : 3 - i4) * 8 & 255;
}
function Oi(e5, t5, r5, o4, i4, p5) {
  if (r5 + o4 > e5.length)
    throw new RangeError("Index out of range");
  if (r5 < 0)
    throw new RangeError("Index out of range");
}
function Bi(e5, t5, r5, o4, i4) {
  return i4 || Oi(e5, t5, r5, 4, 34028234663852886e22, -34028234663852886e22), Hi(e5, t5, r5, o4, 23, 4), r5 + 4;
}
function Di(e5, t5, r5, o4, i4) {
  return i4 || Oi(e5, t5, r5, 8, 17976931348623157e292, -17976931348623157e292), Hi(e5, t5, r5, o4, 52, 8), r5 + 8;
}
function l0(e5) {
  if (e5 = h0(e5).replace(c0, ""), e5.length < 2)
    return "";
  for (; e5.length % 4 !== 0; )
    e5 = e5 + "=";
  return e5;
}
function h0(e5) {
  return e5.trim ? e5.trim() : e5.replace(/^\s+|\s+$/g, "");
}
function d0(e5) {
  return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
}
function Pe(e5, t5) {
  t5 = t5 || 1 / 0;
  for (var r5, o4 = e5.length, i4 = null, p5 = [], m5 = 0; m5 < o4; ++m5) {
    if (r5 = e5.charCodeAt(m5), r5 > 55295 && r5 < 57344) {
      if (!i4) {
        if (r5 > 56319) {
          (t5 -= 3) > -1 && p5.push(239, 191, 189);
          continue;
        } else if (m5 + 1 === o4) {
          (t5 -= 3) > -1 && p5.push(239, 191, 189);
          continue;
        }
        i4 = r5;
        continue;
      }
      if (r5 < 56320) {
        (t5 -= 3) > -1 && p5.push(239, 191, 189), i4 = r5;
        continue;
      }
      r5 = (i4 - 55296 << 10 | r5 - 56320) + 65536;
    } else
      i4 && (t5 -= 3) > -1 && p5.push(239, 191, 189);
    if (i4 = null, r5 < 128) {
      if ((t5 -= 1) < 0)
        break;
      p5.push(r5);
    } else if (r5 < 2048) {
      if ((t5 -= 2) < 0)
        break;
      p5.push(r5 >> 6 | 192, r5 & 63 | 128);
    } else if (r5 < 65536) {
      if ((t5 -= 3) < 0)
        break;
      p5.push(r5 >> 12 | 224, r5 >> 6 & 63 | 128, r5 & 63 | 128);
    } else if (r5 < 1114112) {
      if ((t5 -= 4) < 0)
        break;
      p5.push(r5 >> 18 | 240, r5 >> 12 & 63 | 128, r5 >> 6 & 63 | 128, r5 & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return p5;
}
function p0(e5) {
  for (var t5 = [], r5 = 0; r5 < e5.length; ++r5)
    t5.push(e5.charCodeAt(r5) & 255);
  return t5;
}
function m0(e5, t5) {
  for (var r5, o4, i4, p5 = [], m5 = 0; m5 < e5.length && !((t5 -= 2) < 0); ++m5)
    r5 = e5.charCodeAt(m5), o4 = r5 >> 8, i4 = r5 % 256, p5.push(i4), p5.push(o4);
  return p5;
}
function Pi(e5) {
  return Ga(l0(e5));
}
function Ne(e5, t5, r5, o4) {
  for (var i4 = 0; i4 < o4 && !(i4 + r5 >= t5.length || i4 >= e5.length); ++i4)
    t5[i4 + r5] = e5[i4];
  return i4;
}
function g0(e5) {
  return e5 !== e5;
}
function v0(e5) {
  return e5 != null && (!!e5._isBuffer || Ui(e5) || y0(e5));
}
function Ui(e5) {
  return !!e5.constructor && typeof e5.constructor.isBuffer == "function" && e5.constructor.isBuffer(e5);
}
function y0(e5) {
  return typeof e5.readFloatLE == "function" && typeof e5.slice == "function" && Ui(e5.slice(0, 0));
}
function We(e5, t5, r5, o4, i4) {
  var p5, m5, M4 = i4 * 8 - o4 - 1, b3 = (1 << M4) - 1, R3 = b3 >> 1, L4 = -7, T5 = r5 ? i4 - 1 : 0, D4 = r5 ? -1 : 1, P4 = e5[t5 + T5];
  for (T5 += D4, p5 = P4 & (1 << -L4) - 1, P4 >>= -L4, L4 += M4; L4 > 0; p5 = p5 * 256 + e5[t5 + T5], T5 += D4, L4 -= 8)
    ;
  for (m5 = p5 & (1 << -L4) - 1, p5 >>= -L4, L4 += o4; L4 > 0; m5 = m5 * 256 + e5[t5 + T5], T5 += D4, L4 -= 8)
    ;
  if (p5 === 0)
    p5 = 1 - R3;
  else {
    if (p5 === b3)
      return m5 ? NaN : (P4 ? -1 : 1) * (1 / 0);
    m5 = m5 + Math.pow(2, o4), p5 = p5 - R3;
  }
  return (P4 ? -1 : 1) * m5 * Math.pow(2, p5 - o4);
}
function Hi(e5, t5, r5, o4, i4, p5) {
  var m5, M4, b3, R3 = p5 * 8 - i4 - 1, L4 = (1 << R3) - 1, T5 = L4 >> 1, D4 = i4 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, P4 = o4 ? 0 : p5 - 1, kt = o4 ? 1 : -1, Nt = t5 < 0 || t5 === 0 && 1 / t5 < 0 ? 1 : 0;
  for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (M4 = isNaN(t5) ? 1 : 0, m5 = L4) : (m5 = Math.floor(Math.log(t5) / Math.LN2), t5 * (b3 = Math.pow(2, -m5)) < 1 && (m5--, b3 *= 2), m5 + T5 >= 1 ? t5 += D4 / b3 : t5 += D4 * Math.pow(2, 1 - T5), t5 * b3 >= 2 && (m5++, b3 /= 2), m5 + T5 >= L4 ? (M4 = 0, m5 = L4) : m5 + T5 >= 1 ? (M4 = (t5 * b3 - 1) * Math.pow(2, i4), m5 = m5 + T5) : (M4 = t5 * Math.pow(2, T5 - 1) * Math.pow(2, i4), m5 = 0)); i4 >= 8; e5[r5 + P4] = M4 & 255, P4 += kt, M4 /= 256, i4 -= 8)
    ;
  for (m5 = m5 << i4 | M4, R3 += i4; R3 > 0; e5[r5 + P4] = m5 & 255, P4 += kt, m5 /= 256, R3 -= 8)
    ;
  e5[r5 + P4 - kt] |= Nt * 128;
}
var $t;
var Wt;
var Za;
var jr;
var bi;
var c0;
var Ni = Be(() => {
  y4();
  w5();
  x4();
  $t = [], Wt = [], Za = typeof Uint8Array < "u" ? Uint8Array : Array, jr = false;
  v4.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
  v4.poolSize = 8192;
  v4._augment = function(e5) {
    return e5.__proto__ = v4.prototype, e5;
  };
  v4.from = function(e5, t5, r5) {
    return ki(null, e5, t5, r5);
  };
  v4.kMaxLength = De();
  v4.TYPED_ARRAY_SUPPORT && (v4.prototype.__proto__ = Uint8Array.prototype, v4.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && v4[Symbol.species]);
  v4.alloc = function(e5, t5, r5) {
    return Ya(null, e5, t5, r5);
  };
  v4.allocUnsafe = function(e5) {
    return Yr(null, e5);
  };
  v4.allocUnsafeSlow = function(e5) {
    return Yr(null, e5);
  };
  v4.isBuffer = v0;
  v4.compare = function(t5, r5) {
    if (!jt(t5) || !jt(r5))
      throw new TypeError("Arguments must be Buffers");
    if (t5 === r5)
      return 0;
    for (var o4 = t5.length, i4 = r5.length, p5 = 0, m5 = Math.min(o4, i4); p5 < m5; ++p5)
      if (t5[p5] !== r5[p5]) {
        o4 = t5[p5], i4 = r5[p5];
        break;
      }
    return o4 < i4 ? -1 : i4 < o4 ? 1 : 0;
  };
  v4.isEncoding = function(t5) {
    switch (String(t5).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  v4.concat = function(t5, r5) {
    if (!Array.isArray(t5))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (t5.length === 0)
      return v4.alloc(0);
    var o4;
    if (r5 === void 0)
      for (r5 = 0, o4 = 0; o4 < t5.length; ++o4)
        r5 += t5[o4].length;
    var i4 = v4.allocUnsafe(r5), p5 = 0;
    for (o4 = 0; o4 < t5.length; ++o4) {
      var m5 = t5[o4];
      if (!jt(m5))
        throw new TypeError('"list" argument must be an Array of Buffers');
      m5.copy(i4, p5), p5 += m5.length;
    }
    return i4;
  };
  v4.byteLength = Ii;
  v4.prototype._isBuffer = true;
  v4.prototype.swap16 = function() {
    var t5 = this.length;
    if (t5 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var r5 = 0; r5 < t5; r5 += 2)
      de(this, r5, r5 + 1);
    return this;
  };
  v4.prototype.swap32 = function() {
    var t5 = this.length;
    if (t5 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var r5 = 0; r5 < t5; r5 += 4)
      de(this, r5, r5 + 3), de(this, r5 + 1, r5 + 2);
    return this;
  };
  v4.prototype.swap64 = function() {
    var t5 = this.length;
    if (t5 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var r5 = 0; r5 < t5; r5 += 8)
      de(this, r5, r5 + 7), de(this, r5 + 1, r5 + 6), de(this, r5 + 2, r5 + 5), de(this, r5 + 3, r5 + 4);
    return this;
  };
  v4.prototype.toString = function() {
    var t5 = this.length | 0;
    return t5 === 0 ? "" : arguments.length === 0 ? Ri(this, 0, t5) : Ka.apply(this, arguments);
  };
  v4.prototype.equals = function(t5) {
    if (!jt(t5))
      throw new TypeError("Argument must be a Buffer");
    return this === t5 ? true : v4.compare(this, t5) === 0;
  };
  v4.prototype.compare = function(t5, r5, o4, i4, p5) {
    if (!jt(t5))
      throw new TypeError("Argument must be a Buffer");
    if (r5 === void 0 && (r5 = 0), o4 === void 0 && (o4 = t5 ? t5.length : 0), i4 === void 0 && (i4 = 0), p5 === void 0 && (p5 = this.length), r5 < 0 || o4 > t5.length || i4 < 0 || p5 > this.length)
      throw new RangeError("out of range index");
    if (i4 >= p5 && r5 >= o4)
      return 0;
    if (i4 >= p5)
      return -1;
    if (r5 >= o4)
      return 1;
    if (r5 >>>= 0, o4 >>>= 0, i4 >>>= 0, p5 >>>= 0, this === t5)
      return 0;
    for (var m5 = p5 - i4, M4 = o4 - r5, b3 = Math.min(m5, M4), R3 = this.slice(i4, p5), L4 = t5.slice(r5, o4), T5 = 0; T5 < b3; ++T5)
      if (R3[T5] !== L4[T5]) {
        m5 = R3[T5], M4 = L4[T5];
        break;
      }
    return m5 < M4 ? -1 : M4 < m5 ? 1 : 0;
  };
  v4.prototype.includes = function(t5, r5, o4) {
    return this.indexOf(t5, r5, o4) !== -1;
  };
  v4.prototype.indexOf = function(t5, r5, o4) {
    return Ai(this, t5, r5, o4, true);
  };
  v4.prototype.lastIndexOf = function(t5, r5, o4) {
    return Ai(this, t5, r5, o4, false);
  };
  v4.prototype.write = function(t5, r5, o4, i4) {
    if (r5 === void 0)
      i4 = "utf8", o4 = this.length, r5 = 0;
    else if (o4 === void 0 && typeof r5 == "string")
      i4 = r5, o4 = this.length, r5 = 0;
    else if (isFinite(r5))
      r5 = r5 | 0, isFinite(o4) ? (o4 = o4 | 0, i4 === void 0 && (i4 = "utf8")) : (i4 = o4, o4 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var p5 = this.length - r5;
    if ((o4 === void 0 || o4 > p5) && (o4 = p5), t5.length > 0 && (o4 < 0 || r5 < 0) || r5 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    i4 || (i4 = "utf8");
    for (var m5 = false; ; )
      switch (i4) {
        case "hex":
          return Xa(this, t5, r5, o4);
        case "utf8":
        case "utf-8":
          return t0(this, t5, r5, o4);
        case "ascii":
          return Li(this, t5, r5, o4);
        case "latin1":
        case "binary":
          return e0(this, t5, r5, o4);
        case "base64":
          return r0(this, t5, r5, o4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return n0(this, t5, r5, o4);
        default:
          if (m5)
            throw new TypeError("Unknown encoding: " + i4);
          i4 = ("" + i4).toLowerCase(), m5 = true;
      }
  };
  v4.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  bi = 4096;
  v4.prototype.slice = function(t5, r5) {
    var o4 = this.length;
    t5 = ~~t5, r5 = r5 === void 0 ? o4 : ~~r5, t5 < 0 ? (t5 += o4, t5 < 0 && (t5 = 0)) : t5 > o4 && (t5 = o4), r5 < 0 ? (r5 += o4, r5 < 0 && (r5 = 0)) : r5 > o4 && (r5 = o4), r5 < t5 && (r5 = t5);
    var i4;
    if (v4.TYPED_ARRAY_SUPPORT)
      i4 = this.subarray(t5, r5), i4.__proto__ = v4.prototype;
    else {
      var p5 = r5 - t5;
      i4 = new v4(p5, void 0);
      for (var m5 = 0; m5 < p5; ++m5)
        i4[m5] = this[m5 + t5];
    }
    return i4;
  };
  v4.prototype.readUIntLE = function(t5, r5, o4) {
    t5 = t5 | 0, r5 = r5 | 0, o4 || Tt(t5, r5, this.length);
    for (var i4 = this[t5], p5 = 1, m5 = 0; ++m5 < r5 && (p5 *= 256); )
      i4 += this[t5 + m5] * p5;
    return i4;
  };
  v4.prototype.readUIntBE = function(t5, r5, o4) {
    t5 = t5 | 0, r5 = r5 | 0, o4 || Tt(t5, r5, this.length);
    for (var i4 = this[t5 + --r5], p5 = 1; r5 > 0 && (p5 *= 256); )
      i4 += this[t5 + --r5] * p5;
    return i4;
  };
  v4.prototype.readUInt8 = function(t5, r5) {
    return r5 || Tt(t5, 1, this.length), this[t5];
  };
  v4.prototype.readUInt16LE = function(t5, r5) {
    return r5 || Tt(t5, 2, this.length), this[t5] | this[t5 + 1] << 8;
  };
  v4.prototype.readUInt16BE = function(t5, r5) {
    return r5 || Tt(t5, 2, this.length), this[t5] << 8 | this[t5 + 1];
  };
  v4.prototype.readUInt32LE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), (this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16) + this[t5 + 3] * 16777216;
  };
  v4.prototype.readUInt32BE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), this[t5] * 16777216 + (this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3]);
  };
  v4.prototype.readIntLE = function(t5, r5, o4) {
    t5 = t5 | 0, r5 = r5 | 0, o4 || Tt(t5, r5, this.length);
    for (var i4 = this[t5], p5 = 1, m5 = 0; ++m5 < r5 && (p5 *= 256); )
      i4 += this[t5 + m5] * p5;
    return p5 *= 128, i4 >= p5 && (i4 -= Math.pow(2, 8 * r5)), i4;
  };
  v4.prototype.readIntBE = function(t5, r5, o4) {
    t5 = t5 | 0, r5 = r5 | 0, o4 || Tt(t5, r5, this.length);
    for (var i4 = r5, p5 = 1, m5 = this[t5 + --i4]; i4 > 0 && (p5 *= 256); )
      m5 += this[t5 + --i4] * p5;
    return p5 *= 128, m5 >= p5 && (m5 -= Math.pow(2, 8 * r5)), m5;
  };
  v4.prototype.readInt8 = function(t5, r5) {
    return r5 || Tt(t5, 1, this.length), this[t5] & 128 ? (255 - this[t5] + 1) * -1 : this[t5];
  };
  v4.prototype.readInt16LE = function(t5, r5) {
    r5 || Tt(t5, 2, this.length);
    var o4 = this[t5] | this[t5 + 1] << 8;
    return o4 & 32768 ? o4 | 4294901760 : o4;
  };
  v4.prototype.readInt16BE = function(t5, r5) {
    r5 || Tt(t5, 2, this.length);
    var o4 = this[t5 + 1] | this[t5] << 8;
    return o4 & 32768 ? o4 | 4294901760 : o4;
  };
  v4.prototype.readInt32LE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16 | this[t5 + 3] << 24;
  };
  v4.prototype.readInt32BE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), this[t5] << 24 | this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3];
  };
  v4.prototype.readFloatLE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), We(this, t5, true, 23, 4);
  };
  v4.prototype.readFloatBE = function(t5, r5) {
    return r5 || Tt(t5, 4, this.length), We(this, t5, false, 23, 4);
  };
  v4.prototype.readDoubleLE = function(t5, r5) {
    return r5 || Tt(t5, 8, this.length), We(this, t5, true, 52, 8);
  };
  v4.prototype.readDoubleBE = function(t5, r5) {
    return r5 || Tt(t5, 8, this.length), We(this, t5, false, 52, 8);
  };
  v4.prototype.writeUIntLE = function(t5, r5, o4, i4) {
    if (t5 = +t5, r5 = r5 | 0, o4 = o4 | 0, !i4) {
      var p5 = Math.pow(2, 8 * o4) - 1;
      Pt(this, t5, r5, o4, p5, 0);
    }
    var m5 = 1, M4 = 0;
    for (this[r5] = t5 & 255; ++M4 < o4 && (m5 *= 256); )
      this[r5 + M4] = t5 / m5 & 255;
    return r5 + o4;
  };
  v4.prototype.writeUIntBE = function(t5, r5, o4, i4) {
    if (t5 = +t5, r5 = r5 | 0, o4 = o4 | 0, !i4) {
      var p5 = Math.pow(2, 8 * o4) - 1;
      Pt(this, t5, r5, o4, p5, 0);
    }
    var m5 = o4 - 1, M4 = 1;
    for (this[r5 + m5] = t5 & 255; --m5 >= 0 && (M4 *= 256); )
      this[r5 + m5] = t5 / M4 & 255;
    return r5 + o4;
  };
  v4.prototype.writeUInt8 = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 1, 255, 0), v4.TYPED_ARRAY_SUPPORT || (t5 = Math.floor(t5)), this[r5] = t5 & 255, r5 + 1;
  };
  v4.prototype.writeUInt16LE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 2, 65535, 0), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 & 255, this[r5 + 1] = t5 >>> 8) : Ue(this, t5, r5, true), r5 + 2;
  };
  v4.prototype.writeUInt16BE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 2, 65535, 0), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 >>> 8, this[r5 + 1] = t5 & 255) : Ue(this, t5, r5, false), r5 + 2;
  };
  v4.prototype.writeUInt32LE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 4, 4294967295, 0), v4.TYPED_ARRAY_SUPPORT ? (this[r5 + 3] = t5 >>> 24, this[r5 + 2] = t5 >>> 16, this[r5 + 1] = t5 >>> 8, this[r5] = t5 & 255) : He(this, t5, r5, true), r5 + 4;
  };
  v4.prototype.writeUInt32BE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 4, 4294967295, 0), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = t5 & 255) : He(this, t5, r5, false), r5 + 4;
  };
  v4.prototype.writeIntLE = function(t5, r5, o4, i4) {
    if (t5 = +t5, r5 = r5 | 0, !i4) {
      var p5 = Math.pow(2, 8 * o4 - 1);
      Pt(this, t5, r5, o4, p5 - 1, -p5);
    }
    var m5 = 0, M4 = 1, b3 = 0;
    for (this[r5] = t5 & 255; ++m5 < o4 && (M4 *= 256); )
      t5 < 0 && b3 === 0 && this[r5 + m5 - 1] !== 0 && (b3 = 1), this[r5 + m5] = (t5 / M4 >> 0) - b3 & 255;
    return r5 + o4;
  };
  v4.prototype.writeIntBE = function(t5, r5, o4, i4) {
    if (t5 = +t5, r5 = r5 | 0, !i4) {
      var p5 = Math.pow(2, 8 * o4 - 1);
      Pt(this, t5, r5, o4, p5 - 1, -p5);
    }
    var m5 = o4 - 1, M4 = 1, b3 = 0;
    for (this[r5 + m5] = t5 & 255; --m5 >= 0 && (M4 *= 256); )
      t5 < 0 && b3 === 0 && this[r5 + m5 + 1] !== 0 && (b3 = 1), this[r5 + m5] = (t5 / M4 >> 0) - b3 & 255;
    return r5 + o4;
  };
  v4.prototype.writeInt8 = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 1, 127, -128), v4.TYPED_ARRAY_SUPPORT || (t5 = Math.floor(t5)), t5 < 0 && (t5 = 255 + t5 + 1), this[r5] = t5 & 255, r5 + 1;
  };
  v4.prototype.writeInt16LE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 2, 32767, -32768), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 & 255, this[r5 + 1] = t5 >>> 8) : Ue(this, t5, r5, true), r5 + 2;
  };
  v4.prototype.writeInt16BE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 2, 32767, -32768), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 >>> 8, this[r5 + 1] = t5 & 255) : Ue(this, t5, r5, false), r5 + 2;
  };
  v4.prototype.writeInt32LE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 4, 2147483647, -2147483648), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 & 255, this[r5 + 1] = t5 >>> 8, this[r5 + 2] = t5 >>> 16, this[r5 + 3] = t5 >>> 24) : He(this, t5, r5, true), r5 + 4;
  };
  v4.prototype.writeInt32BE = function(t5, r5, o4) {
    return t5 = +t5, r5 = r5 | 0, o4 || Pt(this, t5, r5, 4, 2147483647, -2147483648), t5 < 0 && (t5 = 4294967295 + t5 + 1), v4.TYPED_ARRAY_SUPPORT ? (this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = t5 & 255) : He(this, t5, r5, false), r5 + 4;
  };
  v4.prototype.writeFloatLE = function(t5, r5, o4) {
    return Bi(this, t5, r5, true, o4);
  };
  v4.prototype.writeFloatBE = function(t5, r5, o4) {
    return Bi(this, t5, r5, false, o4);
  };
  v4.prototype.writeDoubleLE = function(t5, r5, o4) {
    return Di(this, t5, r5, true, o4);
  };
  v4.prototype.writeDoubleBE = function(t5, r5, o4) {
    return Di(this, t5, r5, false, o4);
  };
  v4.prototype.copy = function(t5, r5, o4, i4) {
    if (o4 || (o4 = 0), !i4 && i4 !== 0 && (i4 = this.length), r5 >= t5.length && (r5 = t5.length), r5 || (r5 = 0), i4 > 0 && i4 < o4 && (i4 = o4), i4 === o4 || t5.length === 0 || this.length === 0)
      return 0;
    if (r5 < 0)
      throw new RangeError("targetStart out of bounds");
    if (o4 < 0 || o4 >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (i4 < 0)
      throw new RangeError("sourceEnd out of bounds");
    i4 > this.length && (i4 = this.length), t5.length - r5 < i4 - o4 && (i4 = t5.length - r5 + o4);
    var p5 = i4 - o4, m5;
    if (this === t5 && o4 < r5 && r5 < i4)
      for (m5 = p5 - 1; m5 >= 0; --m5)
        t5[m5 + r5] = this[m5 + o4];
    else if (p5 < 1e3 || !v4.TYPED_ARRAY_SUPPORT)
      for (m5 = 0; m5 < p5; ++m5)
        t5[m5 + r5] = this[m5 + o4];
    else
      Uint8Array.prototype.set.call(t5, this.subarray(o4, o4 + p5), r5);
    return p5;
  };
  v4.prototype.fill = function(t5, r5, o4, i4) {
    if (typeof t5 == "string") {
      if (typeof r5 == "string" ? (i4 = r5, r5 = 0, o4 = this.length) : typeof o4 == "string" && (i4 = o4, o4 = this.length), t5.length === 1) {
        var p5 = t5.charCodeAt(0);
        p5 < 256 && (t5 = p5);
      }
      if (i4 !== void 0 && typeof i4 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof i4 == "string" && !v4.isEncoding(i4))
        throw new TypeError("Unknown encoding: " + i4);
    } else
      typeof t5 == "number" && (t5 = t5 & 255);
    if (r5 < 0 || this.length < r5 || this.length < o4)
      throw new RangeError("Out of range index");
    if (o4 <= r5)
      return this;
    r5 = r5 >>> 0, o4 = o4 === void 0 ? this.length : o4 >>> 0, t5 || (t5 = 0);
    var m5;
    if (typeof t5 == "number")
      for (m5 = r5; m5 < o4; ++m5)
        this[m5] = t5;
    else {
      var M4 = jt(t5) ? t5 : Pe(new v4(t5, i4).toString()), b3 = M4.length;
      for (m5 = 0; m5 < o4 - r5; ++m5)
        this[m5 + r5] = M4[m5 % b3];
    }
    return this;
  };
  c0 = /[^+\/0-9A-Za-z-_]/g;
});
var x4 = Be(() => {
  Ni();
});
var nn = Dt((F4) => {
  "use strict";
  y4();
  w5();
  x4();
  Object.defineProperty(F4, "__esModule", { value: true });
  F4.getLocalStorage = F4.getLocalStorageOrThrow = F4.getCrypto = F4.getCryptoOrThrow = F4.getLocation = F4.getLocationOrThrow = F4.getNavigator = F4.getNavigatorOrThrow = F4.getDocument = F4.getDocumentOrThrow = F4.getFromWindowOrThrow = F4.getFromWindow = void 0;
  function pe(e5) {
    let t5;
    return typeof globalThis < "u" && typeof globalThis[e5] < "u" && (t5 = globalThis[e5]), t5;
  }
  F4.getFromWindow = pe;
  function we(e5) {
    let t5 = pe(e5);
    if (!t5)
      throw new Error(`${e5} is not defined in Window`);
    return t5;
  }
  F4.getFromWindowOrThrow = we;
  function P0() {
    return we("document");
  }
  F4.getDocumentOrThrow = P0;
  function U0() {
    return pe("document");
  }
  F4.getDocument = U0;
  function H0() {
    return we("navigator");
  }
  F4.getNavigatorOrThrow = H0;
  function N0() {
    return pe("navigator");
  }
  F4.getNavigator = N0;
  function W0() {
    return we("location");
  }
  F4.getLocationOrThrow = W0;
  function F0() {
    return pe("location");
  }
  F4.getLocation = F0;
  function q0() {
    return we("crypto");
  }
  F4.getCryptoOrThrow = q0;
  function V0() {
    return pe("crypto");
  }
  F4.getCrypto = V0;
  function Z0() {
    return we("localStorage");
  }
  F4.getLocalStorageOrThrow = Z0;
  function G0() {
    return pe("localStorage");
  }
  F4.getLocalStorage = G0;
});
var po = Dt((je) => {
  "use strict";
  y4();
  w5();
  x4();
  Object.defineProperty(je, "__esModule", { value: true });
  je.getWindowMetadata = void 0;
  var ho = nn();
  function $0() {
    let e5, t5;
    try {
      e5 = ho.getDocumentOrThrow(), t5 = ho.getLocationOrThrow();
    } catch (T5) {
      return null;
    }
    function r5() {
      let T5 = e5.getElementsByTagName("link"), D4 = [];
      for (let P4 = 0; P4 < T5.length; P4++) {
        let kt = T5[P4], Nt = kt.getAttribute("rel");
        if (Nt && Nt.toLowerCase().indexOf("icon") > -1) {
          let U3 = kt.getAttribute("href");
          if (U3)
            if (U3.toLowerCase().indexOf("https:") === -1 && U3.toLowerCase().indexOf("http:") === -1 && U3.indexOf("//") !== 0) {
              let Jt = t5.protocol + "//" + t5.host;
              if (U3.indexOf("/") === 0)
                Jt += U3;
              else {
                let Lt = t5.pathname.split("/");
                Lt.pop(), Jt += Lt.join("/") + "/" + U3;
              }
              D4.push(Jt);
            } else if (U3.indexOf("//") === 0) {
              let Jt = t5.protocol + U3;
              D4.push(Jt);
            } else
              D4.push(U3);
        }
      }
      return D4;
    }
    function o4(...T5) {
      let D4 = e5.getElementsByTagName("meta");
      for (let P4 = 0; P4 < D4.length; P4++) {
        let kt = D4[P4], Nt = ["itemprop", "property", "name"].map((U3) => kt.getAttribute(U3)).filter((U3) => U3 ? T5.includes(U3) : false);
        if (Nt.length && Nt) {
          let U3 = kt.getAttribute("content");
          if (U3)
            return U3;
        }
      }
      return "";
    }
    function i4() {
      let T5 = o4("name", "og:site_name", "og:title", "twitter:title");
      return T5 || (T5 = e5.title), T5;
    }
    function p5() {
      return o4("description", "og:description", "twitter:description", "keywords");
    }
    let m5 = i4(), M4 = p5(), b3 = t5.origin, R3 = r5();
    return { description: M4, url: b3, icons: R3, name: m5 };
  }
  je.getWindowMetadata = $0;
});
var To = Dt(() => {
  y4();
  w5();
  x4();
});
var Ao = Dt((Io, un) => {
  y4();
  w5();
  x4();
  (function(e5, t5) {
    "use strict";
    function r5(g4, n4) {
      if (!g4)
        throw new Error(n4 || "Assertion failed");
    }
    function o4(g4, n4) {
      g4.super_ = n4;
      var a4 = function() {
      };
      a4.prototype = n4.prototype, g4.prototype = new a4(), g4.prototype.constructor = g4;
    }
    function i4(g4, n4, a4) {
      if (i4.isBN(g4))
        return g4;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, g4 !== null && ((n4 === "le" || n4 === "be") && (a4 = n4, n4 = 10), this._init(g4 || 0, n4 || 10, a4 || "be"));
    }
    typeof e5 == "object" ? e5.exports = i4 : t5.BN = i4, i4.BN = i4, i4.wordSize = 26;
    var p5;
    try {
      p5 = To().Buffer;
    } catch (g4) {
    }
    i4.isBN = function(n4) {
      return n4 instanceof i4 ? true : n4 !== null && typeof n4 == "object" && n4.constructor.wordSize === i4.wordSize && Array.isArray(n4.words);
    }, i4.max = function(n4, a4) {
      return n4.cmp(a4) > 0 ? n4 : a4;
    }, i4.min = function(n4, a4) {
      return n4.cmp(a4) < 0 ? n4 : a4;
    }, i4.prototype._init = function(n4, a4, u5) {
      if (typeof n4 == "number")
        return this._initNumber(n4, a4, u5);
      if (typeof n4 == "object")
        return this._initArray(n4, a4, u5);
      a4 === "hex" && (a4 = 16), r5(a4 === (a4 | 0) && a4 >= 2 && a4 <= 36), n4 = n4.toString().replace(/\s+/g, "");
      var c4 = 0;
      n4[0] === "-" && c4++, a4 === 16 ? this._parseHex(n4, c4) : this._parseBase(n4, a4, c4), n4[0] === "-" && (this.negative = 1), this.strip(), u5 === "le" && this._initArray(this.toArray(), a4, u5);
    }, i4.prototype._initNumber = function(n4, a4, u5) {
      n4 < 0 && (this.negative = 1, n4 = -n4), n4 < 67108864 ? (this.words = [n4 & 67108863], this.length = 1) : n4 < 4503599627370496 ? (this.words = [n4 & 67108863, n4 / 67108864 & 67108863], this.length = 2) : (r5(n4 < 9007199254740992), this.words = [n4 & 67108863, n4 / 67108864 & 67108863, 1], this.length = 3), u5 === "le" && this._initArray(this.toArray(), a4, u5);
    }, i4.prototype._initArray = function(n4, a4, u5) {
      if (r5(typeof n4.length == "number"), n4.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(n4.length / 3), this.words = new Array(this.length);
      for (var c4 = 0; c4 < this.length; c4++)
        this.words[c4] = 0;
      var d4, C4, _5 = 0;
      if (u5 === "be")
        for (c4 = n4.length - 1, d4 = 0; c4 >= 0; c4 -= 3)
          C4 = n4[c4] | n4[c4 - 1] << 8 | n4[c4 - 2] << 16, this.words[d4] |= C4 << _5 & 67108863, this.words[d4 + 1] = C4 >>> 26 - _5 & 67108863, _5 += 24, _5 >= 26 && (_5 -= 26, d4++);
      else if (u5 === "le")
        for (c4 = 0, d4 = 0; c4 < n4.length; c4 += 3)
          C4 = n4[c4] | n4[c4 + 1] << 8 | n4[c4 + 2] << 16, this.words[d4] |= C4 << _5 & 67108863, this.words[d4 + 1] = C4 >>> 26 - _5 & 67108863, _5 += 24, _5 >= 26 && (_5 -= 26, d4++);
      return this.strip();
    };
    function m5(g4, n4, a4) {
      for (var u5 = 0, c4 = Math.min(g4.length, a4), d4 = n4; d4 < c4; d4++) {
        var C4 = g4.charCodeAt(d4) - 48;
        u5 <<= 4, C4 >= 49 && C4 <= 54 ? u5 |= C4 - 49 + 10 : C4 >= 17 && C4 <= 22 ? u5 |= C4 - 17 + 10 : u5 |= C4 & 15;
      }
      return u5;
    }
    i4.prototype._parseHex = function(n4, a4) {
      this.length = Math.ceil((n4.length - a4) / 6), this.words = new Array(this.length);
      for (var u5 = 0; u5 < this.length; u5++)
        this.words[u5] = 0;
      var c4, d4, C4 = 0;
      for (u5 = n4.length - 6, c4 = 0; u5 >= a4; u5 -= 6)
        d4 = m5(n4, u5, u5 + 6), this.words[c4] |= d4 << C4 & 67108863, this.words[c4 + 1] |= d4 >>> 26 - C4 & 4194303, C4 += 24, C4 >= 26 && (C4 -= 26, c4++);
      u5 + 6 !== a4 && (d4 = m5(n4, a4, u5 + 6), this.words[c4] |= d4 << C4 & 67108863, this.words[c4 + 1] |= d4 >>> 26 - C4 & 4194303), this.strip();
    };
    function M4(g4, n4, a4, u5) {
      for (var c4 = 0, d4 = Math.min(g4.length, a4), C4 = n4; C4 < d4; C4++) {
        var _5 = g4.charCodeAt(C4) - 48;
        c4 *= u5, _5 >= 49 ? c4 += _5 - 49 + 10 : _5 >= 17 ? c4 += _5 - 17 + 10 : c4 += _5;
      }
      return c4;
    }
    i4.prototype._parseBase = function(n4, a4, u5) {
      this.words = [0], this.length = 1;
      for (var c4 = 0, d4 = 1; d4 <= 67108863; d4 *= a4)
        c4++;
      c4--, d4 = d4 / a4 | 0;
      for (var C4 = n4.length - u5, _5 = C4 % c4, l5 = Math.min(C4, C4 - _5) + u5, s4 = 0, h5 = u5; h5 < l5; h5 += c4)
        s4 = M4(n4, h5, h5 + c4, a4), this.imuln(d4), this.words[0] + s4 < 67108864 ? this.words[0] += s4 : this._iaddn(s4);
      if (_5 !== 0) {
        var k5 = 1;
        for (s4 = M4(n4, h5, n4.length, a4), h5 = 0; h5 < _5; h5++)
          k5 *= a4;
        this.imuln(k5), this.words[0] + s4 < 67108864 ? this.words[0] += s4 : this._iaddn(s4);
      }
    }, i4.prototype.copy = function(n4) {
      n4.words = new Array(this.length);
      for (var a4 = 0; a4 < this.length; a4++)
        n4.words[a4] = this.words[a4];
      n4.length = this.length, n4.negative = this.negative, n4.red = this.red;
    }, i4.prototype.clone = function() {
      var n4 = new i4(null);
      return this.copy(n4), n4;
    }, i4.prototype._expand = function(n4) {
      for (; this.length < n4; )
        this.words[this.length++] = 0;
      return this;
    }, i4.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i4.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i4.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var b3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], R3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], L4 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i4.prototype.toString = function(n4, a4) {
      n4 = n4 || 10, a4 = a4 | 0 || 1;
      var u5;
      if (n4 === 16 || n4 === "hex") {
        u5 = "";
        for (var c4 = 0, d4 = 0, C4 = 0; C4 < this.length; C4++) {
          var _5 = this.words[C4], l5 = ((_5 << c4 | d4) & 16777215).toString(16);
          d4 = _5 >>> 24 - c4 & 16777215, d4 !== 0 || C4 !== this.length - 1 ? u5 = b3[6 - l5.length] + l5 + u5 : u5 = l5 + u5, c4 += 2, c4 >= 26 && (c4 -= 26, C4--);
        }
        for (d4 !== 0 && (u5 = d4.toString(16) + u5); u5.length % a4 !== 0; )
          u5 = "0" + u5;
        return this.negative !== 0 && (u5 = "-" + u5), u5;
      }
      if (n4 === (n4 | 0) && n4 >= 2 && n4 <= 36) {
        var s4 = R3[n4], h5 = L4[n4];
        u5 = "";
        var k5 = this.clone();
        for (k5.negative = 0; !k5.isZero(); ) {
          var I4 = k5.modn(h5).toString(n4);
          k5 = k5.idivn(h5), k5.isZero() ? u5 = I4 + u5 : u5 = b3[s4 - I4.length] + I4 + u5;
        }
        for (this.isZero() && (u5 = "0" + u5); u5.length % a4 !== 0; )
          u5 = "0" + u5;
        return this.negative !== 0 && (u5 = "-" + u5), u5;
      }
      r5(false, "Base should be between 2 and 36");
    }, i4.prototype.toNumber = function() {
      var n4 = this.words[0];
      return this.length === 2 ? n4 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? n4 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r5(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -n4 : n4;
    }, i4.prototype.toJSON = function() {
      return this.toString(16);
    }, i4.prototype.toBuffer = function(n4, a4) {
      return r5(typeof p5 < "u"), this.toArrayLike(p5, n4, a4);
    }, i4.prototype.toArray = function(n4, a4) {
      return this.toArrayLike(Array, n4, a4);
    }, i4.prototype.toArrayLike = function(n4, a4, u5) {
      var c4 = this.byteLength(), d4 = u5 || Math.max(1, c4);
      r5(c4 <= d4, "byte array longer than desired length"), r5(d4 > 0, "Requested array length <= 0"), this.strip();
      var C4 = a4 === "le", _5 = new n4(d4), l5, s4, h5 = this.clone();
      if (C4) {
        for (s4 = 0; !h5.isZero(); s4++)
          l5 = h5.andln(255), h5.iushrn(8), _5[s4] = l5;
        for (; s4 < d4; s4++)
          _5[s4] = 0;
      } else {
        for (s4 = 0; s4 < d4 - c4; s4++)
          _5[s4] = 0;
        for (s4 = 0; !h5.isZero(); s4++)
          l5 = h5.andln(255), h5.iushrn(8), _5[d4 - s4 - 1] = l5;
      }
      return _5;
    }, Math.clz32 ? i4.prototype._countBits = function(n4) {
      return 32 - Math.clz32(n4);
    } : i4.prototype._countBits = function(n4) {
      var a4 = n4, u5 = 0;
      return a4 >= 4096 && (u5 += 13, a4 >>>= 13), a4 >= 64 && (u5 += 7, a4 >>>= 7), a4 >= 8 && (u5 += 4, a4 >>>= 4), a4 >= 2 && (u5 += 2, a4 >>>= 2), u5 + a4;
    }, i4.prototype._zeroBits = function(n4) {
      if (n4 === 0)
        return 26;
      var a4 = n4, u5 = 0;
      return (a4 & 8191) === 0 && (u5 += 13, a4 >>>= 13), (a4 & 127) === 0 && (u5 += 7, a4 >>>= 7), (a4 & 15) === 0 && (u5 += 4, a4 >>>= 4), (a4 & 3) === 0 && (u5 += 2, a4 >>>= 2), (a4 & 1) === 0 && u5++, u5;
    }, i4.prototype.bitLength = function() {
      var n4 = this.words[this.length - 1], a4 = this._countBits(n4);
      return (this.length - 1) * 26 + a4;
    };
    function T5(g4) {
      for (var n4 = new Array(g4.bitLength()), a4 = 0; a4 < n4.length; a4++) {
        var u5 = a4 / 26 | 0, c4 = a4 % 26;
        n4[a4] = (g4.words[u5] & 1 << c4) >>> c4;
      }
      return n4;
    }
    i4.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var n4 = 0, a4 = 0; a4 < this.length; a4++) {
        var u5 = this._zeroBits(this.words[a4]);
        if (n4 += u5, u5 !== 26)
          break;
      }
      return n4;
    }, i4.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i4.prototype.toTwos = function(n4) {
      return this.negative !== 0 ? this.abs().inotn(n4).iaddn(1) : this.clone();
    }, i4.prototype.fromTwos = function(n4) {
      return this.testn(n4 - 1) ? this.notn(n4).iaddn(1).ineg() : this.clone();
    }, i4.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i4.prototype.neg = function() {
      return this.clone().ineg();
    }, i4.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i4.prototype.iuor = function(n4) {
      for (; this.length < n4.length; )
        this.words[this.length++] = 0;
      for (var a4 = 0; a4 < n4.length; a4++)
        this.words[a4] = this.words[a4] | n4.words[a4];
      return this.strip();
    }, i4.prototype.ior = function(n4) {
      return r5((this.negative | n4.negative) === 0), this.iuor(n4);
    }, i4.prototype.or = function(n4) {
      return this.length > n4.length ? this.clone().ior(n4) : n4.clone().ior(this);
    }, i4.prototype.uor = function(n4) {
      return this.length > n4.length ? this.clone().iuor(n4) : n4.clone().iuor(this);
    }, i4.prototype.iuand = function(n4) {
      var a4;
      this.length > n4.length ? a4 = n4 : a4 = this;
      for (var u5 = 0; u5 < a4.length; u5++)
        this.words[u5] = this.words[u5] & n4.words[u5];
      return this.length = a4.length, this.strip();
    }, i4.prototype.iand = function(n4) {
      return r5((this.negative | n4.negative) === 0), this.iuand(n4);
    }, i4.prototype.and = function(n4) {
      return this.length > n4.length ? this.clone().iand(n4) : n4.clone().iand(this);
    }, i4.prototype.uand = function(n4) {
      return this.length > n4.length ? this.clone().iuand(n4) : n4.clone().iuand(this);
    }, i4.prototype.iuxor = function(n4) {
      var a4, u5;
      this.length > n4.length ? (a4 = this, u5 = n4) : (a4 = n4, u5 = this);
      for (var c4 = 0; c4 < u5.length; c4++)
        this.words[c4] = a4.words[c4] ^ u5.words[c4];
      if (this !== a4)
        for (; c4 < a4.length; c4++)
          this.words[c4] = a4.words[c4];
      return this.length = a4.length, this.strip();
    }, i4.prototype.ixor = function(n4) {
      return r5((this.negative | n4.negative) === 0), this.iuxor(n4);
    }, i4.prototype.xor = function(n4) {
      return this.length > n4.length ? this.clone().ixor(n4) : n4.clone().ixor(this);
    }, i4.prototype.uxor = function(n4) {
      return this.length > n4.length ? this.clone().iuxor(n4) : n4.clone().iuxor(this);
    }, i4.prototype.inotn = function(n4) {
      r5(typeof n4 == "number" && n4 >= 0);
      var a4 = Math.ceil(n4 / 26) | 0, u5 = n4 % 26;
      this._expand(a4), u5 > 0 && a4--;
      for (var c4 = 0; c4 < a4; c4++)
        this.words[c4] = ~this.words[c4] & 67108863;
      return u5 > 0 && (this.words[c4] = ~this.words[c4] & 67108863 >> 26 - u5), this.strip();
    }, i4.prototype.notn = function(n4) {
      return this.clone().inotn(n4);
    }, i4.prototype.setn = function(n4, a4) {
      r5(typeof n4 == "number" && n4 >= 0);
      var u5 = n4 / 26 | 0, c4 = n4 % 26;
      return this._expand(u5 + 1), a4 ? this.words[u5] = this.words[u5] | 1 << c4 : this.words[u5] = this.words[u5] & ~(1 << c4), this.strip();
    }, i4.prototype.iadd = function(n4) {
      var a4;
      if (this.negative !== 0 && n4.negative === 0)
        return this.negative = 0, a4 = this.isub(n4), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && n4.negative !== 0)
        return n4.negative = 0, a4 = this.isub(n4), n4.negative = 1, a4._normSign();
      var u5, c4;
      this.length > n4.length ? (u5 = this, c4 = n4) : (u5 = n4, c4 = this);
      for (var d4 = 0, C4 = 0; C4 < c4.length; C4++)
        a4 = (u5.words[C4] | 0) + (c4.words[C4] | 0) + d4, this.words[C4] = a4 & 67108863, d4 = a4 >>> 26;
      for (; d4 !== 0 && C4 < u5.length; C4++)
        a4 = (u5.words[C4] | 0) + d4, this.words[C4] = a4 & 67108863, d4 = a4 >>> 26;
      if (this.length = u5.length, d4 !== 0)
        this.words[this.length] = d4, this.length++;
      else if (u5 !== this)
        for (; C4 < u5.length; C4++)
          this.words[C4] = u5.words[C4];
      return this;
    }, i4.prototype.add = function(n4) {
      var a4;
      return n4.negative !== 0 && this.negative === 0 ? (n4.negative = 0, a4 = this.sub(n4), n4.negative ^= 1, a4) : n4.negative === 0 && this.negative !== 0 ? (this.negative = 0, a4 = n4.sub(this), this.negative = 1, a4) : this.length > n4.length ? this.clone().iadd(n4) : n4.clone().iadd(this);
    }, i4.prototype.isub = function(n4) {
      if (n4.negative !== 0) {
        n4.negative = 0;
        var a4 = this.iadd(n4);
        return n4.negative = 1, a4._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(n4), this.negative = 1, this._normSign();
      var u5 = this.cmp(n4);
      if (u5 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var c4, d4;
      u5 > 0 ? (c4 = this, d4 = n4) : (c4 = n4, d4 = this);
      for (var C4 = 0, _5 = 0; _5 < d4.length; _5++)
        a4 = (c4.words[_5] | 0) - (d4.words[_5] | 0) + C4, C4 = a4 >> 26, this.words[_5] = a4 & 67108863;
      for (; C4 !== 0 && _5 < c4.length; _5++)
        a4 = (c4.words[_5] | 0) + C4, C4 = a4 >> 26, this.words[_5] = a4 & 67108863;
      if (C4 === 0 && _5 < c4.length && c4 !== this)
        for (; _5 < c4.length; _5++)
          this.words[_5] = c4.words[_5];
      return this.length = Math.max(this.length, _5), c4 !== this && (this.negative = 1), this.strip();
    }, i4.prototype.sub = function(n4) {
      return this.clone().isub(n4);
    };
    function D4(g4, n4, a4) {
      a4.negative = n4.negative ^ g4.negative;
      var u5 = g4.length + n4.length | 0;
      a4.length = u5, u5 = u5 - 1 | 0;
      var c4 = g4.words[0] | 0, d4 = n4.words[0] | 0, C4 = c4 * d4, _5 = C4 & 67108863, l5 = C4 / 67108864 | 0;
      a4.words[0] = _5;
      for (var s4 = 1; s4 < u5; s4++) {
        for (var h5 = l5 >>> 26, k5 = l5 & 67108863, I4 = Math.min(s4, n4.length - 1), A5 = Math.max(0, s4 - g4.length + 1); A5 <= I4; A5++) {
          var B3 = s4 - A5 | 0;
          c4 = g4.words[B3] | 0, d4 = n4.words[A5] | 0, C4 = c4 * d4 + k5, h5 += C4 / 67108864 | 0, k5 = C4 & 67108863;
        }
        a4.words[s4] = k5 | 0, l5 = h5 | 0;
      }
      return l5 !== 0 ? a4.words[s4] = l5 | 0 : a4.length--, a4.strip();
    }
    var P4 = function(n4, a4, u5) {
      var c4 = n4.words, d4 = a4.words, C4 = u5.words, _5 = 0, l5, s4, h5, k5 = c4[0] | 0, I4 = k5 & 8191, A5 = k5 >>> 13, B3 = c4[1] | 0, H4 = B3 & 8191, N4 = B3 >>> 13, te = c4[2] | 0, W3 = te & 8191, q5 = te >>> 13, ri = c4[3] | 0, $4 = ri & 8191, j4 = ri >>> 13, ni = c4[4] | 0, Y3 = ni & 8191, J3 = ni >>> 13, ii = c4[5] | 0, z4 = ii & 8191, Q3 = ii >>> 13, oi = c4[6] | 0, K3 = oi & 8191, X3 = oi >>> 13, si = c4[7] | 0, tt = si & 8191, et = si >>> 13, ai = c4[8] | 0, rt = ai & 8191, nt = ai >>> 13, fi = c4[9] | 0, it = fi & 8191, ot = fi >>> 13, ui = d4[0] | 0, st = ui & 8191, at = ui >>> 13, ci = d4[1] | 0, ft = ci & 8191, ut = ci >>> 13, li = d4[2] | 0, ct = li & 8191, lt = li >>> 13, hi = d4[3] | 0, ht = hi & 8191, dt = hi >>> 13, di = d4[4] | 0, pt = di & 8191, mt = di >>> 13, pi = d4[5] | 0, gt = pi & 8191, vt = pi >>> 13, mi = d4[6] | 0, yt = mi & 8191, wt = mi >>> 13, gi = d4[7] | 0, xt = gi & 8191, Ct = gi >>> 13, vi = d4[8] | 0, _t = vi & 8191, Mt = vi >>> 13, yi = d4[9] | 0, St = yi & 8191, bt = yi >>> 13;
      u5.negative = n4.negative ^ a4.negative, u5.length = 19, l5 = Math.imul(I4, st), s4 = Math.imul(I4, at), s4 = s4 + Math.imul(A5, st) | 0, h5 = Math.imul(A5, at);
      var Er = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, l5 = Math.imul(H4, st), s4 = Math.imul(H4, at), s4 = s4 + Math.imul(N4, st) | 0, h5 = Math.imul(N4, at), l5 = l5 + Math.imul(I4, ft) | 0, s4 = s4 + Math.imul(I4, ut) | 0, s4 = s4 + Math.imul(A5, ft) | 0, h5 = h5 + Math.imul(A5, ut) | 0;
      var kr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, l5 = Math.imul(W3, st), s4 = Math.imul(W3, at), s4 = s4 + Math.imul(q5, st) | 0, h5 = Math.imul(q5, at), l5 = l5 + Math.imul(H4, ft) | 0, s4 = s4 + Math.imul(H4, ut) | 0, s4 = s4 + Math.imul(N4, ft) | 0, h5 = h5 + Math.imul(N4, ut) | 0, l5 = l5 + Math.imul(I4, ct) | 0, s4 = s4 + Math.imul(I4, lt) | 0, s4 = s4 + Math.imul(A5, ct) | 0, h5 = h5 + Math.imul(A5, lt) | 0;
      var Tr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, l5 = Math.imul($4, st), s4 = Math.imul($4, at), s4 = s4 + Math.imul(j4, st) | 0, h5 = Math.imul(j4, at), l5 = l5 + Math.imul(W3, ft) | 0, s4 = s4 + Math.imul(W3, ut) | 0, s4 = s4 + Math.imul(q5, ft) | 0, h5 = h5 + Math.imul(q5, ut) | 0, l5 = l5 + Math.imul(H4, ct) | 0, s4 = s4 + Math.imul(H4, lt) | 0, s4 = s4 + Math.imul(N4, ct) | 0, h5 = h5 + Math.imul(N4, lt) | 0, l5 = l5 + Math.imul(I4, ht) | 0, s4 = s4 + Math.imul(I4, dt) | 0, s4 = s4 + Math.imul(A5, ht) | 0, h5 = h5 + Math.imul(A5, dt) | 0;
      var Ir = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, l5 = Math.imul(Y3, st), s4 = Math.imul(Y3, at), s4 = s4 + Math.imul(J3, st) | 0, h5 = Math.imul(J3, at), l5 = l5 + Math.imul($4, ft) | 0, s4 = s4 + Math.imul($4, ut) | 0, s4 = s4 + Math.imul(j4, ft) | 0, h5 = h5 + Math.imul(j4, ut) | 0, l5 = l5 + Math.imul(W3, ct) | 0, s4 = s4 + Math.imul(W3, lt) | 0, s4 = s4 + Math.imul(q5, ct) | 0, h5 = h5 + Math.imul(q5, lt) | 0, l5 = l5 + Math.imul(H4, ht) | 0, s4 = s4 + Math.imul(H4, dt) | 0, s4 = s4 + Math.imul(N4, ht) | 0, h5 = h5 + Math.imul(N4, dt) | 0, l5 = l5 + Math.imul(I4, pt) | 0, s4 = s4 + Math.imul(I4, mt) | 0, s4 = s4 + Math.imul(A5, pt) | 0, h5 = h5 + Math.imul(A5, mt) | 0;
      var Ar = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Ar >>> 26) | 0, Ar &= 67108863, l5 = Math.imul(z4, st), s4 = Math.imul(z4, at), s4 = s4 + Math.imul(Q3, st) | 0, h5 = Math.imul(Q3, at), l5 = l5 + Math.imul(Y3, ft) | 0, s4 = s4 + Math.imul(Y3, ut) | 0, s4 = s4 + Math.imul(J3, ft) | 0, h5 = h5 + Math.imul(J3, ut) | 0, l5 = l5 + Math.imul($4, ct) | 0, s4 = s4 + Math.imul($4, lt) | 0, s4 = s4 + Math.imul(j4, ct) | 0, h5 = h5 + Math.imul(j4, lt) | 0, l5 = l5 + Math.imul(W3, ht) | 0, s4 = s4 + Math.imul(W3, dt) | 0, s4 = s4 + Math.imul(q5, ht) | 0, h5 = h5 + Math.imul(q5, dt) | 0, l5 = l5 + Math.imul(H4, pt) | 0, s4 = s4 + Math.imul(H4, mt) | 0, s4 = s4 + Math.imul(N4, pt) | 0, h5 = h5 + Math.imul(N4, mt) | 0, l5 = l5 + Math.imul(I4, gt) | 0, s4 = s4 + Math.imul(I4, vt) | 0, s4 = s4 + Math.imul(A5, gt) | 0, h5 = h5 + Math.imul(A5, vt) | 0;
      var Lr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, l5 = Math.imul(K3, st), s4 = Math.imul(K3, at), s4 = s4 + Math.imul(X3, st) | 0, h5 = Math.imul(X3, at), l5 = l5 + Math.imul(z4, ft) | 0, s4 = s4 + Math.imul(z4, ut) | 0, s4 = s4 + Math.imul(Q3, ft) | 0, h5 = h5 + Math.imul(Q3, ut) | 0, l5 = l5 + Math.imul(Y3, ct) | 0, s4 = s4 + Math.imul(Y3, lt) | 0, s4 = s4 + Math.imul(J3, ct) | 0, h5 = h5 + Math.imul(J3, lt) | 0, l5 = l5 + Math.imul($4, ht) | 0, s4 = s4 + Math.imul($4, dt) | 0, s4 = s4 + Math.imul(j4, ht) | 0, h5 = h5 + Math.imul(j4, dt) | 0, l5 = l5 + Math.imul(W3, pt) | 0, s4 = s4 + Math.imul(W3, mt) | 0, s4 = s4 + Math.imul(q5, pt) | 0, h5 = h5 + Math.imul(q5, mt) | 0, l5 = l5 + Math.imul(H4, gt) | 0, s4 = s4 + Math.imul(H4, vt) | 0, s4 = s4 + Math.imul(N4, gt) | 0, h5 = h5 + Math.imul(N4, vt) | 0, l5 = l5 + Math.imul(I4, yt) | 0, s4 = s4 + Math.imul(I4, wt) | 0, s4 = s4 + Math.imul(A5, yt) | 0, h5 = h5 + Math.imul(A5, wt) | 0;
      var Rr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, l5 = Math.imul(tt, st), s4 = Math.imul(tt, at), s4 = s4 + Math.imul(et, st) | 0, h5 = Math.imul(et, at), l5 = l5 + Math.imul(K3, ft) | 0, s4 = s4 + Math.imul(K3, ut) | 0, s4 = s4 + Math.imul(X3, ft) | 0, h5 = h5 + Math.imul(X3, ut) | 0, l5 = l5 + Math.imul(z4, ct) | 0, s4 = s4 + Math.imul(z4, lt) | 0, s4 = s4 + Math.imul(Q3, ct) | 0, h5 = h5 + Math.imul(Q3, lt) | 0, l5 = l5 + Math.imul(Y3, ht) | 0, s4 = s4 + Math.imul(Y3, dt) | 0, s4 = s4 + Math.imul(J3, ht) | 0, h5 = h5 + Math.imul(J3, dt) | 0, l5 = l5 + Math.imul($4, pt) | 0, s4 = s4 + Math.imul($4, mt) | 0, s4 = s4 + Math.imul(j4, pt) | 0, h5 = h5 + Math.imul(j4, mt) | 0, l5 = l5 + Math.imul(W3, gt) | 0, s4 = s4 + Math.imul(W3, vt) | 0, s4 = s4 + Math.imul(q5, gt) | 0, h5 = h5 + Math.imul(q5, vt) | 0, l5 = l5 + Math.imul(H4, yt) | 0, s4 = s4 + Math.imul(H4, wt) | 0, s4 = s4 + Math.imul(N4, yt) | 0, h5 = h5 + Math.imul(N4, wt) | 0, l5 = l5 + Math.imul(I4, xt) | 0, s4 = s4 + Math.imul(I4, Ct) | 0, s4 = s4 + Math.imul(A5, xt) | 0, h5 = h5 + Math.imul(A5, Ct) | 0;
      var Or = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, l5 = Math.imul(rt, st), s4 = Math.imul(rt, at), s4 = s4 + Math.imul(nt, st) | 0, h5 = Math.imul(nt, at), l5 = l5 + Math.imul(tt, ft) | 0, s4 = s4 + Math.imul(tt, ut) | 0, s4 = s4 + Math.imul(et, ft) | 0, h5 = h5 + Math.imul(et, ut) | 0, l5 = l5 + Math.imul(K3, ct) | 0, s4 = s4 + Math.imul(K3, lt) | 0, s4 = s4 + Math.imul(X3, ct) | 0, h5 = h5 + Math.imul(X3, lt) | 0, l5 = l5 + Math.imul(z4, ht) | 0, s4 = s4 + Math.imul(z4, dt) | 0, s4 = s4 + Math.imul(Q3, ht) | 0, h5 = h5 + Math.imul(Q3, dt) | 0, l5 = l5 + Math.imul(Y3, pt) | 0, s4 = s4 + Math.imul(Y3, mt) | 0, s4 = s4 + Math.imul(J3, pt) | 0, h5 = h5 + Math.imul(J3, mt) | 0, l5 = l5 + Math.imul($4, gt) | 0, s4 = s4 + Math.imul($4, vt) | 0, s4 = s4 + Math.imul(j4, gt) | 0, h5 = h5 + Math.imul(j4, vt) | 0, l5 = l5 + Math.imul(W3, yt) | 0, s4 = s4 + Math.imul(W3, wt) | 0, s4 = s4 + Math.imul(q5, yt) | 0, h5 = h5 + Math.imul(q5, wt) | 0, l5 = l5 + Math.imul(H4, xt) | 0, s4 = s4 + Math.imul(H4, Ct) | 0, s4 = s4 + Math.imul(N4, xt) | 0, h5 = h5 + Math.imul(N4, Ct) | 0, l5 = l5 + Math.imul(I4, _t) | 0, s4 = s4 + Math.imul(I4, Mt) | 0, s4 = s4 + Math.imul(A5, _t) | 0, h5 = h5 + Math.imul(A5, Mt) | 0;
      var Br = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, l5 = Math.imul(it, st), s4 = Math.imul(it, at), s4 = s4 + Math.imul(ot, st) | 0, h5 = Math.imul(ot, at), l5 = l5 + Math.imul(rt, ft) | 0, s4 = s4 + Math.imul(rt, ut) | 0, s4 = s4 + Math.imul(nt, ft) | 0, h5 = h5 + Math.imul(nt, ut) | 0, l5 = l5 + Math.imul(tt, ct) | 0, s4 = s4 + Math.imul(tt, lt) | 0, s4 = s4 + Math.imul(et, ct) | 0, h5 = h5 + Math.imul(et, lt) | 0, l5 = l5 + Math.imul(K3, ht) | 0, s4 = s4 + Math.imul(K3, dt) | 0, s4 = s4 + Math.imul(X3, ht) | 0, h5 = h5 + Math.imul(X3, dt) | 0, l5 = l5 + Math.imul(z4, pt) | 0, s4 = s4 + Math.imul(z4, mt) | 0, s4 = s4 + Math.imul(Q3, pt) | 0, h5 = h5 + Math.imul(Q3, mt) | 0, l5 = l5 + Math.imul(Y3, gt) | 0, s4 = s4 + Math.imul(Y3, vt) | 0, s4 = s4 + Math.imul(J3, gt) | 0, h5 = h5 + Math.imul(J3, vt) | 0, l5 = l5 + Math.imul($4, yt) | 0, s4 = s4 + Math.imul($4, wt) | 0, s4 = s4 + Math.imul(j4, yt) | 0, h5 = h5 + Math.imul(j4, wt) | 0, l5 = l5 + Math.imul(W3, xt) | 0, s4 = s4 + Math.imul(W3, Ct) | 0, s4 = s4 + Math.imul(q5, xt) | 0, h5 = h5 + Math.imul(q5, Ct) | 0, l5 = l5 + Math.imul(H4, _t) | 0, s4 = s4 + Math.imul(H4, Mt) | 0, s4 = s4 + Math.imul(N4, _t) | 0, h5 = h5 + Math.imul(N4, Mt) | 0, l5 = l5 + Math.imul(I4, St) | 0, s4 = s4 + Math.imul(I4, bt) | 0, s4 = s4 + Math.imul(A5, St) | 0, h5 = h5 + Math.imul(A5, bt) | 0;
      var Dr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, l5 = Math.imul(it, ft), s4 = Math.imul(it, ut), s4 = s4 + Math.imul(ot, ft) | 0, h5 = Math.imul(ot, ut), l5 = l5 + Math.imul(rt, ct) | 0, s4 = s4 + Math.imul(rt, lt) | 0, s4 = s4 + Math.imul(nt, ct) | 0, h5 = h5 + Math.imul(nt, lt) | 0, l5 = l5 + Math.imul(tt, ht) | 0, s4 = s4 + Math.imul(tt, dt) | 0, s4 = s4 + Math.imul(et, ht) | 0, h5 = h5 + Math.imul(et, dt) | 0, l5 = l5 + Math.imul(K3, pt) | 0, s4 = s4 + Math.imul(K3, mt) | 0, s4 = s4 + Math.imul(X3, pt) | 0, h5 = h5 + Math.imul(X3, mt) | 0, l5 = l5 + Math.imul(z4, gt) | 0, s4 = s4 + Math.imul(z4, vt) | 0, s4 = s4 + Math.imul(Q3, gt) | 0, h5 = h5 + Math.imul(Q3, vt) | 0, l5 = l5 + Math.imul(Y3, yt) | 0, s4 = s4 + Math.imul(Y3, wt) | 0, s4 = s4 + Math.imul(J3, yt) | 0, h5 = h5 + Math.imul(J3, wt) | 0, l5 = l5 + Math.imul($4, xt) | 0, s4 = s4 + Math.imul($4, Ct) | 0, s4 = s4 + Math.imul(j4, xt) | 0, h5 = h5 + Math.imul(j4, Ct) | 0, l5 = l5 + Math.imul(W3, _t) | 0, s4 = s4 + Math.imul(W3, Mt) | 0, s4 = s4 + Math.imul(q5, _t) | 0, h5 = h5 + Math.imul(q5, Mt) | 0, l5 = l5 + Math.imul(H4, St) | 0, s4 = s4 + Math.imul(H4, bt) | 0, s4 = s4 + Math.imul(N4, St) | 0, h5 = h5 + Math.imul(N4, bt) | 0;
      var Pr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Pr >>> 26) | 0, Pr &= 67108863, l5 = Math.imul(it, ct), s4 = Math.imul(it, lt), s4 = s4 + Math.imul(ot, ct) | 0, h5 = Math.imul(ot, lt), l5 = l5 + Math.imul(rt, ht) | 0, s4 = s4 + Math.imul(rt, dt) | 0, s4 = s4 + Math.imul(nt, ht) | 0, h5 = h5 + Math.imul(nt, dt) | 0, l5 = l5 + Math.imul(tt, pt) | 0, s4 = s4 + Math.imul(tt, mt) | 0, s4 = s4 + Math.imul(et, pt) | 0, h5 = h5 + Math.imul(et, mt) | 0, l5 = l5 + Math.imul(K3, gt) | 0, s4 = s4 + Math.imul(K3, vt) | 0, s4 = s4 + Math.imul(X3, gt) | 0, h5 = h5 + Math.imul(X3, vt) | 0, l5 = l5 + Math.imul(z4, yt) | 0, s4 = s4 + Math.imul(z4, wt) | 0, s4 = s4 + Math.imul(Q3, yt) | 0, h5 = h5 + Math.imul(Q3, wt) | 0, l5 = l5 + Math.imul(Y3, xt) | 0, s4 = s4 + Math.imul(Y3, Ct) | 0, s4 = s4 + Math.imul(J3, xt) | 0, h5 = h5 + Math.imul(J3, Ct) | 0, l5 = l5 + Math.imul($4, _t) | 0, s4 = s4 + Math.imul($4, Mt) | 0, s4 = s4 + Math.imul(j4, _t) | 0, h5 = h5 + Math.imul(j4, Mt) | 0, l5 = l5 + Math.imul(W3, St) | 0, s4 = s4 + Math.imul(W3, bt) | 0, s4 = s4 + Math.imul(q5, St) | 0, h5 = h5 + Math.imul(q5, bt) | 0;
      var Ur = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, l5 = Math.imul(it, ht), s4 = Math.imul(it, dt), s4 = s4 + Math.imul(ot, ht) | 0, h5 = Math.imul(ot, dt), l5 = l5 + Math.imul(rt, pt) | 0, s4 = s4 + Math.imul(rt, mt) | 0, s4 = s4 + Math.imul(nt, pt) | 0, h5 = h5 + Math.imul(nt, mt) | 0, l5 = l5 + Math.imul(tt, gt) | 0, s4 = s4 + Math.imul(tt, vt) | 0, s4 = s4 + Math.imul(et, gt) | 0, h5 = h5 + Math.imul(et, vt) | 0, l5 = l5 + Math.imul(K3, yt) | 0, s4 = s4 + Math.imul(K3, wt) | 0, s4 = s4 + Math.imul(X3, yt) | 0, h5 = h5 + Math.imul(X3, wt) | 0, l5 = l5 + Math.imul(z4, xt) | 0, s4 = s4 + Math.imul(z4, Ct) | 0, s4 = s4 + Math.imul(Q3, xt) | 0, h5 = h5 + Math.imul(Q3, Ct) | 0, l5 = l5 + Math.imul(Y3, _t) | 0, s4 = s4 + Math.imul(Y3, Mt) | 0, s4 = s4 + Math.imul(J3, _t) | 0, h5 = h5 + Math.imul(J3, Mt) | 0, l5 = l5 + Math.imul($4, St) | 0, s4 = s4 + Math.imul($4, bt) | 0, s4 = s4 + Math.imul(j4, St) | 0, h5 = h5 + Math.imul(j4, bt) | 0;
      var Hr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, l5 = Math.imul(it, pt), s4 = Math.imul(it, mt), s4 = s4 + Math.imul(ot, pt) | 0, h5 = Math.imul(ot, mt), l5 = l5 + Math.imul(rt, gt) | 0, s4 = s4 + Math.imul(rt, vt) | 0, s4 = s4 + Math.imul(nt, gt) | 0, h5 = h5 + Math.imul(nt, vt) | 0, l5 = l5 + Math.imul(tt, yt) | 0, s4 = s4 + Math.imul(tt, wt) | 0, s4 = s4 + Math.imul(et, yt) | 0, h5 = h5 + Math.imul(et, wt) | 0, l5 = l5 + Math.imul(K3, xt) | 0, s4 = s4 + Math.imul(K3, Ct) | 0, s4 = s4 + Math.imul(X3, xt) | 0, h5 = h5 + Math.imul(X3, Ct) | 0, l5 = l5 + Math.imul(z4, _t) | 0, s4 = s4 + Math.imul(z4, Mt) | 0, s4 = s4 + Math.imul(Q3, _t) | 0, h5 = h5 + Math.imul(Q3, Mt) | 0, l5 = l5 + Math.imul(Y3, St) | 0, s4 = s4 + Math.imul(Y3, bt) | 0, s4 = s4 + Math.imul(J3, St) | 0, h5 = h5 + Math.imul(J3, bt) | 0;
      var Nr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, l5 = Math.imul(it, gt), s4 = Math.imul(it, vt), s4 = s4 + Math.imul(ot, gt) | 0, h5 = Math.imul(ot, vt), l5 = l5 + Math.imul(rt, yt) | 0, s4 = s4 + Math.imul(rt, wt) | 0, s4 = s4 + Math.imul(nt, yt) | 0, h5 = h5 + Math.imul(nt, wt) | 0, l5 = l5 + Math.imul(tt, xt) | 0, s4 = s4 + Math.imul(tt, Ct) | 0, s4 = s4 + Math.imul(et, xt) | 0, h5 = h5 + Math.imul(et, Ct) | 0, l5 = l5 + Math.imul(K3, _t) | 0, s4 = s4 + Math.imul(K3, Mt) | 0, s4 = s4 + Math.imul(X3, _t) | 0, h5 = h5 + Math.imul(X3, Mt) | 0, l5 = l5 + Math.imul(z4, St) | 0, s4 = s4 + Math.imul(z4, bt) | 0, s4 = s4 + Math.imul(Q3, St) | 0, h5 = h5 + Math.imul(Q3, bt) | 0;
      var Wr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, l5 = Math.imul(it, yt), s4 = Math.imul(it, wt), s4 = s4 + Math.imul(ot, yt) | 0, h5 = Math.imul(ot, wt), l5 = l5 + Math.imul(rt, xt) | 0, s4 = s4 + Math.imul(rt, Ct) | 0, s4 = s4 + Math.imul(nt, xt) | 0, h5 = h5 + Math.imul(nt, Ct) | 0, l5 = l5 + Math.imul(tt, _t) | 0, s4 = s4 + Math.imul(tt, Mt) | 0, s4 = s4 + Math.imul(et, _t) | 0, h5 = h5 + Math.imul(et, Mt) | 0, l5 = l5 + Math.imul(K3, St) | 0, s4 = s4 + Math.imul(K3, bt) | 0, s4 = s4 + Math.imul(X3, St) | 0, h5 = h5 + Math.imul(X3, bt) | 0;
      var Fr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, l5 = Math.imul(it, xt), s4 = Math.imul(it, Ct), s4 = s4 + Math.imul(ot, xt) | 0, h5 = Math.imul(ot, Ct), l5 = l5 + Math.imul(rt, _t) | 0, s4 = s4 + Math.imul(rt, Mt) | 0, s4 = s4 + Math.imul(nt, _t) | 0, h5 = h5 + Math.imul(nt, Mt) | 0, l5 = l5 + Math.imul(tt, St) | 0, s4 = s4 + Math.imul(tt, bt) | 0, s4 = s4 + Math.imul(et, St) | 0, h5 = h5 + Math.imul(et, bt) | 0;
      var qr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, l5 = Math.imul(it, _t), s4 = Math.imul(it, Mt), s4 = s4 + Math.imul(ot, _t) | 0, h5 = Math.imul(ot, Mt), l5 = l5 + Math.imul(rt, St) | 0, s4 = s4 + Math.imul(rt, bt) | 0, s4 = s4 + Math.imul(nt, St) | 0, h5 = h5 + Math.imul(nt, bt) | 0;
      var Vr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      _5 = (h5 + (s4 >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, l5 = Math.imul(it, St), s4 = Math.imul(it, bt), s4 = s4 + Math.imul(ot, St) | 0, h5 = Math.imul(ot, bt);
      var Zr = (_5 + l5 | 0) + ((s4 & 8191) << 13) | 0;
      return _5 = (h5 + (s4 >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, C4[0] = Er, C4[1] = kr, C4[2] = Tr, C4[3] = Ir, C4[4] = Ar, C4[5] = Lr, C4[6] = Rr, C4[7] = Or, C4[8] = Br, C4[9] = Dr, C4[10] = Pr, C4[11] = Ur, C4[12] = Hr, C4[13] = Nr, C4[14] = Wr, C4[15] = Fr, C4[16] = qr, C4[17] = Vr, C4[18] = Zr, _5 !== 0 && (C4[19] = _5, u5.length++), u5;
    };
    Math.imul || (P4 = D4);
    function kt(g4, n4, a4) {
      a4.negative = n4.negative ^ g4.negative, a4.length = g4.length + n4.length;
      for (var u5 = 0, c4 = 0, d4 = 0; d4 < a4.length - 1; d4++) {
        var C4 = c4;
        c4 = 0;
        for (var _5 = u5 & 67108863, l5 = Math.min(d4, n4.length - 1), s4 = Math.max(0, d4 - g4.length + 1); s4 <= l5; s4++) {
          var h5 = d4 - s4, k5 = g4.words[h5] | 0, I4 = n4.words[s4] | 0, A5 = k5 * I4, B3 = A5 & 67108863;
          C4 = C4 + (A5 / 67108864 | 0) | 0, B3 = B3 + _5 | 0, _5 = B3 & 67108863, C4 = C4 + (B3 >>> 26) | 0, c4 += C4 >>> 26, C4 &= 67108863;
        }
        a4.words[d4] = _5, u5 = C4, C4 = c4;
      }
      return u5 !== 0 ? a4.words[d4] = u5 : a4.length--, a4.strip();
    }
    function Nt(g4, n4, a4) {
      var u5 = new U3();
      return u5.mulp(g4, n4, a4);
    }
    i4.prototype.mulTo = function(n4, a4) {
      var u5, c4 = this.length + n4.length;
      return this.length === 10 && n4.length === 10 ? u5 = P4(this, n4, a4) : c4 < 63 ? u5 = D4(this, n4, a4) : c4 < 1024 ? u5 = kt(this, n4, a4) : u5 = Nt(this, n4, a4), u5;
    };
    function U3(g4, n4) {
      this.x = g4, this.y = n4;
    }
    U3.prototype.makeRBT = function(n4) {
      for (var a4 = new Array(n4), u5 = i4.prototype._countBits(n4) - 1, c4 = 0; c4 < n4; c4++)
        a4[c4] = this.revBin(c4, u5, n4);
      return a4;
    }, U3.prototype.revBin = function(n4, a4, u5) {
      if (n4 === 0 || n4 === u5 - 1)
        return n4;
      for (var c4 = 0, d4 = 0; d4 < a4; d4++)
        c4 |= (n4 & 1) << a4 - d4 - 1, n4 >>= 1;
      return c4;
    }, U3.prototype.permute = function(n4, a4, u5, c4, d4, C4) {
      for (var _5 = 0; _5 < C4; _5++)
        c4[_5] = a4[n4[_5]], d4[_5] = u5[n4[_5]];
    }, U3.prototype.transform = function(n4, a4, u5, c4, d4, C4) {
      this.permute(C4, n4, a4, u5, c4, d4);
      for (var _5 = 1; _5 < d4; _5 <<= 1)
        for (var l5 = _5 << 1, s4 = Math.cos(2 * Math.PI / l5), h5 = Math.sin(2 * Math.PI / l5), k5 = 0; k5 < d4; k5 += l5)
          for (var I4 = s4, A5 = h5, B3 = 0; B3 < _5; B3++) {
            var H4 = u5[k5 + B3], N4 = c4[k5 + B3], te = u5[k5 + B3 + _5], W3 = c4[k5 + B3 + _5], q5 = I4 * te - A5 * W3;
            W3 = I4 * W3 + A5 * te, te = q5, u5[k5 + B3] = H4 + te, c4[k5 + B3] = N4 + W3, u5[k5 + B3 + _5] = H4 - te, c4[k5 + B3 + _5] = N4 - W3, B3 !== l5 && (q5 = s4 * I4 - h5 * A5, A5 = s4 * A5 + h5 * I4, I4 = q5);
          }
    }, U3.prototype.guessLen13b = function(n4, a4) {
      var u5 = Math.max(a4, n4) | 1, c4 = u5 & 1, d4 = 0;
      for (u5 = u5 / 2 | 0; u5; u5 = u5 >>> 1)
        d4++;
      return 1 << d4 + 1 + c4;
    }, U3.prototype.conjugate = function(n4, a4, u5) {
      if (!(u5 <= 1))
        for (var c4 = 0; c4 < u5 / 2; c4++) {
          var d4 = n4[c4];
          n4[c4] = n4[u5 - c4 - 1], n4[u5 - c4 - 1] = d4, d4 = a4[c4], a4[c4] = -a4[u5 - c4 - 1], a4[u5 - c4 - 1] = -d4;
        }
    }, U3.prototype.normalize13b = function(n4, a4) {
      for (var u5 = 0, c4 = 0; c4 < a4 / 2; c4++) {
        var d4 = Math.round(n4[2 * c4 + 1] / a4) * 8192 + Math.round(n4[2 * c4] / a4) + u5;
        n4[c4] = d4 & 67108863, d4 < 67108864 ? u5 = 0 : u5 = d4 / 67108864 | 0;
      }
      return n4;
    }, U3.prototype.convert13b = function(n4, a4, u5, c4) {
      for (var d4 = 0, C4 = 0; C4 < a4; C4++)
        d4 = d4 + (n4[C4] | 0), u5[2 * C4] = d4 & 8191, d4 = d4 >>> 13, u5[2 * C4 + 1] = d4 & 8191, d4 = d4 >>> 13;
      for (C4 = 2 * a4; C4 < c4; ++C4)
        u5[C4] = 0;
      r5(d4 === 0), r5((d4 & -8192) === 0);
    }, U3.prototype.stub = function(n4) {
      for (var a4 = new Array(n4), u5 = 0; u5 < n4; u5++)
        a4[u5] = 0;
      return a4;
    }, U3.prototype.mulp = function(n4, a4, u5) {
      var c4 = 2 * this.guessLen13b(n4.length, a4.length), d4 = this.makeRBT(c4), C4 = this.stub(c4), _5 = new Array(c4), l5 = new Array(c4), s4 = new Array(c4), h5 = new Array(c4), k5 = new Array(c4), I4 = new Array(c4), A5 = u5.words;
      A5.length = c4, this.convert13b(n4.words, n4.length, _5, c4), this.convert13b(a4.words, a4.length, h5, c4), this.transform(_5, C4, l5, s4, c4, d4), this.transform(h5, C4, k5, I4, c4, d4);
      for (var B3 = 0; B3 < c4; B3++) {
        var H4 = l5[B3] * k5[B3] - s4[B3] * I4[B3];
        s4[B3] = l5[B3] * I4[B3] + s4[B3] * k5[B3], l5[B3] = H4;
      }
      return this.conjugate(l5, s4, c4), this.transform(l5, s4, A5, C4, c4, d4), this.conjugate(A5, C4, c4), this.normalize13b(A5, c4), u5.negative = n4.negative ^ a4.negative, u5.length = n4.length + a4.length, u5.strip();
    }, i4.prototype.mul = function(n4) {
      var a4 = new i4(null);
      return a4.words = new Array(this.length + n4.length), this.mulTo(n4, a4);
    }, i4.prototype.mulf = function(n4) {
      var a4 = new i4(null);
      return a4.words = new Array(this.length + n4.length), Nt(this, n4, a4);
    }, i4.prototype.imul = function(n4) {
      return this.clone().mulTo(n4, this);
    }, i4.prototype.imuln = function(n4) {
      r5(typeof n4 == "number"), r5(n4 < 67108864);
      for (var a4 = 0, u5 = 0; u5 < this.length; u5++) {
        var c4 = (this.words[u5] | 0) * n4, d4 = (c4 & 67108863) + (a4 & 67108863);
        a4 >>= 26, a4 += c4 / 67108864 | 0, a4 += d4 >>> 26, this.words[u5] = d4 & 67108863;
      }
      return a4 !== 0 && (this.words[u5] = a4, this.length++), this;
    }, i4.prototype.muln = function(n4) {
      return this.clone().imuln(n4);
    }, i4.prototype.sqr = function() {
      return this.mul(this);
    }, i4.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i4.prototype.pow = function(n4) {
      var a4 = T5(n4);
      if (a4.length === 0)
        return new i4(1);
      for (var u5 = this, c4 = 0; c4 < a4.length && a4[c4] === 0; c4++, u5 = u5.sqr())
        ;
      if (++c4 < a4.length)
        for (var d4 = u5.sqr(); c4 < a4.length; c4++, d4 = d4.sqr())
          a4[c4] !== 0 && (u5 = u5.mul(d4));
      return u5;
    }, i4.prototype.iushln = function(n4) {
      r5(typeof n4 == "number" && n4 >= 0);
      var a4 = n4 % 26, u5 = (n4 - a4) / 26, c4 = 67108863 >>> 26 - a4 << 26 - a4, d4;
      if (a4 !== 0) {
        var C4 = 0;
        for (d4 = 0; d4 < this.length; d4++) {
          var _5 = this.words[d4] & c4, l5 = (this.words[d4] | 0) - _5 << a4;
          this.words[d4] = l5 | C4, C4 = _5 >>> 26 - a4;
        }
        C4 && (this.words[d4] = C4, this.length++);
      }
      if (u5 !== 0) {
        for (d4 = this.length - 1; d4 >= 0; d4--)
          this.words[d4 + u5] = this.words[d4];
        for (d4 = 0; d4 < u5; d4++)
          this.words[d4] = 0;
        this.length += u5;
      }
      return this.strip();
    }, i4.prototype.ishln = function(n4) {
      return r5(this.negative === 0), this.iushln(n4);
    }, i4.prototype.iushrn = function(n4, a4, u5) {
      r5(typeof n4 == "number" && n4 >= 0);
      var c4;
      a4 ? c4 = (a4 - a4 % 26) / 26 : c4 = 0;
      var d4 = n4 % 26, C4 = Math.min((n4 - d4) / 26, this.length), _5 = 67108863 ^ 67108863 >>> d4 << d4, l5 = u5;
      if (c4 -= C4, c4 = Math.max(0, c4), l5) {
        for (var s4 = 0; s4 < C4; s4++)
          l5.words[s4] = this.words[s4];
        l5.length = C4;
      }
      if (C4 !== 0)
        if (this.length > C4)
          for (this.length -= C4, s4 = 0; s4 < this.length; s4++)
            this.words[s4] = this.words[s4 + C4];
        else
          this.words[0] = 0, this.length = 1;
      var h5 = 0;
      for (s4 = this.length - 1; s4 >= 0 && (h5 !== 0 || s4 >= c4); s4--) {
        var k5 = this.words[s4] | 0;
        this.words[s4] = h5 << 26 - d4 | k5 >>> d4, h5 = k5 & _5;
      }
      return l5 && h5 !== 0 && (l5.words[l5.length++] = h5), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i4.prototype.ishrn = function(n4, a4, u5) {
      return r5(this.negative === 0), this.iushrn(n4, a4, u5);
    }, i4.prototype.shln = function(n4) {
      return this.clone().ishln(n4);
    }, i4.prototype.ushln = function(n4) {
      return this.clone().iushln(n4);
    }, i4.prototype.shrn = function(n4) {
      return this.clone().ishrn(n4);
    }, i4.prototype.ushrn = function(n4) {
      return this.clone().iushrn(n4);
    }, i4.prototype.testn = function(n4) {
      r5(typeof n4 == "number" && n4 >= 0);
      var a4 = n4 % 26, u5 = (n4 - a4) / 26, c4 = 1 << a4;
      if (this.length <= u5)
        return false;
      var d4 = this.words[u5];
      return !!(d4 & c4);
    }, i4.prototype.imaskn = function(n4) {
      r5(typeof n4 == "number" && n4 >= 0);
      var a4 = n4 % 26, u5 = (n4 - a4) / 26;
      if (r5(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u5)
        return this;
      if (a4 !== 0 && u5++, this.length = Math.min(u5, this.length), a4 !== 0) {
        var c4 = 67108863 ^ 67108863 >>> a4 << a4;
        this.words[this.length - 1] &= c4;
      }
      return this.strip();
    }, i4.prototype.maskn = function(n4) {
      return this.clone().imaskn(n4);
    }, i4.prototype.iaddn = function(n4) {
      return r5(typeof n4 == "number"), r5(n4 < 67108864), n4 < 0 ? this.isubn(-n4) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < n4 ? (this.words[0] = n4 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(n4), this.negative = 1, this) : this._iaddn(n4);
    }, i4.prototype._iaddn = function(n4) {
      this.words[0] += n4;
      for (var a4 = 0; a4 < this.length && this.words[a4] >= 67108864; a4++)
        this.words[a4] -= 67108864, a4 === this.length - 1 ? this.words[a4 + 1] = 1 : this.words[a4 + 1]++;
      return this.length = Math.max(this.length, a4 + 1), this;
    }, i4.prototype.isubn = function(n4) {
      if (r5(typeof n4 == "number"), r5(n4 < 67108864), n4 < 0)
        return this.iaddn(-n4);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(n4), this.negative = 1, this;
      if (this.words[0] -= n4, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a4 = 0; a4 < this.length && this.words[a4] < 0; a4++)
          this.words[a4] += 67108864, this.words[a4 + 1] -= 1;
      return this.strip();
    }, i4.prototype.addn = function(n4) {
      return this.clone().iaddn(n4);
    }, i4.prototype.subn = function(n4) {
      return this.clone().isubn(n4);
    }, i4.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i4.prototype.abs = function() {
      return this.clone().iabs();
    }, i4.prototype._ishlnsubmul = function(n4, a4, u5) {
      var c4 = n4.length + u5, d4;
      this._expand(c4);
      var C4, _5 = 0;
      for (d4 = 0; d4 < n4.length; d4++) {
        C4 = (this.words[d4 + u5] | 0) + _5;
        var l5 = (n4.words[d4] | 0) * a4;
        C4 -= l5 & 67108863, _5 = (C4 >> 26) - (l5 / 67108864 | 0), this.words[d4 + u5] = C4 & 67108863;
      }
      for (; d4 < this.length - u5; d4++)
        C4 = (this.words[d4 + u5] | 0) + _5, _5 = C4 >> 26, this.words[d4 + u5] = C4 & 67108863;
      if (_5 === 0)
        return this.strip();
      for (r5(_5 === -1), _5 = 0, d4 = 0; d4 < this.length; d4++)
        C4 = -(this.words[d4] | 0) + _5, _5 = C4 >> 26, this.words[d4] = C4 & 67108863;
      return this.negative = 1, this.strip();
    }, i4.prototype._wordDiv = function(n4, a4) {
      var u5 = this.length - n4.length, c4 = this.clone(), d4 = n4, C4 = d4.words[d4.length - 1] | 0, _5 = this._countBits(C4);
      u5 = 26 - _5, u5 !== 0 && (d4 = d4.ushln(u5), c4.iushln(u5), C4 = d4.words[d4.length - 1] | 0);
      var l5 = c4.length - d4.length, s4;
      if (a4 !== "mod") {
        s4 = new i4(null), s4.length = l5 + 1, s4.words = new Array(s4.length);
        for (var h5 = 0; h5 < s4.length; h5++)
          s4.words[h5] = 0;
      }
      var k5 = c4.clone()._ishlnsubmul(d4, 1, l5);
      k5.negative === 0 && (c4 = k5, s4 && (s4.words[l5] = 1));
      for (var I4 = l5 - 1; I4 >= 0; I4--) {
        var A5 = (c4.words[d4.length + I4] | 0) * 67108864 + (c4.words[d4.length + I4 - 1] | 0);
        for (A5 = Math.min(A5 / C4 | 0, 67108863), c4._ishlnsubmul(d4, A5, I4); c4.negative !== 0; )
          A5--, c4.negative = 0, c4._ishlnsubmul(d4, 1, I4), c4.isZero() || (c4.negative ^= 1);
        s4 && (s4.words[I4] = A5);
      }
      return s4 && s4.strip(), c4.strip(), a4 !== "div" && u5 !== 0 && c4.iushrn(u5), { div: s4 || null, mod: c4 };
    }, i4.prototype.divmod = function(n4, a4, u5) {
      if (r5(!n4.isZero()), this.isZero())
        return { div: new i4(0), mod: new i4(0) };
      var c4, d4, C4;
      return this.negative !== 0 && n4.negative === 0 ? (C4 = this.neg().divmod(n4, a4), a4 !== "mod" && (c4 = C4.div.neg()), a4 !== "div" && (d4 = C4.mod.neg(), u5 && d4.negative !== 0 && d4.iadd(n4)), { div: c4, mod: d4 }) : this.negative === 0 && n4.negative !== 0 ? (C4 = this.divmod(n4.neg(), a4), a4 !== "mod" && (c4 = C4.div.neg()), { div: c4, mod: C4.mod }) : (this.negative & n4.negative) !== 0 ? (C4 = this.neg().divmod(n4.neg(), a4), a4 !== "div" && (d4 = C4.mod.neg(), u5 && d4.negative !== 0 && d4.isub(n4)), { div: C4.div, mod: d4 }) : n4.length > this.length || this.cmp(n4) < 0 ? { div: new i4(0), mod: this } : n4.length === 1 ? a4 === "div" ? { div: this.divn(n4.words[0]), mod: null } : a4 === "mod" ? { div: null, mod: new i4(this.modn(n4.words[0])) } : { div: this.divn(n4.words[0]), mod: new i4(this.modn(n4.words[0])) } : this._wordDiv(n4, a4);
    }, i4.prototype.div = function(n4) {
      return this.divmod(n4, "div", false).div;
    }, i4.prototype.mod = function(n4) {
      return this.divmod(n4, "mod", false).mod;
    }, i4.prototype.umod = function(n4) {
      return this.divmod(n4, "mod", true).mod;
    }, i4.prototype.divRound = function(n4) {
      var a4 = this.divmod(n4);
      if (a4.mod.isZero())
        return a4.div;
      var u5 = a4.div.negative !== 0 ? a4.mod.isub(n4) : a4.mod, c4 = n4.ushrn(1), d4 = n4.andln(1), C4 = u5.cmp(c4);
      return C4 < 0 || d4 === 1 && C4 === 0 ? a4.div : a4.div.negative !== 0 ? a4.div.isubn(1) : a4.div.iaddn(1);
    }, i4.prototype.modn = function(n4) {
      r5(n4 <= 67108863);
      for (var a4 = (1 << 26) % n4, u5 = 0, c4 = this.length - 1; c4 >= 0; c4--)
        u5 = (a4 * u5 + (this.words[c4] | 0)) % n4;
      return u5;
    }, i4.prototype.idivn = function(n4) {
      r5(n4 <= 67108863);
      for (var a4 = 0, u5 = this.length - 1; u5 >= 0; u5--) {
        var c4 = (this.words[u5] | 0) + a4 * 67108864;
        this.words[u5] = c4 / n4 | 0, a4 = c4 % n4;
      }
      return this.strip();
    }, i4.prototype.divn = function(n4) {
      return this.clone().idivn(n4);
    }, i4.prototype.egcd = function(n4) {
      r5(n4.negative === 0), r5(!n4.isZero());
      var a4 = this, u5 = n4.clone();
      a4.negative !== 0 ? a4 = a4.umod(n4) : a4 = a4.clone();
      for (var c4 = new i4(1), d4 = new i4(0), C4 = new i4(0), _5 = new i4(1), l5 = 0; a4.isEven() && u5.isEven(); )
        a4.iushrn(1), u5.iushrn(1), ++l5;
      for (var s4 = u5.clone(), h5 = a4.clone(); !a4.isZero(); ) {
        for (var k5 = 0, I4 = 1; (a4.words[0] & I4) === 0 && k5 < 26; ++k5, I4 <<= 1)
          ;
        if (k5 > 0)
          for (a4.iushrn(k5); k5-- > 0; )
            (c4.isOdd() || d4.isOdd()) && (c4.iadd(s4), d4.isub(h5)), c4.iushrn(1), d4.iushrn(1);
        for (var A5 = 0, B3 = 1; (u5.words[0] & B3) === 0 && A5 < 26; ++A5, B3 <<= 1)
          ;
        if (A5 > 0)
          for (u5.iushrn(A5); A5-- > 0; )
            (C4.isOdd() || _5.isOdd()) && (C4.iadd(s4), _5.isub(h5)), C4.iushrn(1), _5.iushrn(1);
        a4.cmp(u5) >= 0 ? (a4.isub(u5), c4.isub(C4), d4.isub(_5)) : (u5.isub(a4), C4.isub(c4), _5.isub(d4));
      }
      return { a: C4, b: _5, gcd: u5.iushln(l5) };
    }, i4.prototype._invmp = function(n4) {
      r5(n4.negative === 0), r5(!n4.isZero());
      var a4 = this, u5 = n4.clone();
      a4.negative !== 0 ? a4 = a4.umod(n4) : a4 = a4.clone();
      for (var c4 = new i4(1), d4 = new i4(0), C4 = u5.clone(); a4.cmpn(1) > 0 && u5.cmpn(1) > 0; ) {
        for (var _5 = 0, l5 = 1; (a4.words[0] & l5) === 0 && _5 < 26; ++_5, l5 <<= 1)
          ;
        if (_5 > 0)
          for (a4.iushrn(_5); _5-- > 0; )
            c4.isOdd() && c4.iadd(C4), c4.iushrn(1);
        for (var s4 = 0, h5 = 1; (u5.words[0] & h5) === 0 && s4 < 26; ++s4, h5 <<= 1)
          ;
        if (s4 > 0)
          for (u5.iushrn(s4); s4-- > 0; )
            d4.isOdd() && d4.iadd(C4), d4.iushrn(1);
        a4.cmp(u5) >= 0 ? (a4.isub(u5), c4.isub(d4)) : (u5.isub(a4), d4.isub(c4));
      }
      var k5;
      return a4.cmpn(1) === 0 ? k5 = c4 : k5 = d4, k5.cmpn(0) < 0 && k5.iadd(n4), k5;
    }, i4.prototype.gcd = function(n4) {
      if (this.isZero())
        return n4.abs();
      if (n4.isZero())
        return this.abs();
      var a4 = this.clone(), u5 = n4.clone();
      a4.negative = 0, u5.negative = 0;
      for (var c4 = 0; a4.isEven() && u5.isEven(); c4++)
        a4.iushrn(1), u5.iushrn(1);
      do {
        for (; a4.isEven(); )
          a4.iushrn(1);
        for (; u5.isEven(); )
          u5.iushrn(1);
        var d4 = a4.cmp(u5);
        if (d4 < 0) {
          var C4 = a4;
          a4 = u5, u5 = C4;
        } else if (d4 === 0 || u5.cmpn(1) === 0)
          break;
        a4.isub(u5);
      } while (true);
      return u5.iushln(c4);
    }, i4.prototype.invm = function(n4) {
      return this.egcd(n4).a.umod(n4);
    }, i4.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i4.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i4.prototype.andln = function(n4) {
      return this.words[0] & n4;
    }, i4.prototype.bincn = function(n4) {
      r5(typeof n4 == "number");
      var a4 = n4 % 26, u5 = (n4 - a4) / 26, c4 = 1 << a4;
      if (this.length <= u5)
        return this._expand(u5 + 1), this.words[u5] |= c4, this;
      for (var d4 = c4, C4 = u5; d4 !== 0 && C4 < this.length; C4++) {
        var _5 = this.words[C4] | 0;
        _5 += d4, d4 = _5 >>> 26, _5 &= 67108863, this.words[C4] = _5;
      }
      return d4 !== 0 && (this.words[C4] = d4, this.length++), this;
    }, i4.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i4.prototype.cmpn = function(n4) {
      var a4 = n4 < 0;
      if (this.negative !== 0 && !a4)
        return -1;
      if (this.negative === 0 && a4)
        return 1;
      this.strip();
      var u5;
      if (this.length > 1)
        u5 = 1;
      else {
        a4 && (n4 = -n4), r5(n4 <= 67108863, "Number is too big");
        var c4 = this.words[0] | 0;
        u5 = c4 === n4 ? 0 : c4 < n4 ? -1 : 1;
      }
      return this.negative !== 0 ? -u5 | 0 : u5;
    }, i4.prototype.cmp = function(n4) {
      if (this.negative !== 0 && n4.negative === 0)
        return -1;
      if (this.negative === 0 && n4.negative !== 0)
        return 1;
      var a4 = this.ucmp(n4);
      return this.negative !== 0 ? -a4 | 0 : a4;
    }, i4.prototype.ucmp = function(n4) {
      if (this.length > n4.length)
        return 1;
      if (this.length < n4.length)
        return -1;
      for (var a4 = 0, u5 = this.length - 1; u5 >= 0; u5--) {
        var c4 = this.words[u5] | 0, d4 = n4.words[u5] | 0;
        if (c4 !== d4) {
          c4 < d4 ? a4 = -1 : c4 > d4 && (a4 = 1);
          break;
        }
      }
      return a4;
    }, i4.prototype.gtn = function(n4) {
      return this.cmpn(n4) === 1;
    }, i4.prototype.gt = function(n4) {
      return this.cmp(n4) === 1;
    }, i4.prototype.gten = function(n4) {
      return this.cmpn(n4) >= 0;
    }, i4.prototype.gte = function(n4) {
      return this.cmp(n4) >= 0;
    }, i4.prototype.ltn = function(n4) {
      return this.cmpn(n4) === -1;
    }, i4.prototype.lt = function(n4) {
      return this.cmp(n4) === -1;
    }, i4.prototype.lten = function(n4) {
      return this.cmpn(n4) <= 0;
    }, i4.prototype.lte = function(n4) {
      return this.cmp(n4) <= 0;
    }, i4.prototype.eqn = function(n4) {
      return this.cmpn(n4) === 0;
    }, i4.prototype.eq = function(n4) {
      return this.cmp(n4) === 0;
    }, i4.red = function(n4) {
      return new V3(n4);
    }, i4.prototype.toRed = function(n4) {
      return r5(!this.red, "Already a number in reduction context"), r5(this.negative === 0, "red works only with positives"), n4.convertTo(this)._forceRed(n4);
    }, i4.prototype.fromRed = function() {
      return r5(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i4.prototype._forceRed = function(n4) {
      return this.red = n4, this;
    }, i4.prototype.forceRed = function(n4) {
      return r5(!this.red, "Already a number in reduction context"), this._forceRed(n4);
    }, i4.prototype.redAdd = function(n4) {
      return r5(this.red, "redAdd works only with red numbers"), this.red.add(this, n4);
    }, i4.prototype.redIAdd = function(n4) {
      return r5(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, n4);
    }, i4.prototype.redSub = function(n4) {
      return r5(this.red, "redSub works only with red numbers"), this.red.sub(this, n4);
    }, i4.prototype.redISub = function(n4) {
      return r5(this.red, "redISub works only with red numbers"), this.red.isub(this, n4);
    }, i4.prototype.redShl = function(n4) {
      return r5(this.red, "redShl works only with red numbers"), this.red.shl(this, n4);
    }, i4.prototype.redMul = function(n4) {
      return r5(this.red, "redMul works only with red numbers"), this.red._verify2(this, n4), this.red.mul(this, n4);
    }, i4.prototype.redIMul = function(n4) {
      return r5(this.red, "redMul works only with red numbers"), this.red._verify2(this, n4), this.red.imul(this, n4);
    }, i4.prototype.redSqr = function() {
      return r5(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i4.prototype.redISqr = function() {
      return r5(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i4.prototype.redSqrt = function() {
      return r5(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i4.prototype.redInvm = function() {
      return r5(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i4.prototype.redNeg = function() {
      return r5(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i4.prototype.redPow = function(n4) {
      return r5(this.red && !n4.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, n4);
    };
    var Jt = { k256: null, p224: null, p192: null, p25519: null };
    function Lt(g4, n4) {
      this.name = g4, this.p = new i4(n4, 16), this.n = this.p.bitLength(), this.k = new i4(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Lt.prototype._tmp = function() {
      var n4 = new i4(null);
      return n4.words = new Array(Math.ceil(this.n / 13)), n4;
    }, Lt.prototype.ireduce = function(n4) {
      var a4 = n4, u5;
      do
        this.split(a4, this.tmp), a4 = this.imulK(a4), a4 = a4.iadd(this.tmp), u5 = a4.bitLength();
      while (u5 > this.n);
      var c4 = u5 < this.n ? -1 : a4.ucmp(this.p);
      return c4 === 0 ? (a4.words[0] = 0, a4.length = 1) : c4 > 0 ? a4.isub(this.p) : a4.strip(), a4;
    }, Lt.prototype.split = function(n4, a4) {
      n4.iushrn(this.n, 0, a4);
    }, Lt.prototype.imulK = function(n4) {
      return n4.imul(this.k);
    };
    function Se() {
      Lt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    o4(Se, Lt), Se.prototype.split = function(n4, a4) {
      for (var u5 = 4194303, c4 = Math.min(n4.length, 9), d4 = 0; d4 < c4; d4++)
        a4.words[d4] = n4.words[d4];
      if (a4.length = c4, n4.length <= 9) {
        n4.words[0] = 0, n4.length = 1;
        return;
      }
      var C4 = n4.words[9];
      for (a4.words[a4.length++] = C4 & u5, d4 = 10; d4 < n4.length; d4++) {
        var _5 = n4.words[d4] | 0;
        n4.words[d4 - 10] = (_5 & u5) << 4 | C4 >>> 22, C4 = _5;
      }
      C4 >>>= 22, n4.words[d4 - 10] = C4, C4 === 0 && n4.length > 10 ? n4.length -= 10 : n4.length -= 9;
    }, Se.prototype.imulK = function(n4) {
      n4.words[n4.length] = 0, n4.words[n4.length + 1] = 0, n4.length += 2;
      for (var a4 = 0, u5 = 0; u5 < n4.length; u5++) {
        var c4 = n4.words[u5] | 0;
        a4 += c4 * 977, n4.words[u5] = a4 & 67108863, a4 = c4 * 64 + (a4 / 67108864 | 0);
      }
      return n4.words[n4.length - 1] === 0 && (n4.length--, n4.words[n4.length - 1] === 0 && n4.length--), n4;
    };
    function ti() {
      Lt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    o4(ti, Lt);
    function ei() {
      Lt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    o4(ei, Lt);
    function br() {
      Lt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    o4(br, Lt), br.prototype.imulK = function(n4) {
      for (var a4 = 0, u5 = 0; u5 < n4.length; u5++) {
        var c4 = (n4.words[u5] | 0) * 19 + a4, d4 = c4 & 67108863;
        c4 >>>= 26, n4.words[u5] = d4, a4 = c4;
      }
      return a4 !== 0 && (n4.words[n4.length++] = a4), n4;
    }, i4._prime = function(n4) {
      if (Jt[n4])
        return Jt[n4];
      var a4;
      if (n4 === "k256")
        a4 = new Se();
      else if (n4 === "p224")
        a4 = new ti();
      else if (n4 === "p192")
        a4 = new ei();
      else if (n4 === "p25519")
        a4 = new br();
      else
        throw new Error("Unknown prime " + n4);
      return Jt[n4] = a4, a4;
    };
    function V3(g4) {
      if (typeof g4 == "string") {
        var n4 = i4._prime(g4);
        this.m = n4.p, this.prime = n4;
      } else
        r5(g4.gtn(1), "modulus must be greater than 1"), this.m = g4, this.prime = null;
    }
    V3.prototype._verify1 = function(n4) {
      r5(n4.negative === 0, "red works only with positives"), r5(n4.red, "red works only with red numbers");
    }, V3.prototype._verify2 = function(n4, a4) {
      r5((n4.negative | a4.negative) === 0, "red works only with positives"), r5(n4.red && n4.red === a4.red, "red works only with red numbers");
    }, V3.prototype.imod = function(n4) {
      return this.prime ? this.prime.ireduce(n4)._forceRed(this) : n4.umod(this.m)._forceRed(this);
    }, V3.prototype.neg = function(n4) {
      return n4.isZero() ? n4.clone() : this.m.sub(n4)._forceRed(this);
    }, V3.prototype.add = function(n4, a4) {
      this._verify2(n4, a4);
      var u5 = n4.add(a4);
      return u5.cmp(this.m) >= 0 && u5.isub(this.m), u5._forceRed(this);
    }, V3.prototype.iadd = function(n4, a4) {
      this._verify2(n4, a4);
      var u5 = n4.iadd(a4);
      return u5.cmp(this.m) >= 0 && u5.isub(this.m), u5;
    }, V3.prototype.sub = function(n4, a4) {
      this._verify2(n4, a4);
      var u5 = n4.sub(a4);
      return u5.cmpn(0) < 0 && u5.iadd(this.m), u5._forceRed(this);
    }, V3.prototype.isub = function(n4, a4) {
      this._verify2(n4, a4);
      var u5 = n4.isub(a4);
      return u5.cmpn(0) < 0 && u5.iadd(this.m), u5;
    }, V3.prototype.shl = function(n4, a4) {
      return this._verify1(n4), this.imod(n4.ushln(a4));
    }, V3.prototype.imul = function(n4, a4) {
      return this._verify2(n4, a4), this.imod(n4.imul(a4));
    }, V3.prototype.mul = function(n4, a4) {
      return this._verify2(n4, a4), this.imod(n4.mul(a4));
    }, V3.prototype.isqr = function(n4) {
      return this.imul(n4, n4.clone());
    }, V3.prototype.sqr = function(n4) {
      return this.mul(n4, n4);
    }, V3.prototype.sqrt = function(n4) {
      if (n4.isZero())
        return n4.clone();
      var a4 = this.m.andln(3);
      if (r5(a4 % 2 === 1), a4 === 3) {
        var u5 = this.m.add(new i4(1)).iushrn(2);
        return this.pow(n4, u5);
      }
      for (var c4 = this.m.subn(1), d4 = 0; !c4.isZero() && c4.andln(1) === 0; )
        d4++, c4.iushrn(1);
      r5(!c4.isZero());
      var C4 = new i4(1).toRed(this), _5 = C4.redNeg(), l5 = this.m.subn(1).iushrn(1), s4 = this.m.bitLength();
      for (s4 = new i4(2 * s4 * s4).toRed(this); this.pow(s4, l5).cmp(_5) !== 0; )
        s4.redIAdd(_5);
      for (var h5 = this.pow(s4, c4), k5 = this.pow(n4, c4.addn(1).iushrn(1)), I4 = this.pow(n4, c4), A5 = d4; I4.cmp(C4) !== 0; ) {
        for (var B3 = I4, H4 = 0; B3.cmp(C4) !== 0; H4++)
          B3 = B3.redSqr();
        r5(H4 < A5);
        var N4 = this.pow(h5, new i4(1).iushln(A5 - H4 - 1));
        k5 = k5.redMul(N4), h5 = N4.redSqr(), I4 = I4.redMul(h5), A5 = H4;
      }
      return k5;
    }, V3.prototype.invm = function(n4) {
      var a4 = n4._invmp(this.m);
      return a4.negative !== 0 ? (a4.negative = 0, this.imod(a4).redNeg()) : this.imod(a4);
    }, V3.prototype.pow = function(n4, a4) {
      if (a4.isZero())
        return new i4(1).toRed(this);
      if (a4.cmpn(1) === 0)
        return n4.clone();
      var u5 = 4, c4 = new Array(1 << u5);
      c4[0] = new i4(1).toRed(this), c4[1] = n4;
      for (var d4 = 2; d4 < c4.length; d4++)
        c4[d4] = this.mul(c4[d4 - 1], n4);
      var C4 = c4[0], _5 = 0, l5 = 0, s4 = a4.bitLength() % 26;
      for (s4 === 0 && (s4 = 26), d4 = a4.length - 1; d4 >= 0; d4--) {
        for (var h5 = a4.words[d4], k5 = s4 - 1; k5 >= 0; k5--) {
          var I4 = h5 >> k5 & 1;
          if (C4 !== c4[0] && (C4 = this.sqr(C4)), I4 === 0 && _5 === 0) {
            l5 = 0;
            continue;
          }
          _5 <<= 1, _5 |= I4, l5++, !(l5 !== u5 && (d4 !== 0 || k5 !== 0)) && (C4 = this.mul(C4, c4[_5]), l5 = 0, _5 = 0);
        }
        s4 = 26;
      }
      return C4;
    }, V3.prototype.convertTo = function(n4) {
      var a4 = n4.umod(this.m);
      return a4 === n4 ? a4.clone() : a4;
    }, V3.prototype.convertFrom = function(n4) {
      var a4 = n4.clone();
      return a4.red = null, a4;
    }, i4.mont = function(n4) {
      return new he(n4);
    };
    function he(g4) {
      V3.call(this, g4), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i4(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    o4(he, V3), he.prototype.convertTo = function(n4) {
      return this.imod(n4.ushln(this.shift));
    }, he.prototype.convertFrom = function(n4) {
      var a4 = this.imod(n4.mul(this.rinv));
      return a4.red = null, a4;
    }, he.prototype.imul = function(n4, a4) {
      if (n4.isZero() || a4.isZero())
        return n4.words[0] = 0, n4.length = 1, n4;
      var u5 = n4.imul(a4), c4 = u5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u5.isub(c4).iushrn(this.shift), C4 = d4;
      return d4.cmp(this.m) >= 0 ? C4 = d4.isub(this.m) : d4.cmpn(0) < 0 && (C4 = d4.iadd(this.m)), C4._forceRed(this);
    }, he.prototype.mul = function(n4, a4) {
      if (n4.isZero() || a4.isZero())
        return new i4(0)._forceRed(this);
      var u5 = n4.mul(a4), c4 = u5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u5.isub(c4).iushrn(this.shift), C4 = d4;
      return d4.cmp(this.m) >= 0 ? C4 = d4.isub(this.m) : d4.cmpn(0) < 0 && (C4 = d4.iadd(this.m)), C4._forceRed(this);
    }, he.prototype.invm = function(n4) {
      var a4 = this.imod(n4._invmp(this.m).mul(this.r2));
      return a4._forceRed(this);
    };
  })(typeof un > "u" || un, Io);
});
var ln = Dt((zc, Oo) => {
  y4();
  w5();
  x4();
  Oo.exports = cn5;
  cn5.strict = Lo;
  cn5.loose = Ro;
  var l1 = Object.prototype.toString, h1 = { "[object Int8Array]": true, "[object Int16Array]": true, "[object Int32Array]": true, "[object Uint8Array]": true, "[object Uint8ClampedArray]": true, "[object Uint16Array]": true, "[object Uint32Array]": true, "[object Float32Array]": true, "[object Float64Array]": true };
  function cn5(e5) {
    return Lo(e5) || Ro(e5);
  }
  function Lo(e5) {
    return e5 instanceof Int8Array || e5 instanceof Int16Array || e5 instanceof Int32Array || e5 instanceof Uint8Array || e5 instanceof Uint8ClampedArray || e5 instanceof Uint16Array || e5 instanceof Uint32Array || e5 instanceof Float32Array || e5 instanceof Float64Array;
  }
  function Ro(e5) {
    return h1[l1.call(e5)];
  }
});
var Do = Dt((Qc, Bo) => {
  y4();
  w5();
  x4();
  var d1 = ln().strict;
  Bo.exports = function(t5) {
    if (d1(t5)) {
      var r5 = v4.from(t5.buffer);
      return t5.byteLength !== t5.buffer.byteLength && (r5 = r5.slice(t5.byteOffset, t5.byteOffset + t5.byteLength)), r5;
    } else
      return v4.from(t5);
  };
});
var rs = Dt((oe) => {
  "use strict";
  y4();
  w5();
  x4();
  Object.defineProperty(oe, "__esModule", { value: true });
  oe.isBrowserCryptoAvailable = oe.getSubtleCrypto = oe.getBrowerCrypto = void 0;
  function vn() {
    return (globalThis == null ? void 0 : globalThis.crypto) || (globalThis == null ? void 0 : globalThis.msCrypto) || {};
  }
  oe.getBrowerCrypto = vn;
  function es() {
    let e5 = vn();
    return e5.subtle || e5.webkitSubtle;
  }
  oe.getSubtleCrypto = es;
  function _1() {
    return !!vn() && !!es();
  }
  oe.isBrowserCryptoAvailable = _1;
});
var os = Dt((se) => {
  "use strict";
  y4();
  w5();
  x4();
  Object.defineProperty(se, "__esModule", { value: true });
  se.isBrowser = se.isNode = se.isReactNative = void 0;
  function ns() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  se.isReactNative = ns;
  function is() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  se.isNode = is;
  function M1() {
    return !ns() && !is();
  }
  se.isBrowser = M1;
});
var Ce = Dt((ae) => {
  "use strict";
  y4();
  w5();
  x4();
  var S1 = ae && ae.__createBinding || (Object.create ? function(e5, t5, r5, o4) {
    o4 === void 0 && (o4 = r5), Object.defineProperty(e5, o4, { enumerable: true, get: function() {
      return t5[r5];
    } });
  } : function(e5, t5, r5, o4) {
    o4 === void 0 && (o4 = r5), e5[o4] = t5[r5];
  }), ss = ae && ae.__exportStar || function(e5, t5) {
    for (var r5 in e5)
      r5 !== "default" && !t5.hasOwnProperty(r5) && S1(t5, e5, r5);
  };
  Object.defineProperty(ae, "__esModule", { value: true });
  ss(rs(), ae);
  ss(os(), ae);
});
var _s = Dt((Xl, Cs) => {
  "use strict";
  y4();
  w5();
  x4();
  Cs.exports = (e5) => encodeURIComponent(e5).replace(/[!'()*]/g, (t5) => `%${t5.charCodeAt(0).toString(16).toUpperCase()}`);
});
var ks = Dt((th, Es) => {
  "use strict";
  y4();
  w5();
  x4();
  var bs = "%[a-f0-9]{2}", Ms = new RegExp(bs, "gi"), Ss = new RegExp("(" + bs + ")+", "gi");
  function Sn(e5, t5) {
    try {
      return decodeURIComponent(e5.join(""));
    } catch (i4) {
    }
    if (e5.length === 1)
      return e5;
    t5 = t5 || 1;
    var r5 = e5.slice(0, t5), o4 = e5.slice(t5);
    return Array.prototype.concat.call([], Sn(r5), Sn(o4));
  }
  function V1(e5) {
    try {
      return decodeURIComponent(e5);
    } catch (o4) {
      for (var t5 = e5.match(Ms), r5 = 1; r5 < t5.length; r5++)
        e5 = Sn(t5, r5).join(""), t5 = e5.match(Ms);
      return e5;
    }
  }
  function Z1(e5) {
    for (var t5 = { "%FE%FF": "\uFFFD\uFFFD", "%FF%FE": "\uFFFD\uFFFD" }, r5 = Ss.exec(e5); r5; ) {
      try {
        t5[r5[0]] = decodeURIComponent(r5[0]);
      } catch (M4) {
        var o4 = V1(r5[0]);
        o4 !== r5[0] && (t5[r5[0]] = o4);
      }
      r5 = Ss.exec(e5);
    }
    t5["%C2"] = "\uFFFD";
    for (var i4 = Object.keys(t5), p5 = 0; p5 < i4.length; p5++) {
      var m5 = i4[p5];
      e5 = e5.replace(new RegExp(m5, "g"), t5[m5]);
    }
    return e5;
  }
  Es.exports = function(e5) {
    if (typeof e5 != "string")
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e5 + "`");
    try {
      return e5 = e5.replace(/\+/g, " "), decodeURIComponent(e5);
    } catch (t5) {
      return Z1(e5);
    }
  };
});
var Is = Dt((eh, Ts) => {
  "use strict";
  y4();
  w5();
  x4();
  Ts.exports = (e5, t5) => {
    if (!(typeof e5 == "string" && typeof t5 == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
    if (t5 === "")
      return [e5];
    let r5 = e5.indexOf(t5);
    return r5 === -1 ? [e5] : [e5.slice(0, r5), e5.slice(r5 + t5.length)];
  };
});
var Us = Dt((Kt) => {
  "use strict";
  y4();
  w5();
  x4();
  var G1 = _s(), $1 = ks(), Ls = Is(), j1 = (e5) => e5 == null;
  function Y1(e5) {
    switch (e5.arrayFormat) {
      case "index":
        return (t5) => (r5, o4) => {
          let i4 = r5.length;
          return o4 === void 0 || e5.skipNull && o4 === null || e5.skipEmptyString && o4 === "" ? r5 : o4 === null ? [...r5, [At(t5, e5), "[", i4, "]"].join("")] : [...r5, [At(t5, e5), "[", At(i4, e5), "]=", At(o4, e5)].join("")];
        };
      case "bracket":
        return (t5) => (r5, o4) => o4 === void 0 || e5.skipNull && o4 === null || e5.skipEmptyString && o4 === "" ? r5 : o4 === null ? [...r5, [At(t5, e5), "[]"].join("")] : [...r5, [At(t5, e5), "[]=", At(o4, e5)].join("")];
      case "comma":
      case "separator":
        return (t5) => (r5, o4) => o4 == null || o4.length === 0 ? r5 : r5.length === 0 ? [[At(t5, e5), "=", At(o4, e5)].join("")] : [[r5, At(o4, e5)].join(e5.arrayFormatSeparator)];
      default:
        return (t5) => (r5, o4) => o4 === void 0 || e5.skipNull && o4 === null || e5.skipEmptyString && o4 === "" ? r5 : o4 === null ? [...r5, At(t5, e5)] : [...r5, [At(t5, e5), "=", At(o4, e5)].join("")];
    }
  }
  function J1(e5) {
    let t5;
    switch (e5.arrayFormat) {
      case "index":
        return (r5, o4, i4) => {
          if (t5 = /\[(\d*)\]$/.exec(r5), r5 = r5.replace(/\[\d*\]$/, ""), !t5) {
            i4[r5] = o4;
            return;
          }
          i4[r5] === void 0 && (i4[r5] = {}), i4[r5][t5[1]] = o4;
        };
      case "bracket":
        return (r5, o4, i4) => {
          if (t5 = /(\[\])$/.exec(r5), r5 = r5.replace(/\[\]$/, ""), !t5) {
            i4[r5] = o4;
            return;
          }
          if (i4[r5] === void 0) {
            i4[r5] = [o4];
            return;
          }
          i4[r5] = [].concat(i4[r5], o4);
        };
      case "comma":
      case "separator":
        return (r5, o4, i4) => {
          let m5 = typeof o4 == "string" && o4.split("").indexOf(e5.arrayFormatSeparator) > -1 ? o4.split(e5.arrayFormatSeparator).map((M4) => Ie(M4, e5)) : o4 === null ? o4 : Ie(o4, e5);
          i4[r5] = m5;
        };
      default:
        return (r5, o4, i4) => {
          if (i4[r5] === void 0) {
            i4[r5] = o4;
            return;
          }
          i4[r5] = [].concat(i4[r5], o4);
        };
    }
  }
  function Rs(e5) {
    if (typeof e5 != "string" || e5.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function At(e5, t5) {
    return t5.encode ? t5.strict ? G1(e5) : encodeURIComponent(e5) : e5;
  }
  function Ie(e5, t5) {
    return t5.decode ? $1(e5) : e5;
  }
  function Os(e5) {
    return Array.isArray(e5) ? e5.sort() : typeof e5 == "object" ? Os(Object.keys(e5)).sort((t5, r5) => Number(t5) - Number(r5)).map((t5) => e5[t5]) : e5;
  }
  function Bs(e5) {
    let t5 = e5.indexOf("#");
    return t5 !== -1 && (e5 = e5.slice(0, t5)), e5;
  }
  function z1(e5) {
    let t5 = "", r5 = e5.indexOf("#");
    return r5 !== -1 && (t5 = e5.slice(r5)), t5;
  }
  function Ds(e5) {
    e5 = Bs(e5);
    let t5 = e5.indexOf("?");
    return t5 === -1 ? "" : e5.slice(t5 + 1);
  }
  function As(e5, t5) {
    return t5.parseNumbers && !Number.isNaN(Number(e5)) && typeof e5 == "string" && e5.trim() !== "" ? e5 = Number(e5) : t5.parseBooleans && e5 !== null && (e5.toLowerCase() === "true" || e5.toLowerCase() === "false") && (e5 = e5.toLowerCase() === "true"), e5;
  }
  function Ps(e5, t5) {
    t5 = Object.assign({ decode: true, sort: true, arrayFormat: "none", arrayFormatSeparator: ",", parseNumbers: false, parseBooleans: false }, t5), Rs(t5.arrayFormatSeparator);
    let r5 = J1(t5), o4 = /* @__PURE__ */ Object.create(null);
    if (typeof e5 != "string" || (e5 = e5.trim().replace(/^[?#&]/, ""), !e5))
      return o4;
    for (let i4 of e5.split("&")) {
      let [p5, m5] = Ls(t5.decode ? i4.replace(/\+/g, " ") : i4, "=");
      m5 = m5 === void 0 ? null : ["comma", "separator"].includes(t5.arrayFormat) ? m5 : Ie(m5, t5), r5(Ie(p5, t5), m5, o4);
    }
    for (let i4 of Object.keys(o4)) {
      let p5 = o4[i4];
      if (typeof p5 == "object" && p5 !== null)
        for (let m5 of Object.keys(p5))
          p5[m5] = As(p5[m5], t5);
      else
        o4[i4] = As(p5, t5);
    }
    return t5.sort === false ? o4 : (t5.sort === true ? Object.keys(o4).sort() : Object.keys(o4).sort(t5.sort)).reduce((i4, p5) => {
      let m5 = o4[p5];
      return Boolean(m5) && typeof m5 == "object" && !Array.isArray(m5) ? i4[p5] = Os(m5) : i4[p5] = m5, i4;
    }, /* @__PURE__ */ Object.create(null));
  }
  Kt.extract = Ds;
  Kt.parse = Ps;
  Kt.stringify = (e5, t5) => {
    if (!e5)
      return "";
    t5 = Object.assign({ encode: true, strict: true, arrayFormat: "none", arrayFormatSeparator: "," }, t5), Rs(t5.arrayFormatSeparator);
    let r5 = (m5) => t5.skipNull && j1(e5[m5]) || t5.skipEmptyString && e5[m5] === "", o4 = Y1(t5), i4 = {};
    for (let m5 of Object.keys(e5))
      r5(m5) || (i4[m5] = e5[m5]);
    let p5 = Object.keys(i4);
    return t5.sort !== false && p5.sort(t5.sort), p5.map((m5) => {
      let M4 = e5[m5];
      return M4 === void 0 ? "" : M4 === null ? At(m5, t5) : Array.isArray(M4) ? M4.reduce(o4(m5), []).join("&") : At(m5, t5) + "=" + At(M4, t5);
    }).filter((m5) => m5.length > 0).join("&");
  };
  Kt.parseUrl = (e5, t5) => {
    t5 = Object.assign({ decode: true }, t5);
    let [r5, o4] = Ls(e5, "#");
    return Object.assign({ url: r5.split("?")[0] || "", query: Ps(Ds(e5), t5) }, t5 && t5.parseFragmentIdentifier && o4 ? { fragmentIdentifier: Ie(o4, t5) } : {});
  };
  Kt.stringifyUrl = (e5, t5) => {
    t5 = Object.assign({ encode: true, strict: true }, t5);
    let r5 = Bs(e5.url).split("?")[0] || "", o4 = Kt.extract(e5.url), i4 = Kt.parse(o4, { sort: false }), p5 = Object.assign(i4, e5.query), m5 = Kt.stringify(p5, t5);
    m5 && (m5 = `?${m5}`);
    let M4 = z1(e5.url);
    return e5.fragmentIdentifier && (M4 = `#${At(e5.fragmentIdentifier, t5)}`), `${r5}${m5}${M4}`;
  };
});
var Zs = Dt((vh, Vs) => {
  "use strict";
  y4();
  w5();
  x4();
  Vs.exports = function() {
    throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
  };
});
y4();
w5();
x4();
var rn = {};
ve(rn, { buildQRData: () => en, buildVerificationRequest: () => Qr, hashEncodedBytes: () => tn, hashString: () => qi, keccak256: () => Vi, randomNumber: () => Fi, validateABILikeEncoding: () => Fe, validateInputParams: () => Xr, verifyVerificationResponse: () => Kr, worldIDHash: () => zr });
y4();
w5();
x4();
var Fi = (e5, t5) => Math.floor(Math.random() * (t5 - e5 + 1) + e5);
var Qr = (e5) => {
  if (!e5.signal)
    throw new Error("Unexpectedly trying to build verification request without a `signal`.");
  let t5 = { signal: e5.advanced_use_raw_signal ? e5.signal : zr(e5.signal).digest, action_id: e5.advanced_use_raw_action_id ? e5.action_id : zr(e5.action_id).digest };
  return e5.app_name && (t5.app_name = e5.app_name), e5.signal_description && (t5.signal_description = e5.signal_description), { id: Fi(1e5, 9999999), jsonrpc: "2.0", method: "wld_worldIDVerification", params: [t5] };
};
var Kr = (e5) => {
  let t5 = "merkle_root" in e5 ? e5.merkle_root : void 0, r5 = "nullifier_hash" in e5 ? e5.nullifier_hash : void 0, o4 = "proof" in e5 ? e5.proof : void 0;
  for (let i4 of [t5, r5, o4])
    if (!i4 || !Fe(i4))
      return false;
  return true;
};
var Fe = (e5) => {
  let t5 = /^0x[\dabcdef]+$/;
  return !!e5.toString().match(t5) && e5.length >= 66;
};
var Xr = (e5) => e5.action_id ? e5.advanced_use_raw_action_id && !Fe(e5.action_id) ? { valid: false, error: `You enabled 'advanced_use_raw_action_id' which uses the action ID raw (without any additional hashing or encoding),
        but the action ID you provided does not look to be validly hashed or encoded. Please check
        https://id.worldcoin.org/docs/js/reference#parameters for details.` } : e5.advanced_use_raw_signal && e5.signal && !Fe(e5.signal) ? { valid: false, error: `You enabled 'advanced_use_raw_signal' which uses the signal raw (without any additional hashing or encoding),
        but the signal you provided does not look to be validly hashed or encoded. Please check
        https://id.worldcoin.org/docs/js/reference#parameters for details.` } : { valid: true } : { valid: false, error: "The `action_id` parameter cannot be empty." };
function zr(e5) {
  return isBytesLike(e5) ? tn(e5) : qi(e5);
}
function qi(e5) {
  let t5 = v4.from(e5);
  return tn(t5);
}
function tn(e5) {
  let t5 = BigInt(Vi(e5)) >> BigInt(8), r5 = t5.toString(16);
  return { hash: t5, digest: `0x${r5.padStart(64, "0")}` };
}
function Vi(e5) {
  let t5 = [arrayify(e5)], r5 = hexlify(concat3(t5));
  return "0x" + import_js_sha36.default.keccak_256(arrayify(r5));
}
function en(e5) {
  let t5 = new URL(e5.bridge), r5 = new URL("https://worldcoin.org/verify");
  return r5.searchParams.append("t", e5.handshakeTopic), r5.searchParams.append("k", e5.key), r5.searchParams.append("b", t5.hostname), r5.searchParams.append("v", "1"), r5.toString();
}
y4();
w5();
x4();
var qe = ((M4) => (M4.ConnectionFailed = "connection_failed", M4.VerificationRejected = "verification_rejected", M4.AlreadySigned = "already_signed", M4.InvalidActionID = "invalid_action_id", M4.InvalidSignal = "invalid_signal", M4.UnexpectedResponse = "unexpected_response", M4.GenericError = "generic_error", M4))(qe || {});
var Ve = ((r5) => (r5[r5.VerificationFlow = 0] = "VerificationFlow", r5[r5.LearnMore = 1] = "LearnMore", r5))(Ve || {});
var Ze = ((i4) => (i4[i4.AwaitingConnection = 0] = "AwaitingConnection", i4[i4.AwaitingVerification = 1] = "AwaitingVerification", i4[i4.Confirmed = 2] = "Confirmed", i4[i4.Failed = 3] = "Failed", i4))(Ze || {});
y4();
w5();
x4();
y4();
w5();
x4();
var Gi = _4({ "@import": "https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&family=Sora:wght@600&display=swap", "*": { fontFamily: '"Rubik", Arial, Helvetica, sans-serif' } });
var { styled: E5, css: pc, getCssText: mc } = q3({ theme: { colors: { grey5: "#858494", grey6: "#191C20", teal: "#183C4A", primary: "#4940E0", primaryA50: "#4940e080", primaryA10: "#4940e01a", onPrimary: "#ffffff", gradientFrom: "#FF6848", gradientTo: "#4940E0" }, radii: { xl: "36px", lg: "12px", md: "10px", sm: "8px" } }, media: { smDown: "(max-width: 768px)" } });
var $i = Q2({ colors: { color: "#191c20", background: "#ffffff", buttonDefaultBg: "#f0edf9", buttonDefaultColor: "#183c4a", buttonNeutralBg: "#F1F2F2", buttonNeutralColor: "#191C20", buttonPrimaryBg: "#4940e0", buttonPrimaryColor: "#ffffff", buttonGradientFrom: "#FF6848", buttonGradientTo: "#4940E0", circleDefaultBg: "#f9f9f9", circleDefaultColor: "#4940e0", circlePrimaryBg: "#4940e0", circlePrimaryColor: "#ffffff", captchaColor: "#183c4a", captchaGradientFrom: "#FF6848", captchaGradientTo: "#4940E0", devButtonBg: "#f9f9f980", devButtonBorder: "#183c4a1a", loaderBg: "#f0edf9", loaderFg: "#4940e0", qrcode: "black", qrcodeBorder: "#4940e01a" } });
var ji = Q2({ colors: { color: "#ffffff", background: "#0c0e10", buttonDefaultBg: "#272b2f", buttonDefaultColor: "#858494", buttonNeutralBg: "#F1F2F21A", buttonNeutralColor: "#ffffff", buttonPrimaryBg: "#4940e0", buttonPrimaryColor: "#ffffff", buttonGradientFrom: "#FF6848", buttonGradientTo: "#4940E0", circleDefaultBg: "#ffffff1c", circleDefaultColor: "#ffffff", circlePrimaryBg: "#4940e0", circlePrimaryColor: "#ffffff", captchaColor: "#ffffff", captchaGradientFrom: "#FF6848", captchaGradientTo: "#4940E0", devButtonBg: "#ffffff1a", devButtonBorder: "#ffffff1a", loaderBg: "#101719", loaderFg: "#4940e0", qrcode: "white", qrcodeBorder: "#ffffff1c" } });
y4();
w5();
x4();
y4();
w5();
x4();
function Yi({ style: e5 }) {
  return f4.createElement("svg", { width: "42", height: "42", viewBox: "0 0 42 42", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M20.9728 13.1327C21.4192 11.2371 25.8349 6.49303 27.942 8.076C30.3946 9.97654 27.534 13.7923 26.5261 15.2678C26.5261 15.2678 26.3245 13.2255 24.7166 11.3739C23.4351 12.1995 22.2496 13.0301 21.5536 13.5284C21.4913 13.5702 21.4182 13.5923 21.3436 13.592C21.269 13.5917 21.1962 13.5691 21.1342 13.5268C21.0722 13.4846 21.0238 13.4246 20.9951 13.3545C20.9664 13.2844 20.9587 13.2073 20.9728 13.1327V13.1327ZM22.7727 15.9957C22.7195 16.0209 22.6733 16.059 22.6381 16.1067C22.603 16.1545 22.5799 16.2103 22.5711 16.2693C22.5543 16.3609 22.5716 16.4556 22.6194 16.5351C22.6673 16.6145 22.7425 16.673 22.8303 16.6993C23.6463 16.9436 25.0238 17.3735 26.4541 17.8816C26.0317 20.3147 24.5918 21.7462 24.5918 21.7462C26.3533 21.6289 31.0618 21.5361 30.9994 18.3946C30.9082 15.7319 24.5102 15.17 22.7727 15.9957ZM21.6928 19.2105C21.6252 19.1766 21.549 19.1645 21.4745 19.1759C21.4 19.1873 21.3306 19.2216 21.2758 19.2742C21.2209 19.3268 21.1832 19.3953 21.1677 19.4703C21.1521 19.5454 21.1595 19.6235 21.1888 19.6942C21.5056 20.4955 22.0384 21.8586 22.5375 23.3194C20.4017 24.4969 18.405 24.2379 18.405 24.2379C19.5905 25.5668 22.5951 29.2604 24.9662 27.2573C26.958 25.5277 23.4111 20.0802 21.6928 19.2105ZM18.549 20.3538C18.5369 20.2952 18.5109 20.2405 18.4732 20.1945C18.4356 20.1485 18.3874 20.1126 18.333 20.09C18.2491 20.0515 18.154 20.0467 18.0667 20.0766C17.9795 20.1065 17.9066 20.1689 17.8626 20.2512C17.4451 21.0036 16.7251 22.2739 15.914 23.5783C13.6821 22.611 12.6358 20.857 12.6358 20.857C12.3526 22.6305 11.3831 27.3257 14.4021 27.9706C16.9699 28.4787 18.9522 22.2592 18.549 20.3538V20.3538ZM15.7172 18.5558C15.7525 18.5093 15.7769 18.4552 15.7885 18.3976C15.8002 18.3401 15.7988 18.2805 15.7844 18.2236C15.7616 18.1325 15.7061 18.0533 15.6288 18.0018C15.5515 17.9502 15.458 17.93 15.3668 17.9451C14.5269 18.0819 13.1013 18.3018 11.5942 18.4679C10.9463 16.0837 11.6422 14.1636 11.6422 14.1636C10.1015 15.0381 5.89222 17.1927 7.27453 19.9922C8.48405 22.3569 14.4981 20.0606 15.7172 18.5558V18.5558ZM15.3284 15.1798C15.3871 15.1816 15.4454 15.1687 15.4981 15.1423C15.5508 15.1159 15.5963 15.0768 15.6308 15.0284C15.6859 14.9526 15.7116 14.8588 15.7027 14.7649C15.6938 14.6711 15.6511 14.5839 15.5828 14.5202C14.954 13.9388 13.8981 12.9422 12.8326 11.8429C14.2629 9.84463 16.1731 9.2046 16.1731 9.2046C14.5413 8.5206 10.2647 6.5028 8.97362 9.35605C7.90808 11.7891 13.4133 15.1505 15.3284 15.1798V15.1798ZM17.9922 12.9177C18.0842 12.9144 18.1718 12.8767 18.2382 12.8118C18.3046 12.7469 18.3452 12.6594 18.3522 12.566C18.405 11.7012 18.5202 10.2404 18.6978 8.70626C21.1264 8.59877 22.8063 9.72248 22.8063 9.72248C22.3167 7.99783 21.2032 3.33687 18.2082 4.07949C15.674 4.74883 16.5187 11.2273 17.685 12.776C17.7218 12.8225 17.7687 12.8595 17.8221 12.8841C17.8754 12.9087 17.9337 12.9202 17.9922 12.9177V12.9177Z", fill: "url(#paint0_linear_18_318)" }), f4.createElement("path", { d: "M1.85564 40L0.213594 34.1818H1.34712L2.39541 38.4574H2.44939L3.56871 34.1818H4.59996L5.72212 38.4602H5.77325L6.82155 34.1818H7.95507L6.31303 40H5.27325L4.10848 35.9176H4.06303L2.89541 40H1.85564ZM13.4923 37.0909C13.4923 37.7178 13.3748 38.2547 13.14 38.7017C12.907 39.1468 12.5889 39.4877 12.1854 39.7244C11.7839 39.9612 11.3284 40.0795 10.819 40.0795C10.3095 40.0795 9.85305 39.9612 9.44965 39.7244C9.04813 39.4858 8.72995 39.1439 8.4951 38.6989C8.26215 38.2519 8.14567 37.7159 8.14567 37.0909C8.14567 36.464 8.26215 35.928 8.4951 35.483C8.72995 35.036 9.04813 34.6941 9.44965 34.4574C9.85305 34.2206 10.3095 34.1023 10.819 34.1023C11.3284 34.1023 11.7839 34.2206 12.1854 34.4574C12.5889 34.6941 12.907 35.036 13.14 35.483C13.3748 35.928 13.4923 36.464 13.4923 37.0909ZM12.4326 37.0909C12.4326 36.6496 12.3635 36.2775 12.2252 35.9744C12.0889 35.6695 11.8995 35.4394 11.657 35.2841C11.4146 35.1269 11.1353 35.0483 10.819 35.0483C10.5027 35.0483 10.2233 35.1269 9.9809 35.2841C9.73847 35.4394 9.54813 35.6695 9.40987 35.9744C9.27351 36.2775 9.20533 36.6496 9.20533 37.0909C9.20533 37.5322 9.27351 37.9053 9.40987 38.2102C9.54813 38.5133 9.73847 38.7434 9.9809 38.9006C10.2233 39.0559 10.5027 39.1335 10.819 39.1335C11.1353 39.1335 11.4146 39.0559 11.657 38.9006C11.8995 38.7434 12.0889 38.5133 12.2252 38.2102C12.3635 37.9053 12.4326 37.5322 12.4326 37.0909ZM14.4087 40V34.1818H16.5905C17.0375 34.1818 17.4125 34.2595 17.7155 34.4148C18.0205 34.5701 18.2506 34.7879 18.4059 35.0682C18.5631 35.3466 18.6417 35.6714 18.6417 36.0426C18.6417 36.4157 18.5621 36.7396 18.403 37.0142C18.2458 37.2869 18.0138 37.4981 17.707 37.6477C17.4002 37.7955 17.0233 37.8693 16.5763 37.8693H15.0223V36.9943H16.4343C16.6956 36.9943 16.9097 36.9583 17.0763 36.8864C17.243 36.8125 17.3661 36.7055 17.4456 36.5653C17.5271 36.4233 17.5678 36.2491 17.5678 36.0426C17.5678 35.8362 17.5271 35.66 17.4456 35.5142C17.3642 35.3665 17.2401 35.2547 17.0735 35.179C16.9068 35.1013 16.6919 35.0625 16.4286 35.0625H15.4627V40H14.4087ZM17.4144 37.3636L18.8547 40H17.6786L16.2638 37.3636H17.4144ZM19.5318 40V34.1818H20.5858V39.1165H23.1483V40H19.5318ZM25.9547 40H23.9831V34.1818H25.9944C26.5721 34.1818 27.0683 34.2983 27.4831 34.5312C27.8998 34.7623 28.2198 35.0947 28.4433 35.5284C28.6668 35.9621 28.7785 36.4811 28.7785 37.0852C28.7785 37.6913 28.6658 38.2121 28.4405 38.6477C28.217 39.0833 27.8941 39.4176 27.4717 39.6506C27.0513 39.8835 26.5456 40 25.9547 40ZM25.0371 39.0881H25.9035C26.3088 39.0881 26.6469 39.0142 26.9177 38.8665C27.1886 38.7169 27.3922 38.4943 27.5285 38.1989C27.6649 37.9015 27.7331 37.5303 27.7331 37.0852C27.7331 36.6402 27.6649 36.2708 27.5285 35.9773C27.3922 35.6818 27.1905 35.4612 26.9234 35.3153C26.6583 35.1676 26.3287 35.0938 25.9348 35.0938H25.0371V39.0881ZM32.6583 34.1818V40H31.6043V34.1818H32.6583ZM35.6912 40H33.7196V34.1818H35.731C36.3087 34.1818 36.8049 34.2983 37.2196 34.5312C37.6363 34.7623 37.9564 35.0947 38.1799 35.5284C38.4034 35.9621 38.5151 36.4811 38.5151 37.0852C38.5151 37.6913 38.4024 38.2121 38.177 38.6477C37.9535 39.0833 37.6306 39.4176 37.2083 39.6506C36.7878 39.8835 36.2821 40 35.6912 40ZM34.7736 39.0881H35.6401C36.0454 39.0881 36.3835 39.0142 36.6543 38.8665C36.9251 38.7169 37.1287 38.4943 37.2651 38.1989C37.4015 37.9015 37.4696 37.5303 37.4696 37.0852C37.4696 36.6402 37.4015 36.2708 37.2651 35.9773C37.1287 35.6818 36.927 35.4612 36.66 35.3153C36.3948 35.1676 36.0653 35.0938 35.6714 35.0938H34.7736V39.0881Z", fill: "url(#paint1_linear_18_318)" }), f4.createElement("path", { d: "M37 3.20052L37 3.55052L37 3.20052ZM38 4.14231L37.65 4.14231L38 4.14231ZM35.65 4.14231C35.65 4.3356 35.8067 4.49231 36 4.49231C36.1933 4.49231 36.35 4.3356 36.35 4.14231L35.65 4.14231ZM37.7216 4.79431L37.4765 4.54451L37.4765 4.54451L37.7216 4.79431ZM36.65 5.86719C36.65 6.06049 36.8067 6.21719 37 6.21719C37.1933 6.21719 37.35 6.06049 37.35 5.86719L36.65 5.86719ZM37.0666 5.08203L37.0883 5.43136L37.0666 5.08203ZM37 5.15076L36.65 5.15076L37 5.15076ZM37 3.55052C37.3791 3.55052 37.65 3.83495 37.65 4.14231L38.35 4.14231C38.35 3.40939 37.7255 2.85052 37 2.85052L37 3.55052ZM37 2.85052C36.8255 2.85052 36.6523 2.88286 36.4901 2.94614L36.7445 3.59828C36.825 3.5669 36.9118 3.55052 37 3.55052L37 2.85052ZM36.4901 2.94614C36.3279 3.00943 36.1792 3.1027 36.0529 3.22157L36.5329 3.73116C36.5923 3.67512 36.6641 3.62965 36.7445 3.59828L36.4901 2.94614ZM36.0529 3.22157C35.9267 3.34048 35.8253 3.4828 35.7557 3.64099L36.3965 3.92281C36.4274 3.85247 36.4734 3.78715 36.5329 3.73116L36.0529 3.22157ZM35.7557 3.64099C35.6861 3.79924 35.65 3.96965 35.65 4.14231L36.35 4.14231C36.35 4.06761 36.3656 3.99309 36.3965 3.92281L35.7557 3.64099ZM37.65 4.14231C37.65 4.29458 37.5868 4.43618 37.4765 4.54451L37.9668 5.04411C38.2012 4.81401 38.35 4.49613 38.35 4.14231L37.65 4.14231ZM37.4765 4.54451C37.3687 4.65027 37.2175 4.72201 37.045 4.7327L37.0883 5.43136C37.4296 5.41021 37.7393 5.26734 37.9668 5.04411L37.4765 4.54451ZM37.35 5.86719L37.35 5.15076L36.65 5.15076L36.65 5.86719L37.35 5.86719ZM37.045 4.7327C36.8377 4.74555 36.65 4.91535 36.65 5.15076L37.35 5.15076C37.35 5.31253 37.2221 5.42307 37.0883 5.43136L37.045 4.7327Z", fill: "#5E54FF" }), f4.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M36.9968 6.59687C37.1899 6.59687 37.3477 6.75333 37.3477 6.94688C37.3477 7.14042 37.193 7.29687 37.0003 7.29687L36.9968 7.29687C36.8037 7.29687 36.6477 7.14042 36.6477 6.94687C36.6477 6.75332 36.8037 6.59687 36.9968 6.59687", fill: "#5E54FF" }), f4.createElement("circle", { cx: "36.9987", cy: "5.0026", r: "3.66667", stroke: "#5E54FF", strokeWidth: "0.7" }), f4.createElement("defs", null, f4.createElement("linearGradient", { id: "paint0_linear_18_318", x1: "7", y1: "15.9999", x2: "31", y2: "15.9999", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848", style: { stopColor: "var(--gradient-from)" } }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0", style: { stopColor: "var(--gradient-to)" } })), f4.createElement("linearGradient", { id: "paint1_linear_18_318", x1: "1.45287e-07", y1: "37", x2: "39", y2: "37", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848", style: { stopColor: "var(--gradient-from)" } }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0", style: { stopColor: "var(--gradient-to)" } }))));
}
function Ji({ style: e5 }) {
  return f4.createElement("svg", { width: "5.95em", height: "1em", viewBox: "0 0 119 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M39.3403 4.53948L36.4022 15.9712H34.4955L32.0081 8.10159L29.512 15.9712H27.6053L24.6672 4.53948H26.6432L28.7146 12.7557L30.9854 4.53948H33.0221L35.2928 12.7557L37.3642 4.53948H39.3403Z", fill: "currentColor" }), f4.createElement("path", { d: "M40.2417 10.2597C40.2417 6.5849 41.8537 4.29682 45.0431 4.29682C48.2326 4.29682 49.8273 6.5849 49.8273 10.2597C49.8273 13.9345 48.2066 16.2225 45.0431 16.2225C41.8797 16.2225 40.2417 13.9345 40.2417 10.2597ZM47.8512 10.2597C47.8512 8.82097 47.5392 6.12555 45.0431 6.12555C42.5471 6.12555 42.2177 8.82097 42.2177 10.2597C42.2177 11.6984 42.5384 14.3938 45.0431 14.3938C47.5479 14.3938 47.8512 11.6984 47.8512 10.2597Z", fill: "currentColor" }), f4.createElement("path", { d: "M57.8702 15.9712L55.6515 11.2997H53.6928V15.9712H51.7167V4.53948H55.7381C58.5116 4.53948 60.0456 5.40617 60.0456 7.85892C60.0456 9.68764 59.2483 10.667 57.7575 11.0744L60.063 15.9712H57.8702ZM53.6928 9.4623H55.6515C57.3329 9.4623 58.1042 9.03762 58.1042 7.91959C58.1042 6.80155 57.2895 6.38554 55.6515 6.38554H53.6928V9.4623Z", fill: "currentColor" }), f4.createElement("path", { d: "M62.1344 4.53948H64.1104V14.0991H69.7613V15.9712H62.1344V4.53948Z", fill: "currentColor" }), f4.createElement("path", { d: "M71.6247 4.53948H74.8748C78.2982 4.53948 80.5083 6.78422 80.5083 10.2943C80.5083 13.8044 78.2982 15.9712 74.8748 15.9712H71.6247V4.53948ZM75.0134 14.0991C77.1888 14.0991 78.5322 12.5304 78.5322 10.2943C78.5322 8.05826 77.1282 6.4202 75.0134 6.4202H73.6007V14.0991H75.0134Z", fill: "currentColor" }), f4.createElement("path", { d: "M82.155 10.225C82.155 6.6802 84.1311 4.34879 87.1992 4.34879C89.3832 4.34879 91.2466 5.53616 91.836 7.7809L89.9899 8.34425C89.6172 7.26955 89.0712 6.22952 87.1992 6.22952C85.3271 6.22952 84.1311 7.9109 84.1311 10.225C84.1311 12.539 85.2578 14.2898 87.1992 14.2898C89.1405 14.2898 89.7646 13.1284 90.0072 12.123L91.836 12.6951C91.2986 14.8965 89.5306 16.1705 87.1992 16.1705C84.1311 16.1705 82.155 13.8218 82.155 10.225Z", fill: "currentColor" }), f4.createElement("path", { d: "M93.422 10.2597C93.422 6.5849 95.0341 4.29682 98.2148 4.29682C101.396 4.29682 102.999 6.5849 102.999 10.2597C102.999 13.9345 101.387 16.2225 98.2148 16.2225C95.0427 16.2225 93.422 13.9345 93.422 10.2597ZM101.023 10.2597C101.023 8.82097 100.72 6.12555 98.2148 6.12555C95.7101 6.12555 95.3894 8.82097 95.3894 10.2597C95.3894 11.6984 95.7188 14.3938 98.2148 14.3938C100.711 14.3938 101.023 11.6984 101.023 10.2597Z", fill: "currentColor" }), f4.createElement("path", { d: "M105.313 4.53948H107.289V15.9712H105.313V4.53948Z", fill: "currentColor" }), f4.createElement("path", { d: "M118.062 4.53948V15.9712H116.086L111.64 8.52627V15.9712H109.673V4.53948H111.64L116.086 12.2531V4.53948H118.062Z", fill: "currentColor" }), f4.createElement("path", { d: "M11.9268 7.88491C11.9773 7.94369 12.0479 7.98158 12.1248 7.99119C12.2017 8.0008 12.2794 7.98145 12.3428 7.93691C12.9321 7.52089 13.9375 6.82754 15.0295 6.14285C15.8399 7.05468 16.3723 8.17949 16.5636 9.38429C17.4216 8.15358 19.8484 4.98148 17.7596 3.39543C15.9742 2.06939 12.2301 6.03018 11.8574 7.60756C11.8453 7.65593 11.8453 7.70654 11.8574 7.75492C11.8695 7.80329 11.8933 7.84794 11.9268 7.88491Z", fill: "currentColor" }), f4.createElement("path", { d: "M13.3828 9.99105C13.3267 10.0198 13.2802 10.0644 13.2493 10.1194C13.2184 10.1743 13.2043 10.2372 13.209 10.3001C13.2136 10.363 13.2367 10.4231 13.2753 10.473C13.3139 10.5229 13.3664 10.5602 13.4261 10.5804C14.1195 10.7884 15.2895 11.1438 16.5029 11.5684C16.296 12.7735 15.7452 13.8931 14.9169 14.7925C16.4162 14.6885 20.4117 14.6105 20.3597 11.9931C20.2817 9.77437 14.8562 9.30636 13.3828 9.99105Z", fill: "currentColor" }), f4.createElement("path", { d: "M12.4641 12.6778C12.4195 12.6563 12.3706 12.6451 12.3211 12.6451C12.2716 12.6451 12.2227 12.6563 12.1781 12.6778C12.1091 12.7148 12.056 12.7757 12.0289 12.8492C12.0017 12.9226 12.0024 13.0035 12.0308 13.0764C12.3081 13.7438 12.7588 14.8878 13.1748 16.1012C11.3634 17.0806 9.67335 16.8639 9.67335 16.8639C10.6787 17.9733 13.2268 21.05 15.2462 19.386C16.9276 17.9386 13.9202 13.3971 12.4641 12.6778Z", fill: "currentColor" }), f4.createElement("path", { d: "M9.79472 13.6225C9.78428 13.5743 9.76225 13.5294 9.73053 13.4916C9.69882 13.4539 9.65838 13.4244 9.61272 13.4058C9.54097 13.3748 9.4602 13.3718 9.38637 13.3975C9.31254 13.4232 9.25104 13.4756 9.21404 13.5445C8.8587 14.1685 8.25201 15.2259 7.55865 16.3179C6.43195 15.8447 5.46588 15.0562 4.77657 14.0472C4.53389 15.5292 3.7192 19.438 6.27594 19.9754C8.46001 20.4 10.1327 15.2172 9.79472 13.6225Z", fill: "currentColor" }), f4.createElement("path", { d: "M7.39396 12.1317C7.4232 12.0925 7.44309 12.0471 7.4521 11.9991C7.46111 11.951 7.45901 11.9015 7.44596 11.8544C7.42733 11.7776 7.3803 11.7108 7.31436 11.6674C7.24841 11.624 7.16846 11.6072 7.09061 11.6204C6.37992 11.733 5.17522 11.915 3.89251 12.0537C3.56429 10.878 3.57932 9.63299 3.93584 8.46559C2.62714 9.19361 -0.943641 10.9877 0.235063 13.3277C1.25776 15.2951 6.36259 13.3884 7.39396 12.1317Z", fill: "currentColor" }), f4.createElement("path", { d: "M7.0646 9.31496C7.11404 9.31612 7.16297 9.30482 7.2069 9.2821C7.25082 9.25938 7.28832 9.22598 7.31594 9.18496C7.36452 9.12436 7.388 9.04743 7.38155 8.97004C7.3751 8.89264 7.33921 8.82067 7.28127 8.76894C6.74392 8.2836 5.85123 7.45157 4.94987 6.53287C5.66301 5.54161 6.64708 4.77723 7.78396 4.33147C6.39725 3.76812 2.7658 2.08673 1.6651 4.46148C0.763735 6.48954 5.44388 9.28896 7.0646 9.31496Z", fill: "currentColor" }), f4.createElement("path", { d: "M9.31802 7.42555C9.39724 7.42366 9.47297 7.39251 9.53058 7.3381C9.5882 7.28368 9.62362 7.20986 9.63003 7.13087C9.67336 6.42018 9.7687 5.19814 9.9247 3.9241C11.1428 3.86314 12.3526 4.15506 13.4088 4.7648C12.9928 3.32609 12.0481 -0.556704 9.50869 0.0673157C7.35929 0.622 8.06998 6.0215 9.06668 7.31288C9.0957 7.3513 9.13395 7.38177 9.17789 7.40146C9.22183 7.42116 9.27002 7.42944 9.31802 7.42555Z", fill: "currentColor" }));
}
function Ge({ style: e5 }) {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 46 46", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M26.979 17.9748C27.0917 18.106 27.2493 18.1906 27.4209 18.212C27.5926 18.2335 27.7661 18.1903 27.9076 18.0909C29.2231 17.1623 31.4672 15.6147 33.9047 14.0864C35.7135 16.1216 36.9017 18.6323 37.3288 21.3215C39.244 18.5745 44.6607 11.4941 39.9985 7.95389C36.0133 4.99405 27.6561 13.8349 26.8243 17.3557C26.7972 17.4637 26.7972 17.5767 26.8241 17.6846C26.8511 17.7926 26.9043 17.8923 26.979 17.9748Z", fill: "url(#paint0_linear_7302_161195)" }), f4.createElement("path", { d: "M30.229 22.6759C30.1037 22.74 30 22.8396 29.931 22.9623C29.8619 23.085 29.8306 23.2253 29.841 23.3657C29.8513 23.5061 29.9028 23.6404 29.989 23.7516C30.0752 23.8629 30.1924 23.9463 30.3257 23.9914C31.8734 24.4556 34.485 25.2488 37.1933 26.1967C36.7314 28.8866 35.5021 31.3857 33.6532 33.3932C36.9999 33.1611 45.9181 32.9869 45.802 27.1446C45.6279 22.1922 33.5177 21.1476 30.229 22.6759Z", fill: "url(#paint1_linear_7302_161195)" }), f4.createElement("path", { d: "M28.1784 28.6729C28.0788 28.6249 27.9697 28.6 27.8592 28.6C27.7487 28.6 27.6395 28.6249 27.54 28.6729C27.386 28.7555 27.2675 28.8916 27.2069 29.0555C27.1464 29.2194 27.1478 29.3998 27.2111 29.5627C27.8302 31.0523 28.8361 33.6059 29.7647 36.3143C25.7215 38.5003 21.9492 38.0167 21.9492 38.0167C24.1932 40.4929 29.8808 47.3605 34.3882 43.6462C38.1412 40.4155 31.4284 30.2785 28.1784 28.6729Z", fill: "url(#paint2_linear_7302_161195)" }), f4.createElement("path", { d: "M22.2201 30.7816C22.1968 30.674 22.1476 30.5737 22.0768 30.4895C22.006 30.4052 21.9158 30.3395 21.8138 30.2979C21.6537 30.2287 21.4734 30.2221 21.3086 30.2794C21.1438 30.3367 21.0065 30.4538 20.924 30.6075C20.1308 32.0003 18.7766 34.3605 17.229 36.798C14.7141 35.7418 12.5577 33.9818 11.0191 31.7295C10.4775 35.0375 8.65899 43.7623 14.3659 44.9617C19.2409 45.9096 22.9746 34.3411 22.2201 30.7816Z", fill: "url(#paint3_linear_7302_161195)" }), f4.createElement("path", { d: "M16.8614 27.454C16.9266 27.3665 16.971 27.2652 16.9912 27.1579C17.0113 27.0506 17.0066 26.9402 16.9774 26.835C16.9359 26.6637 16.8309 26.5146 16.6837 26.4176C16.5365 26.3207 16.358 26.2832 16.1843 26.3126C14.598 26.5641 11.909 26.9704 9.04584 27.2799C8.31322 24.6557 8.34678 21.8767 9.14257 19.2709C6.22142 20.8959 -1.74887 24.9004 0.882103 30.1237C3.16486 34.5151 14.5593 30.2591 16.8614 27.454Z", fill: "url(#paint4_linear_7302_161195)" }), f4.createElement("path", { d: "M16.1262 21.1668C16.2366 21.1694 16.3458 21.1442 16.4438 21.0935C16.5419 21.0427 16.6256 20.9682 16.6872 20.8766C16.7957 20.7414 16.8481 20.5697 16.8337 20.3969C16.8193 20.2241 16.7392 20.0635 16.6099 19.948C15.4104 18.8647 13.4179 17.0075 11.406 14.9569C12.9978 12.7444 15.1943 11.0382 17.7319 10.0432C14.6366 8.78577 6.53092 5.03277 4.07406 10.3334C2.06214 14.8602 12.5086 21.1088 16.1262 21.1668Z", fill: "url(#paint5_linear_7302_161195)" }), f4.createElement("path", { d: "M21.156 16.9495C21.3329 16.9453 21.5019 16.8757 21.6305 16.7543C21.7591 16.6328 21.8382 16.468 21.8525 16.2917C21.9492 14.7054 22.162 11.9777 22.5102 9.13394C25.2291 8.99787 27.9294 9.64945 30.287 11.0104C29.3585 7.79911 27.2498 -0.867611 21.5816 0.525254C16.784 1.76336 18.3703 13.8155 20.595 16.698C20.6598 16.7837 20.7452 16.8517 20.8433 16.8957C20.9413 16.9397 21.0489 16.9582 21.156 16.9495Z", fill: "url(#paint6_linear_7302_161195)" }), f4.createElement("defs", null, f4.createElement("linearGradient", { id: "paint0_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint1_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint2_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint3_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint4_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint5_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" })), f4.createElement("linearGradient", { id: "paint6_linear_7302_161195", x1: "0.357422", y1: "22.6957", x2: "45.8032", y2: "22.6957", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#FF6848" }), f4.createElement("stop", { offset: "1", stopColor: "#4940E0" }))));
}
function zi() {
  return f4.createElement("svg", { width: "101", height: "100", viewBox: "0 0 101 100", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, f4.createElement("circle", { opacity: "0.1", cx: "50.5", cy: "50", r: "50", fill: "#191C20" }), f4.createElement("circle", { cx: "50.5", cy: "50", r: "30", fill: "url(#paint0_linear_10037_54628)" }), f4.createElement("mask", { id: "mask0_10037_54628", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "20", y: "20", width: "31", height: "60" }, f4.createElement("rect", { x: "20.5", y: "20", width: "30", height: "60", fill: "#C4C4C4" })), f4.createElement("g", { mask: "url(#mask0_10037_54628)" }, f4.createElement("circle", { cx: "50.5", cy: "50", r: "30", fill: "black" })), f4.createElement("path", { d: "M53.2555 46.4166C53.8546 44.0468 59.7817 38.1165 62.61 40.0953C65.9022 42.4711 62.0624 47.2411 60.7095 49.0855C60.7095 49.0855 60.4389 46.5326 58.2806 44.2179C56.5605 45.25 54.9692 46.2883 54.035 46.9113C53.9514 46.9635 53.8533 46.9911 53.7532 46.9907C53.653 46.9904 53.5552 46.962 53.472 46.9092C53.3888 46.8564 53.3239 46.7815 53.2853 46.6938C53.2468 46.6062 53.2364 46.5098 53.2555 46.4166ZM55.6714 49.9955C55.6 50.027 55.538 50.0746 55.4908 50.1343C55.4436 50.194 55.4127 50.2638 55.4008 50.3376C55.3783 50.4521 55.4014 50.5705 55.4657 50.6698C55.53 50.7691 55.6308 50.8422 55.7487 50.875C56.844 51.1804 58.693 51.7179 60.6128 52.353C60.0459 55.3946 58.1131 57.1841 58.1131 57.1841C60.4775 57.0375 66.7977 56.9214 66.7139 52.9943C66.5915 49.6657 58.0036 48.9634 55.6714 49.9955ZM54.2218 54.0143C54.1311 53.9718 54.0289 53.9567 53.9288 53.971C53.8288 53.9852 53.7357 54.0281 53.6621 54.0939C53.5885 54.1597 53.5379 54.2452 53.517 54.3391C53.4961 54.4329 53.506 54.5306 53.5454 54.6189C53.9706 55.6205 54.6857 57.3245 55.3557 59.1507C52.4888 60.6226 49.8087 60.2989 49.8087 60.2989C51.4 61.9601 55.433 66.5774 58.6157 64.0733C61.2893 61.9113 56.5283 55.1014 54.2218 54.0143ZM50.002 55.4434C49.9858 55.3702 49.9509 55.3018 49.9003 55.2443C49.8498 55.1868 49.7851 55.142 49.7121 55.1136C49.5994 55.0655 49.4718 55.0595 49.3547 55.0969C49.2376 55.1343 49.1397 55.2123 49.0807 55.3152C48.5202 56.2557 47.5538 57.8437 46.465 59.4744C43.4693 58.2651 42.0648 56.0725 42.0648 56.0725C41.6847 58.2895 40.3833 64.1588 44.4356 64.965C47.8824 65.6002 50.5432 57.8253 50.002 55.4434ZM46.2009 53.1959C46.2483 53.1377 46.2811 53.0701 46.2967 52.9981C46.3123 52.9261 46.3104 52.8517 46.2911 52.7806C46.2605 52.6666 46.186 52.5677 46.0822 52.5032C45.9785 52.4388 45.853 52.4135 45.7306 52.4324C44.6032 52.6034 42.6897 52.8783 40.6668 53.0859C39.797 50.1055 40.7312 47.7052 40.7312 47.7052C38.6631 48.7985 33.013 51.4919 34.8685 54.9915C36.492 57.9475 44.5645 55.077 46.2009 53.1959ZM45.6791 48.9756C45.7579 48.9778 45.8361 48.9617 45.9068 48.9287C45.9776 48.8957 46.0387 48.8468 46.0849 48.7863C46.159 48.6916 46.1934 48.5742 46.1815 48.4569C46.1696 48.3396 46.1122 48.2306 46.0205 48.1511C45.1765 47.4243 43.7592 46.1784 42.3289 44.8042C44.2488 42.3062 46.8129 41.5061 46.8129 41.5061C44.6225 40.6511 38.8822 38.1287 37.1491 41.6955C35.7189 44.737 43.1085 48.9389 45.6791 48.9756ZM49.2547 46.1478C49.3781 46.1437 49.4957 46.0965 49.5848 46.0154C49.6739 45.9343 49.7284 45.8249 49.7378 45.7081C49.8087 44.6271 49.9633 42.8009 50.2017 40.8832C53.4616 40.7488 55.7165 42.1535 55.7165 42.1535C55.0594 39.9976 53.5647 34.171 49.5446 35.0994C46.1429 35.9361 47.2768 44.0346 48.8423 45.9707C48.8917 46.0287 48.9547 46.075 49.0263 46.1058C49.0979 46.1365 49.1761 46.1509 49.2547 46.1478Z", fill: "white" }), f4.createElement("defs", null, f4.createElement("linearGradient", { id: "paint0_linear_10037_54628", x1: "50.5", y1: "20", x2: "50.5", y2: "80", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "#F66751" }), f4.createElement("stop", { offset: "1", stopColor: "#5743D6" }))));
}
y4();
w5();
x4();
var Qi = E5("div", {});
y4();
w5();
x4();
function Ki({ style: e5 }) {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M5.5 5.5L14.5 14.5M14.5 5.5L5.5 14.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }));
}
function Xi({ style: e5 }) {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M12.4647 15L7.5 10.0178L12.5 5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }));
}
function to() {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "none" }, f4.createElement("path", { d: "M6.5 6.5L17.5 17.5M17.5 6.5L6.5 17.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }));
}
function eo() {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "none" }, f4.createElement("path", { d: "M4 11.8438L9.66667 17.6875L21 6", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" }));
}
function $e({ style: e5 }) {
  return f4.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: Vt({ color: "#217237" }, e5) }, f4.createElement("rect", { x: "2", y: "2", width: "20", height: "20", rx: "10", fill: "currentColor" }), f4.createElement("path", { d: "M8.47175 12.0173C8.28035 11.8183 7.96383 11.812 7.76478 12.0034C7.56572 12.1948 7.55951 12.5114 7.75091 12.7104L8.47175 12.0173ZM10.4328 14.7782L10.0724 15.1248C10.166 15.2221 10.2951 15.2775 10.4301 15.2782C10.5652 15.2789 10.6949 15.2249 10.7895 15.1286L10.4328 14.7782ZM16.2458 9.57301C16.4393 9.376 16.4365 9.05943 16.2395 8.86593C16.0424 8.67244 15.7259 8.67529 15.5324 8.8723L16.2458 9.57301ZM7.75091 12.7104L10.0724 15.1248L10.7932 14.4317L8.47175 12.0173L7.75091 12.7104ZM10.7895 15.1286L16.2458 9.57301L15.5324 8.8723L10.0761 14.4279L10.7895 15.1286Z", fill: "white" }), f4.createElement("rect", { x: "2", y: "2", width: "20", height: "20", rx: "10", stroke: "currentColor" }));
}
function ro({ style: e5 }) {
  return f4.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: e5 }, f4.createElement("path", { d: "M6.78955 8.30273L3.00008 12.3027L6.78955 16.3027", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M17.2104 8.30273L20.9999 12.3027L17.2104 16.3027", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M13.8877 7.00045L9.87874 17.493", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }));
}
function no() {
  return f4.createElement("svg", { width: "27", height: "24", viewBox: "0 0 27 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, f4.createElement("path", { d: "M8.41406 15.4282C8.41406 12.8338 10.4899 10.7305 13.0504 10.7305C14.317 10.7305 15.4664 11.2454 16.3029 12.0812", stroke: "currentColor", strokeWidth: "0.428571", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M16.5013 10.5645L16.427 12.2439L14.8242 12.3429", stroke: "currentColor", strokeWidth: "0.428571", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M17.7658 15.3105C17.7658 17.905 15.69 20.0083 13.1295 20.0083C11.8629 20.0083 10.7135 19.4933 9.87695 18.6576", stroke: "currentColor", strokeWidth: "0.428571", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M9.67969 20.169L9.75396 18.4896L11.3567 18.3945", stroke: "currentColor", strokeWidth: "0.428571", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M3.10395 6.3074C3.70933 6.3074 4.20008 5.80661 4.20008 5.18885C4.20008 4.5711 3.70933 4.07031 3.10395 4.07031C2.49857 4.07031 2.00781 4.5711 2.00781 5.18885C2.00781 5.80661 2.49857 6.3074 3.10395 6.3074Z", fill: "currentColor" }), f4.createElement("path", { d: "M6.75629 6.3074C7.36167 6.3074 7.85243 5.80661 7.85243 5.18885C7.85243 4.5711 7.36167 4.07031 6.75629 4.07031C6.15091 4.07031 5.66016 4.5711 5.66016 5.18885C5.66016 5.80661 6.15091 6.3074 6.75629 6.3074Z", fill: "currentColor" }), f4.createElement("path", { d: "M10.4047 6.3074C11.0101 6.3074 11.5009 5.80661 11.5009 5.18885C11.5009 4.5711 11.0101 4.07031 10.4047 4.07031C9.79935 4.07031 9.30859 4.5711 9.30859 5.18885C9.30859 5.80661 9.79935 6.3074 10.4047 6.3074Z", fill: "currentColor" }), f4.createElement("path", { d: "M0.214286 3.25424C0.214286 1.57532 1.57532 0.214286 3.25424 0.214286H22.9287C24.6077 0.214286 25.9687 1.57532 25.9687 3.25424V8.38988H0.214286V3.25424Z", stroke: "currentColor", strokeWidth: "0.428571" }), f4.createElement("path", { d: "M0.214286 8.36468H25.9687V20.7459C25.9687 22.4249 24.6077 23.7859 22.9287 23.7859H3.25424C1.57532 23.7859 0.214286 22.4249 0.214286 20.7459V8.36468Z", stroke: "currentColor", strokeWidth: "0.428571" }));
}
function io() {
  return f4.createElement("svg", { width: "24", height: "34", viewBox: "0 0 24 34", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, f4.createElement("rect", { x: "0.186567", y: "0.186567", width: "23.6269", height: "33.5092", rx: "2.79851", stroke: "currentColor", strokeWidth: "0.373134" }), f4.createElement("path", { d: "M4.18896 0H19.8156L18.509 2.80667C18.2423 3.38318 17.661 3.75234 17.0316 3.75234H6.98363C6.34897 3.75234 5.77297 3.38318 5.5063 2.80667L4.19963 0H4.18896Z", fill: "currentColor" }), f4.createElement("path", { d: "M6.28223 30.8496H18.2556", stroke: "currentColor", strokeWidth: "0.746269", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M13.0664 15.9833C13.2516 15.1847 15.1171 13.1905 16.0105 13.8553C17.0474 14.6538 15.8392 16.2649 15.4133 16.8834C15.4133 16.8834 15.33 16.0248 14.6495 15.2447C14.1079 15.5909 13.608 15.9417 13.3117 16.1495C13.2886 16.1633 13.2562 16.1772 13.2238 16.1772C13.1914 16.1772 13.159 16.1633 13.1358 16.1495C13.1081 16.131 13.0895 16.1079 13.0757 16.0756C13.0664 16.0433 13.0618 16.011 13.071 15.9833H13.0664ZM13.8256 17.1881C13.8256 17.1881 13.7839 17.2158 13.7746 17.2343C13.7608 17.2527 13.7515 17.2758 13.7469 17.3035C13.7376 17.3404 13.7469 17.382 13.7654 17.4189C13.7839 17.4558 13.8163 17.4789 13.8533 17.4882C14.1959 17.5897 14.7838 17.7743 15.3856 17.9867C15.205 19.0115 14.5986 19.6162 14.5986 19.6162C15.3439 19.5654 17.3298 19.5285 17.302 18.2083C17.265 17.0866 14.5616 16.8511 13.8302 17.1973V17.1881H13.8256ZM13.3673 18.5406C13.3395 18.5268 13.3071 18.5222 13.2747 18.5268C13.2469 18.5268 13.2145 18.5452 13.196 18.5683C13.1729 18.5914 13.159 18.6191 13.1497 18.6514C13.1451 18.6837 13.1497 18.716 13.159 18.7437C13.2886 19.0807 13.5201 19.6531 13.7284 20.2717C12.8257 20.7656 11.9832 20.6594 11.9832 20.6594C12.4831 21.218 13.7515 22.7736 14.756 21.9335C15.5985 21.2041 14.0987 18.9099 13.3719 18.5452L13.3673 18.5406ZM12.0388 19.0207C12.0388 18.9976 12.0249 18.9745 12.0063 18.9561C11.9925 18.9376 11.9739 18.9192 11.9508 18.9145C11.9184 18.9007 11.8767 18.8961 11.8397 18.9145C11.8027 18.9284 11.7749 18.9515 11.7518 18.9884C11.5758 19.3069 11.2703 19.8378 10.9324 20.3917C9.98808 19.9855 9.54369 19.2423 9.54369 19.2423C9.42333 19.9901 9.01598 21.9658 10.2936 22.2381C11.3768 22.4551 12.2147 19.8331 12.0434 19.0299L12.0388 19.0207ZM10.8445 18.2637C10.8445 18.2637 10.8676 18.2221 10.8769 18.199C10.8769 18.176 10.8769 18.1483 10.8769 18.1252C10.8676 18.0882 10.8445 18.0559 10.8121 18.0329C10.7796 18.0098 10.7426 18.0005 10.7056 18.0098C10.3491 18.0698 9.74737 18.1575 9.10856 18.2267C8.83544 17.225 9.12708 16.4172 9.12708 16.4172C8.47901 16.7819 6.70145 17.6959 7.28471 18.873C7.79391 19.8701 10.3353 18.9007 10.8491 18.2683L10.8445 18.2637ZM10.6824 16.8419C10.6824 16.8419 10.7334 16.8419 10.7519 16.828C10.775 16.8142 10.7935 16.8004 10.8028 16.7819C10.8259 16.7496 10.8398 16.7126 10.8352 16.6711C10.8352 16.6342 10.8121 16.5972 10.7843 16.5695C10.5204 16.3249 10.0714 15.9048 9.62239 15.4432C10.2242 14.5985 11.0342 14.3307 11.0342 14.3307C10.3445 14.0399 8.53919 13.1952 7.99296 14.3953C7.54394 15.4201 9.86773 16.8373 10.6732 16.8465H10.6778L10.6824 16.8419ZM11.8073 15.891C11.8443 15.891 11.8814 15.8771 11.9138 15.8494C11.9415 15.8217 11.9601 15.7848 11.9601 15.7433C11.9832 15.3786 12.0295 14.7646 12.1036 14.1184C13.1312 14.0722 13.8348 14.5477 13.8348 14.5477C13.6265 13.8229 13.159 11.8565 11.8953 12.1704C10.8259 12.452 11.1824 15.1801 11.6777 15.831C11.6916 15.8494 11.7101 15.8679 11.7379 15.8771C11.761 15.891 11.7842 15.891 11.8073 15.891Z", fill: "currentColor" }));
}
function oo() {
  return f4.createElement("svg", { width: "24", height: "22", viewBox: "0 0 24 22", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, f4.createElement("path", { d: "M2.84313 5.78299C3.39803 5.78299 3.84787 5.32396 3.84787 4.75771C3.84787 4.19146 3.39803 3.73242 2.84313 3.73242C2.28822 3.73242 1.83838 4.19146 1.83838 4.75771C1.83838 5.32396 2.28822 5.78299 2.84313 5.78299Z", fill: "currentColor" }), f4.createElement("path", { d: "M6.18932 5.78299C6.74422 5.78299 7.19406 5.32396 7.19406 4.75771C7.19406 4.19146 6.74422 3.73242 6.18932 3.73242C5.63441 3.73242 5.18457 4.19146 5.18457 4.75771C5.18457 5.32396 5.63441 5.78299 6.18932 5.78299Z", fill: "currentColor" }), f4.createElement("path", { d: "M9.536 5.78299C10.0909 5.78299 10.5407 5.32396 10.5407 4.75771C10.5407 4.19146 10.0909 3.73242 9.536 3.73242C8.98109 3.73242 8.53125 4.19146 8.53125 4.75771C8.53125 5.32396 8.98109 5.78299 9.536 5.78299Z", fill: "currentColor" }), f4.createElement("path", { d: "M6.146 21.7905V16.8094L8.33447 14.5762", stroke: "currentColor", strokeWidth: "0.40678", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M23.7965 13.0762H18.2074L15.4819 15.8615", stroke: "currentColor", strokeWidth: "0.40678", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M3.87354 21.7926V13.8477", stroke: "currentColor", strokeWidth: "0.40678", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M14.7693 17.8505C15.4994 17.8505 16.0913 17.2465 16.0913 16.5014C16.0913 15.7563 15.4994 15.1523 14.7693 15.1523C14.0392 15.1523 13.4473 15.7563 13.4473 16.5014C13.4473 17.2465 14.0392 17.8505 14.7693 17.8505Z", fill: "currentColor" }), f4.createElement("path", { d: "M8.6692 15.7743C9.39934 15.7743 9.99124 15.1703 9.99124 14.4252C9.99124 13.6802 9.39934 13.0762 8.6692 13.0762C7.93906 13.0762 7.34717 13.6802 7.34717 14.4252C7.34717 15.1703 7.93906 15.7743 8.6692 15.7743Z", fill: "currentColor" }), f4.createElement("path", { d: "M3.87086 14.1141C4.601 14.1141 5.1929 13.5101 5.1929 12.7651C5.1929 12.02 4.601 11.416 3.87086 11.416C3.14072 11.416 2.54883 12.02 2.54883 12.7651C2.54883 13.5101 3.14072 14.1141 3.87086 14.1141Z", fill: "currentColor" }), f4.createElement("path", { d: "M16.4817 11.3934C17.2118 11.3934 17.8037 10.7894 17.8037 10.0444C17.8037 9.29931 17.2118 8.69531 16.4817 8.69531C15.7516 8.69531 15.1597 9.29931 15.1597 10.0444C15.1597 10.7894 15.7516 11.3934 16.4817 11.3934Z", fill: "currentColor" }), f4.createElement("path", { d: "M23.5951 10.0449H17.4121", stroke: "currentColor", strokeWidth: "0.40678", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M0.20339 3.25424C0.20339 1.5693 1.5693 0.20339 3.25424 0.20339H20.7458C22.4307 0.20339 23.7966 1.5693 23.7966 3.25424V7.68342H0.20339V3.25424Z", stroke: "currentColor", strokeWidth: "0.40678" }), f4.createElement("path", { d: "M0.20339 7.67409H23.7966V18.7448C23.7966 20.4297 22.4307 21.7956 20.7458 21.7956H3.25424C1.5693 21.7956 0.20339 20.4297 0.20339 18.7448V7.67409Z", stroke: "currentColor", strokeWidth: "0.40678" }));
}
function so() {
  return f4.createElement("svg", { width: "24", height: "34", viewBox: "0 0 24 34", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, f4.createElement("mask", { id: "path-1-inside-1_1_2", fill: "white" }, f4.createElement("path", { d: "M2 2.98507C2 1.33646 3.33646 0 4.98507 0H21.0149C22.6635 0 24 1.33646 24 2.98507V29.0149C24 30.6635 22.6635 32 21.0149 32H4.98507C3.33646 32 2 30.6635 2 29.0149V2.98507Z" })), f4.createElement("path", { d: "M2 2.98507C2 1.13039 3.50352 -0.373134 5.35821 -0.373134H21.0149C22.8696 -0.373134 24.3731 1.13039 24.3731 2.98507L23.6269 2.98507C23.6269 1.54254 22.4575 0.373134 21.0149 0.373134H4.98507C3.33646 0.373134 2 1.54254 2 2.98507V2.98507ZM24 32H2H24ZM2 32V0V32ZM21.0149 -0.373134C22.8696 -0.373134 24.3731 1.13039 24.3731 2.98507V28.6418C24.3731 30.4965 22.8696 32 21.0149 32H21.0149C22.4575 32 23.6269 30.6635 23.6269 29.0149V2.98507C23.6269 1.54254 22.4575 0.373134 21.0149 0.373134L21.0149 -0.373134Z", fill: "currentColor", mask: "url(#path-1-inside-1_1_2)" }), f4.createElement("rect", { x: "0.186567", y: "2.18094", width: "21.6256", height: "31.5143", rx: "2.79851", stroke: "currentColor", strokeWidth: "0.373134" }), f4.createElement("path", { d: "M4.31041 29.3963L18.3096 29.3963", stroke: "currentColor", strokeWidth: "0.500014", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M4.00253 25.2407C6.08571 26.3698 9.8664 21.4706 7.8895 20.5345C7.44007 20.3222 6.9208 20.438 6.51996 20.7436C4.04201 22.6415 8.96146 26.4245 10.7592 24.2724C11.0659 23.9057 11.5487 23.8735 11.8311 24.2628C12.3474 24.9737 13.1643 25.1956 13.9629 24.5909C14.2757 24.3528 14.6917 24.3561 15.0075 24.5909C15.9246 25.2825 17.4005 25.5527 18.0017 24.4976", stroke: "currentColor", strokeWidth: "0.500014", strokeMiterlimit: "10", strokeLinecap: "round" }), f4.createElement("path", { d: "M4.31041 10.9598H18.3096", stroke: "currentColor", strokeWidth: "0.500014", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M4.31041 13.4505H18.3096", stroke: "currentColor", strokeWidth: "0.500014", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("path", { d: "M4.31041 15.9458H18.3096", stroke: "currentColor", strokeWidth: "0.500014", strokeLinecap: "round", strokeLinejoin: "round" }));
}
y4();
w5();
x4();
y4();
w5();
x4();
function E0(e5) {
  return { name: "telemetry-error", error: e5 };
}
typeof globalThis < "u" && (globalThis.onunhandledrejection = function(e5) {
  return e5.reason.name !== "telemetry-error";
});
async function k0(e5, t5) {
  try {
    return await fetch(e5, t5);
  } catch (r5) {
    throw E0(r5);
  }
}
var ye = (0, import_posthog_js_lite.createInternalPostHogInstance)("phc_QttqgDbMQDYHX1EMH7FnT6ECBVzdp0kGUq92aQaVQ6I", { fetch: k0 }, globalThis);
var be = { version: "0.5.0", package: "world-id-js" };
var ao = (e5) => {
  e5 ? ye.capture("wid loaded", be) : ye.optOut();
};
var fo = () => {
  ye.capture("wid opened", be);
};
var uo = (e5) => {
  ye.capture("wid connection established", Vt({ lead_time_seconds: e5 }, be));
};
var co = () => {
  ye.capture("wid verification success", be);
};
var lo = (e5) => {
  ye.capture("wid verification failed", Vt({ error_code: e5 }, be));
};
var Et = kea([path(["logic", "widgetLogic"]), props({}), actions({ processProps: (e5) => ({ props: e5 }), disableWidget: true, enableWidget: true, initWidget: true, unInitWidget: true, finishWidgetLoading: true, activateModal: true, disableModal: true, toggleModal: true, initTelemetry: true, setModalView: (e5) => ({ view: e5 }), setQrCodeContent: (e5) => ({ content: e5 }), setIsDevMode: (e5) => ({ isDev: e5 }) }), reducers({ isWidgetInitialized: [false, { initWidget: () => true, unInitWidget: () => false }], isWidgetEnabled: [false, { enableWidget: () => true, disableWidget: () => false }], widgetLoading: [true, { finishWidgetLoading: () => false }], qrCodeContent: [null, { setQrCodeContent: (e5, { content: t5 }) => t5 }], isDevMode: [false, { setIsDevMode: (e5, { isDev: t5 }) => t5 }], isModalVisible: [false, { activateModal: () => true, disableModal: () => false, toggleModal: (e5) => !e5 }], modalView: [0, { setModalView: (e5, { view: t5 }) => t5 }] }), listeners2(({ actions: e5 }) => ({ processProps: async ({ props: t5 }) => {
  let { valid: r5, error: o4 } = Xr(t5);
  !r5 && t5.debug && console.error(o4), r5 ? (e5.initWidget(), t5.signal ? e5.enableWidget() : e5.disableWidget()) : e5.unInitWidget(), ao(t5.enable_telemetry);
} })), propsChanged(({ actions: e5, props: t5 }) => {
  e5.processProps(t5);
}), events(({ actions: e5, props: t5 }) => ({ afterMount: () => {
  e5.processProps(t5), e5.setIsDevMode(typeof globalThis < "u" ? globalThis.location.hostname === "localhost" : false);
} }))]);
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
var wo = Zt(po());
var Rt = Zt(nn());
y4();
w5();
x4();
var j0 = function() {
  for (var e5 = 0, t5 = 0, r5 = arguments.length; t5 < r5; t5++)
    e5 += arguments[t5].length;
  for (var o4 = Array(e5), i4 = 0, t5 = 0; t5 < r5; t5++)
    for (var p5 = arguments[t5], m5 = 0, M4 = p5.length; m5 < M4; m5++, i4++)
      o4[i4] = p5[m5];
  return o4;
};
var Y0 = function() {
  function e5(t5, r5, o4) {
    this.name = t5, this.version = r5, this.os = o4, this.type = "browser";
  }
  return e5;
}();
var J0 = function() {
  function e5(t5) {
    this.version = t5, this.type = "node", this.name = "node", this.os = process.platform;
  }
  return e5;
}();
var z0 = function() {
  function e5(t5, r5, o4, i4) {
    this.name = t5, this.version = r5, this.os = o4, this.bot = i4, this.type = "bot-device";
  }
  return e5;
}();
var Q0 = function() {
  function e5() {
    this.type = "bot", this.bot = true, this.name = "bot", this.version = null, this.os = null;
  }
  return e5;
}();
var K0 = function() {
  function e5() {
    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
  }
  return e5;
}();
var X0 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var t1 = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var mo = 3;
var e1 = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FBAV\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["searchbot", X0]];
var go = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function yo(e5) {
  return e5 ? vo(e5) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new K0() : typeof navigator < "u" ? vo(navigator.userAgent) : i1();
}
function r1(e5) {
  return e5 !== "" && e1.reduce(function(t5, r5) {
    var o4 = r5[0], i4 = r5[1];
    if (t5)
      return t5;
    var p5 = i4.exec(e5);
    return !!p5 && [o4, p5];
  }, false);
}
function vo(e5) {
  var t5 = r1(e5);
  if (!t5)
    return null;
  var r5 = t5[0], o4 = t5[1];
  if (r5 === "searchbot")
    return new Q0();
  var i4 = o4[1] && o4[1].split(/[._]/).slice(0, 3);
  i4 ? i4.length < mo && (i4 = j0(i4, o1(mo - i4.length))) : i4 = [];
  var p5 = i4.join("."), m5 = n1(e5), M4 = t1.exec(e5);
  return M4 && M4[1] ? new z0(r5, p5, m5, M4[1]) : new Y0(r5, p5, m5);
}
function n1(e5) {
  for (var t5 = 0, r5 = go.length; t5 < r5; t5++) {
    var o4 = go[t5], i4 = o4[0], p5 = o4[1], m5 = p5.exec(e5);
    if (m5)
      return i4;
  }
  return null;
}
function i1() {
  var e5 = typeof process < "u" && process.version;
  return e5 ? new J0(process.version.slice(1)) : null;
}
function o1(e5) {
  for (var t5 = [], r5 = 0; r5 < e5; r5++)
    t5.push("0");
  return t5;
}
function Ye(e5) {
  return yo(e5);
}
function on3() {
  let e5 = Ye();
  return e5 && e5.os ? e5.os : void 0;
}
function s1() {
  let e5 = on3();
  return e5 ? e5.toLowerCase().includes("android") : false;
}
function a1() {
  let e5 = on3();
  return e5 ? e5.toLowerCase().includes("ios") || e5.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function xo() {
  return on3() ? s1() || a1() : false;
}
function f1() {
  let e5 = Ye();
  return e5 && e5.name ? e5.name.toLowerCase() === "node" : false;
}
function Co() {
  return !f1() && !!u1();
}
var u1 = Rt.getNavigator;
var _o = Rt.getLocation;
var Je = Rt.getLocalStorage;
function sn() {
  return wo.getWindowMetadata();
}
y4();
w5();
x4();
y4();
w5();
x4();
function Mo(e5) {
  if (typeof e5 != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof e5}`);
  try {
    return JSON.parse(e5);
  } catch (t5) {
    return e5;
  }
}
function So(e5) {
  return typeof e5 == "string" ? e5 : JSON.stringify(e5);
}
var bo = Mo;
var Eo = So;
y4();
w5();
x4();
function an(e5, t5) {
  let r5 = Eo(t5), o4 = Je();
  o4 && o4.setItem(e5, r5);
}
function ze(e5) {
  let t5 = null, r5 = null, o4 = Je();
  return o4 && (r5 = o4.getItem(e5)), t5 = r5 && bo(r5), t5;
}
function Qe(e5) {
  let t5 = Je();
  t5 && t5.removeItem(e5);
}
y4();
w5();
x4();
var fn = "WALLETCONNECT_DEEPLINK_CHOICE";
y4();
w5();
x4();
y4();
w5();
x4();
var ko = ["session_request", "session_update", "exchange_key", "connect", "disconnect", "display_uri", "modal_closed", "transport_open", "transport_close", "transport_error"];
var Ke = ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "eth_signTypedData", "eth_signTypedData_v1", "eth_signTypedData_v2", "eth_signTypedData_v3", "eth_signTypedData_v4", "personal_sign", "wallet_addEthereumChain", "wallet_switchEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
y4();
w5();
x4();
var Zo = Zt(Ao());
y4();
w5();
x4();
var p1 = Zt(ln());
var Po = Zt(Do());
var Uo = "hex";
var Ho = "utf8";
var Xe = "0";
function ee2(e5) {
  return new Uint8Array(e5);
}
function hn(e5, t5 = false) {
  let r5 = e5.toString(Uo);
  return t5 ? Qt(r5) : r5;
}
function No(e5) {
  return e5.toString(Ho);
}
function xe(e5) {
  return (0, Po.default)(e5);
}
function re2(e5, t5 = false) {
  return hn(xe(e5), t5);
}
function dn(e5) {
  return No(xe(e5));
}
function Wo(e5) {
  return v4.from(Ft(e5), Uo);
}
function ne(e5) {
  return ee2(Wo(e5));
}
function tr(e5) {
  return v4.from(e5, Ho);
}
function pn(e5) {
  return ee2(tr(e5));
}
function Fo(e5, t5 = false) {
  return hn(tr(e5), t5);
}
function qo(e5, t5) {
  return !(typeof e5 != "string" || !e5.match(/^0x[0-9A-Fa-f]*$/) || t5 && e5.length !== 2 + 2 * t5);
}
function mn(...e5) {
  let t5 = [];
  return e5.forEach((r5) => t5 = t5.concat(Array.from(r5))), new Uint8Array([...t5]);
}
function m1(e5, t5 = 8) {
  let r5 = e5 % t5;
  return r5 ? (e5 - r5) / t5 * t5 + t5 : e5;
}
function g1(e5, t5 = 8, r5 = Xe) {
  return v1(e5, m1(e5.length, t5), r5);
}
function v1(e5, t5, r5 = Xe) {
  return y1(e5, t5, true, r5);
}
function Ft(e5) {
  return e5.replace(/^0x/, "");
}
function Qt(e5) {
  return e5.startsWith("0x") ? e5 : `0x${e5}`;
}
function er(e5) {
  return e5 = Ft(e5), e5 = g1(e5, 2), e5 && (e5 = Qt(e5)), e5;
}
function Vo(e5) {
  let t5 = e5.startsWith("0x");
  return e5 = Ft(e5), e5 = e5.startsWith(Xe) ? e5.substring(1) : e5, t5 ? Qt(e5) : e5;
}
function y1(e5, t5, r5, o4 = Xe) {
  let i4 = t5 - e5.length, p5 = e5;
  if (i4 > 0) {
    let m5 = o4.repeat(i4);
    p5 = r5 ? m5 + e5 : e5 + m5;
  }
  return p5;
}
function nr(e5) {
  return xe(new Uint8Array(e5));
}
function Go(e5, t5) {
  return re2(new Uint8Array(e5), !t5);
}
function $o(e5) {
  return ee2(e5).buffer;
}
function jo(e5) {
  return tr(e5);
}
function Yo(e5, t5) {
  return Fo(e5, !t5);
}
function Jo(e5) {
  return ne(e5).buffer;
}
function ir(e5, t5) {
  let r5 = Ft(er(new Zo.default(e5).toString(16)));
  return t5 ? r5 : Qt(r5);
}
y4();
w5();
x4();
y4();
w5();
x4();
var Ot = {};
ve(Ot, { DEFAULT_ERROR: () => ke, IBaseJsonRpcProvider: () => dr, IEvents: () => _e, IJsonRpcConnection: () => yn, IJsonRpcProvider: () => wn, INTERNAL_ERROR: () => or, INVALID_PARAMS: () => Xo, INVALID_REQUEST: () => Qo, METHOD_NOT_FOUND: () => Ko, PARSE_ERROR: () => zo, RESERVED_ERROR_CODES: () => gn, SERVER_ERROR: () => Ee, SERVER_ERROR_CODE_RANGE: () => sr, STANDARD_ERROR_MAP: () => ie, formatErrorMessage: () => us, formatJsonRpcError: () => k1, formatJsonRpcRequest: () => b1, formatJsonRpcResult: () => E1, getError: () => fr, getErrorByCode: () => ur, isHttpUrl: () => B1, isJsonRpcError: () => hs, isJsonRpcPayload: () => xn, isJsonRpcRequest: () => U1, isJsonRpcResponse: () => H1, isJsonRpcResult: () => ls, isJsonRpcValidationInvalid: () => N1, isLocalhostUrl: () => P1, isNodeJs: () => fs, isReservedErrorCode: () => ar, isServerErrorCode: () => w1, isValidDefaultRoute: () => lr, isValidErrorCode: () => ts, isValidLeadingWildcardRoute: () => I1, isValidRoute: () => T1, isValidTrailingWildcardRoute: () => A1, isValidWildcardRoute: () => hr, isWsUrl: () => D1, parseConnectionError: () => C1, payloadId: () => cr, validateJsonRpcError: () => x1 });
y4();
w5();
x4();
y4();
w5();
x4();
var zo = "PARSE_ERROR";
var Qo = "INVALID_REQUEST";
var Ko = "METHOD_NOT_FOUND";
var Xo = "INVALID_PARAMS";
var or = "INTERNAL_ERROR";
var Ee = "SERVER_ERROR";
var gn = [-32700, -32600, -32601, -32602, -32603];
var sr = [-32e3, -32099];
var ie = { [zo]: { code: -32700, message: "Parse error" }, [Qo]: { code: -32600, message: "Invalid Request" }, [Ko]: { code: -32601, message: "Method not found" }, [Xo]: { code: -32602, message: "Invalid params" }, [or]: { code: -32603, message: "Internal error" }, [Ee]: { code: -32e3, message: "Server error" } };
var ke = Ee;
y4();
w5();
x4();
function w1(e5) {
  return e5 <= sr[0] && e5 >= sr[1];
}
function ar(e5) {
  return gn.includes(e5);
}
function ts(e5) {
  return typeof e5 == "number";
}
function fr(e5) {
  return Object.keys(ie).includes(e5) ? ie[e5] : ie[ke];
}
function ur(e5) {
  let t5 = Object.values(ie).find((r5) => r5.code === e5);
  return t5 || ie[ke];
}
function x1(e5) {
  if (typeof e5.error.code > "u")
    return { valid: false, error: "Missing code for JSON-RPC error" };
  if (typeof e5.error.message > "u")
    return { valid: false, error: "Missing message for JSON-RPC error" };
  if (!ts(e5.error.code))
    return { valid: false, error: `Invalid error code type for JSON-RPC: ${e5.error.code}` };
  if (ar(e5.error.code)) {
    let t5 = ur(e5.error.code);
    if (t5.message !== ie[ke].message && e5.error.message === t5.message)
      return { valid: false, error: `Invalid error code message for JSON-RPC: ${e5.error.code}` };
  }
  return { valid: true };
}
function C1(e5, t5, r5) {
  return e5.message.includes("getaddrinfo ENOTFOUND") || e5.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r5} RPC url at ${t5}`) : e5;
}
var Z3 = {};
ve(Z3, { isNodeJs: () => fs });
y4();
w5();
x4();
var as = Zt(Ce());
O3(Z3, Zt(Ce()));
var fs = as.isNode;
O3(Ot, Z3);
y4();
w5();
x4();
function cr() {
  let e5 = Date.now() * Math.pow(10, 3), t5 = Math.floor(Math.random() * Math.pow(10, 3));
  return e5 + t5;
}
function b1(e5, t5, r5) {
  return { id: r5 || cr(), jsonrpc: "2.0", method: e5, params: t5 };
}
function E1(e5, t5) {
  return { id: e5, jsonrpc: "2.0", result: t5 };
}
function k1(e5, t5, r5) {
  return { id: e5, jsonrpc: "2.0", error: us(t5, r5) };
}
function us(e5, t5) {
  return typeof e5 > "u" ? fr(or) : (typeof e5 == "string" && (e5 = Object.assign(Object.assign({}, fr(Ee)), { message: e5 })), typeof t5 < "u" && (e5.data = t5), ar(e5.code) && (e5 = ur(e5.code)), e5);
}
y4();
w5();
x4();
function T1(e5) {
  return e5.includes("*") ? hr(e5) : !/\W/g.test(e5);
}
function lr(e5) {
  return e5 === "*";
}
function hr(e5) {
  return lr(e5) ? true : !(!e5.includes("*") || e5.split("*").length !== 2 || e5.split("*").filter((t5) => t5.trim() === "").length !== 1);
}
function I1(e5) {
  return !lr(e5) && hr(e5) && !e5.split("*")[0].trim();
}
function A1(e5) {
  return !lr(e5) && hr(e5) && !e5.split("*")[1].trim();
}
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
var _e = class {
};
y4();
w5();
x4();
var yn = class extends _e {
  constructor(t5) {
    super();
  }
};
var dr = class extends _e {
  constructor() {
    super();
  }
};
var wn = class extends dr {
  constructor(t5) {
    super();
  }
};
y4();
w5();
x4();
y4();
w5();
x4();
var L1 = "^https?:";
var R1 = "^wss?:";
function O1(e5) {
  let t5 = e5.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t5 || !t5.length))
    return t5[0];
}
function cs(e5, t5) {
  let r5 = O1(e5);
  return typeof r5 > "u" ? false : new RegExp(t5).test(r5);
}
function B1(e5) {
  return cs(e5, L1);
}
function D1(e5) {
  return cs(e5, R1);
}
function P1(e5) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(e5);
}
y4();
w5();
x4();
function xn(e5) {
  return typeof e5 == "object" && "id" in e5 && "jsonrpc" in e5 && e5.jsonrpc === "2.0";
}
function U1(e5) {
  return xn(e5) && "method" in e5;
}
function H1(e5) {
  return xn(e5) && (ls(e5) || hs(e5));
}
function ls(e5) {
  return "result" in e5;
}
function hs(e5) {
  return "error" in e5;
}
function N1(e5) {
  return "error" in e5 && e5.valid === false;
}
function Te(e5) {
  return er(e5);
}
function ds(e5) {
  return Vo(Qt(e5));
}
var ps = cr;
function pr() {
  return ((t5, r5) => {
    for (r5 = t5 = ""; t5++ < 36; r5 += t5 * 51 & 52 ? (t5 ^ 15 ? 8 ^ Math.random() * (t5 ^ 20 ? 16 : 4) : 4).toString(16) : "-")
      ;
    return r5;
  })();
}
y4();
w5();
x4();
function ms(e5) {
  return e5 === "" || typeof e5 == "string" && e5.trim() === "";
}
function gs(e5) {
  return !(e5 && e5.length);
}
function Cn(e5, t5) {
  return qo(e5, t5);
}
function vs(e5) {
  return typeof e5.method < "u";
}
function me(e5) {
  return typeof e5.result < "u";
}
function Me(e5) {
  return typeof e5.error < "u";
}
function _n(e5) {
  return typeof e5.event < "u";
}
function ys(e5) {
  return ko.includes(e5) || e5.startsWith("wc_");
}
function ws(e5) {
  return e5.method.startsWith("wc_") ? true : !Ke.includes(e5.method);
}
function F1(e5) {
  e5 = Ft(e5.toLowerCase());
  let t5 = Ft((0, import_js_sha37.keccak_256)(jo(e5))), r5 = "";
  for (let o4 = 0; o4 < e5.length; o4++)
    parseInt(t5[o4], 16) > 7 ? r5 += e5[o4].toUpperCase() : r5 += e5[o4];
  return Qt(r5);
}
var q1 = (e5) => e5 ? e5.toLowerCase().substring(0, 2) !== "0x" ? false : /^(0x)?[0-9a-f]{40}$/i.test(e5) ? /^(0x)?[0-9a-f]{40}$/.test(e5) || /^(0x)?[0-9A-F]{40}$/.test(e5) ? true : e5 === F1(e5) : false : false;
function Mn(e5) {
  return !gs(e5) && !Cn(e5[0]) && (e5[0] = Yo(e5[0])), e5;
}
function mr(e5) {
  if (typeof e5.type < "u" && e5.type !== "0")
    return e5;
  if (typeof e5.from > "u" || !q1(e5.from))
    throw new Error("Transaction object must include a valid 'from' value.");
  function t5(i4) {
    let p5 = i4;
    return (typeof i4 == "number" || typeof i4 == "string" && !ms(i4)) && (Cn(i4) ? typeof i4 == "string" && (p5 = Te(i4)) : p5 = ir(i4)), typeof p5 == "string" && (p5 = ds(p5)), p5;
  }
  let r5 = { from: Te(e5.from), to: typeof e5.to > "u" ? void 0 : Te(e5.to), gasPrice: typeof e5.gasPrice > "u" ? "" : t5(e5.gasPrice), gas: typeof e5.gas > "u" ? typeof e5.gasLimit > "u" ? "" : t5(e5.gasLimit) : t5(e5.gas), value: typeof e5.value > "u" ? "" : t5(e5.value), nonce: typeof e5.nonce > "u" ? "" : t5(e5.nonce), data: typeof e5.data > "u" ? "" : Te(e5.data) || "0x" }, o4 = ["gasPrice", "gas", "value", "nonce"];
  return Object.keys(r5).forEach((i4) => {
    (typeof r5[i4] > "u" || typeof r5[i4] == "string" && !r5[i4].trim().length) && o4.includes(i4) && delete r5[i4];
  }), r5;
}
y4();
w5();
x4();
function xs(e5) {
  let t5 = e5.message || "Failed or Rejected Request", r5 = -32e3;
  if (e5 && !e5.code)
    switch (t5) {
      case "Parse error":
        r5 = -32700;
        break;
      case "Invalid request":
        r5 = -32600;
        break;
      case "Method not found":
        r5 = -32601;
        break;
      case "Invalid params":
        r5 = -32602;
        break;
      case "Internal error":
        r5 = -32603;
        break;
      default:
        r5 = -32e3;
        break;
    }
  return { code: r5, message: t5 };
}
y4();
w5();
x4();
y4();
w5();
x4();
var gr = Zt(Us());
function Hs(e5) {
  let t5 = e5.indexOf("?") !== -1 ? e5.indexOf("?") : void 0;
  return typeof t5 < "u" ? e5.substr(t5) : "";
}
function Ns(e5, t5) {
  let r5 = bn(e5);
  return r5 = Object.assign(Object.assign({}, r5), t5), e5 = Q1(r5), e5;
}
function bn(e5) {
  return gr.parse(e5);
}
function Q1(e5) {
  return gr.stringify(e5);
}
function Ws(e5) {
  return typeof e5.bridge < "u";
}
function Fs(e5) {
  let t5 = e5.indexOf(":"), r5 = e5.indexOf("?") !== -1 ? e5.indexOf("?") : void 0, o4 = e5.substring(0, t5), i4 = e5.substring(t5 + 1, r5);
  function p5(T5) {
    let D4 = "@", P4 = T5.split(D4);
    return { handshakeTopic: P4[0], version: parseInt(P4[1], 10) };
  }
  let m5 = p5(i4), M4 = typeof r5 < "u" ? e5.substr(r5) : "";
  function b3(T5) {
    let D4 = bn(T5);
    return { key: D4.key || "", bridge: D4.bridge || "" };
  }
  let R3 = b3(M4);
  return Object.assign(Object.assign({ protocol: o4 }, m5), R3);
}
y4();
w5();
x4();
y4();
w5();
x4();
var En = class {
  constructor() {
    this._eventEmitters = [], typeof globalThis < "u" && typeof globalThis.addEventListener < "u" && (globalThis.addEventListener("online", () => this.trigger("online")), globalThis.addEventListener("offline", () => this.trigger("offline")));
  }
  on(t5, r5) {
    this._eventEmitters.push({ event: t5, callback: r5 });
  }
  trigger(t5) {
    let r5 = [];
    t5 && (r5 = this._eventEmitters.filter((o4) => o4.event === t5)), r5.forEach((o4) => {
      o4.callback();
    });
  }
};
var qs = En;
var K1 = typeof globalThis.WebSocket < "u" ? globalThis.WebSocket : Zs();
var kn = class {
  constructor(t5) {
    if (this.opts = t5, this._queue = [], this._events = [], this._subscriptions = [], this._protocol = t5.protocol, this._version = t5.version, this._url = "", this._netMonitor = null, this._socket = null, this._nextSocket = null, this._subscriptions = t5.subscriptions || [], this._netMonitor = t5.netMonitor || new qs(), !t5.url || typeof t5.url != "string")
      throw new Error("Missing or invalid WebSocket url");
    this._url = t5.url, this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(t5) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(t5) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(t5) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(t5) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(t5) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(t5, r5, o4) {
    if (!r5 || typeof r5 != "string")
      throw new Error("Missing or invalid topic field");
    this._socketSend({ topic: r5, type: "pub", payload: t5, silent: !!o4 });
  }
  subscribe(t5) {
    this._socketSend({ topic: t5, type: "sub", payload: "", silent: true });
  }
  on(t5, r5) {
    this._events.push({ event: t5, callback: r5 });
  }
  _socketCreate() {
    if (this._nextSocket)
      return;
    let t5 = X1(this._url, this._protocol, this._version);
    if (this._nextSocket = new K1(t5), !this._nextSocket)
      throw new Error("Failed to create socket");
    this._nextSocket.onmessage = (r5) => this._socketReceive(r5), this._nextSocket.onopen = () => this._socketOpen(), this._nextSocket.onerror = (r5) => this._socketError(r5), this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null, this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose(), this._socket = this._nextSocket, this._nextSocket = null, this._queueSubscriptions(), this._pushQueue();
  }
  _socketClose() {
    this._socket && (this._socket.onclose = () => {
    }, this._socket.close());
  }
  _socketSend(t5) {
    let r5 = JSON.stringify(t5);
    this._socket && this._socket.readyState === 1 ? this._socket.send(r5) : (this._setToQueue(t5), this._socketCreate());
  }
  async _socketReceive(t5) {
    let r5;
    try {
      r5 = JSON.parse(t5.data);
    } catch (o4) {
      return;
    }
    if (this._socketSend({ topic: r5.topic, type: "ack", payload: "", silent: true }), this._socket && this._socket.readyState === 1) {
      let o4 = this._events.filter((i4) => i4.event === "message");
      o4 && o4.length && o4.forEach((i4) => i4.callback(r5));
    }
  }
  _socketError(t5) {
    let r5 = this._events.filter((o4) => o4.event === "error");
    r5 && r5.length && r5.forEach((o4) => o4.callback(t5));
  }
  _queueSubscriptions() {
    this._subscriptions.forEach((r5) => this._queue.push({ topic: r5, type: "sub", payload: "", silent: true })), this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(t5) {
    this._queue.push(t5);
  }
  _pushQueue() {
    this._queue.forEach((r5) => this._socketSend(r5)), this._queue = [];
  }
};
function X1(e5, t5, r5) {
  var o4, i4;
  let m5 = (e5.startsWith("https") ? e5.replace("https", "wss") : e5.startsWith("http") ? e5.replace("http", "ws") : e5).split("?"), M4 = Co() ? { protocol: t5, version: r5, env: "browser", host: ((o4 = _o()) === null || o4 === void 0 ? void 0 : o4.host) || "" } : { protocol: t5, version: r5, env: ((i4 = Ye()) === null || i4 === void 0 ? void 0 : i4.name) || "" }, b3 = Ns(Hs(m5[1] || ""), M4);
  return m5[0] + "?" + b3;
}
var Gs = kn;
y4();
w5();
x4();
var vr = "Session currently connected";
var fe = "Session currently disconnected";
var $s = "Session Rejected";
var js = "Missing JSON RPC response";
var Ys = 'JSON-RPC success response must include "result" field';
var Js = 'JSON-RPC error response must include "error" field';
var zs = 'JSON RPC request must have valid "method" value';
var Qs = 'JSON RPC request must have valid "id" value';
var Ks = "Missing one of the required parameters: bridge / uri / session";
var Tn = "JSON RPC response format is invalid";
var Xs = "URI format is invalid";
var ta = "QRCode Modal not provided";
var In = "User close QRCode Modal";
y4();
w5();
x4();
var An = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(t5) {
    this._eventEmitters.push(t5);
  }
  unsubscribe(t5) {
    this._eventEmitters = this._eventEmitters.filter((r5) => r5.event !== t5);
  }
  trigger(t5) {
    let r5 = [], o4;
    vs(t5) ? o4 = t5.method : me(t5) || Me(t5) ? o4 = `response:${t5.id}` : _n(t5) ? o4 = t5.event : o4 = "", o4 && (r5 = this._eventEmitters.filter((i4) => i4.event === o4)), (!r5 || !r5.length) && !ys(o4) && !_n(o4) && (r5 = this._eventEmitters.filter((i4) => i4.event === "call_request")), r5.forEach((i4) => {
      if (Me(t5)) {
        let p5 = new Error(t5.error.message);
        i4.callback(p5, null);
      } else
        i4.callback(null, t5);
    });
  }
};
var ea = An;
y4();
w5();
x4();
var Ln = class {
  constructor(t5 = "walletconnect") {
    this.storageId = t5;
  }
  getSession() {
    let t5 = null, r5 = ze(this.storageId);
    return r5 && Ws(r5) && (t5 = r5), t5;
  }
  setSession(t5) {
    return an(this.storageId, t5), t5;
  }
  removeSession() {
    Qe(this.storageId);
  }
};
var ra = Ln;
y4();
w5();
x4();
var tf = "walletconnect.org";
var ef = "abcdefghijklmnopqrstuvwxyz0123456789";
var na = ef.split("").map((e5) => `https://${e5}.bridge.walletconnect.org`);
function rf(e5) {
  let t5 = e5.indexOf("//") > -1 ? e5.split("/")[2] : e5.split("/")[0];
  return t5 = t5.split(":")[0], t5 = t5.split("?")[0], t5;
}
function nf(e5) {
  return rf(e5).split(".").slice(-2).join(".");
}
function of() {
  return Math.floor(Math.random() * na.length);
}
function sf() {
  return na[of()];
}
function af(e5) {
  return nf(e5) === tf;
}
function ia(e5) {
  return af(e5) ? sf() : e5;
}
var Rn = class {
  constructor(t5) {
    if (this.protocol = "wc", this.version = 1, this._bridge = "", this._key = null, this._clientId = "", this._clientMeta = null, this._peerId = "", this._peerMeta = null, this._handshakeId = 0, this._handshakeTopic = "", this._connected = false, this._accounts = [], this._chainId = 0, this._networkId = 0, this._rpcUrl = "", this._eventManager = new ea(), this._clientMeta = sn() || t5.connectorOpts.clientMeta || null, this._cryptoLib = t5.cryptoLib, this._sessionStorage = t5.sessionStorage || new ra(t5.connectorOpts.storageId), this._qrcodeModal = t5.connectorOpts.qrcodeModal, this._qrcodeModalOptions = t5.connectorOpts.qrcodeModalOptions, this._signingMethods = [...Ke, ...t5.connectorOpts.signingMethods || []], !t5.connectorOpts.bridge && !t5.connectorOpts.uri && !t5.connectorOpts.session)
      throw new Error(Ks);
    t5.connectorOpts.bridge && (this.bridge = ia(t5.connectorOpts.bridge)), t5.connectorOpts.uri && (this.uri = t5.connectorOpts.uri);
    let r5 = t5.connectorOpts.session || this._getStorageSession();
    r5 && (this.session = r5), this.handshakeId && this._subscribeToSessionResponse(this.handshakeId, "Session request rejected"), this._transport = t5.transport || new Gs({ protocol: this.protocol, version: this.version, url: this.bridge, subscriptions: [this.clientId] }), this._subscribeToInternalEvents(), this._initTransport(), t5.connectorOpts.uri && this._subscribeToSessionRequest(), t5.pushServerOpts && this._registerPushServer(t5.pushServerOpts);
  }
  set bridge(t5) {
    !t5 || (this._bridge = t5);
  }
  get bridge() {
    return this._bridge;
  }
  set key(t5) {
    if (!t5)
      return;
    let r5 = Jo(t5);
    this._key = r5;
  }
  get key() {
    return this._key ? Go(this._key, true) : "";
  }
  set clientId(t5) {
    !t5 || (this._clientId = t5);
  }
  get clientId() {
    let t5 = this._clientId;
    return t5 || (t5 = this._clientId = pr()), this._clientId;
  }
  set peerId(t5) {
    !t5 || (this._peerId = t5);
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(t5) {
  }
  get clientMeta() {
    let t5 = this._clientMeta;
    return t5 || (t5 = this._clientMeta = sn()), t5;
  }
  set peerMeta(t5) {
    this._peerMeta = t5;
  }
  get peerMeta() {
    return this._peerMeta;
  }
  set handshakeTopic(t5) {
    !t5 || (this._handshakeTopic = t5);
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(t5) {
    !t5 || (this._handshakeId = t5);
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    return this._formatUri();
  }
  set uri(t5) {
    if (!t5)
      return;
    let { handshakeTopic: r5, bridge: o4, key: i4 } = this._parseUri(t5);
    this.handshakeTopic = r5, this.bridge = o4, this.key = i4;
  }
  set chainId(t5) {
    this._chainId = t5;
  }
  get chainId() {
    return this._chainId;
  }
  set networkId(t5) {
    this._networkId = t5;
  }
  get networkId() {
    return this._networkId;
  }
  set accounts(t5) {
    this._accounts = t5;
  }
  get accounts() {
    return this._accounts;
  }
  set rpcUrl(t5) {
    this._rpcUrl = t5;
  }
  get rpcUrl() {
    return this._rpcUrl;
  }
  set connected(t5) {
  }
  get connected() {
    return this._connected;
  }
  set pending(t5) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return { connected: this.connected, accounts: this.accounts, chainId: this.chainId, bridge: this.bridge, key: this.key, clientId: this.clientId, clientMeta: this.clientMeta, peerId: this.peerId, peerMeta: this.peerMeta, handshakeId: this.handshakeId, handshakeTopic: this.handshakeTopic };
  }
  set session(t5) {
    !t5 || (this._connected = t5.connected, this.accounts = t5.accounts, this.chainId = t5.chainId, this.bridge = t5.bridge, this.key = t5.key, this.clientId = t5.clientId, this.clientMeta = t5.clientMeta, this.peerId = t5.peerId, this.peerMeta = t5.peerMeta, this.handshakeId = t5.handshakeId, this.handshakeTopic = t5.handshakeTopic);
  }
  on(t5, r5) {
    let o4 = { event: t5, callback: r5 };
    this._eventManager.subscribe(o4);
  }
  off(t5) {
    this._eventManager.unsubscribe(t5);
  }
  async createInstantRequest(t5) {
    this._key = await this._generateKey();
    let r5 = this._formatRequest({ method: "wc_instantRequest", params: [{ peerId: this.clientId, peerMeta: this.clientMeta, request: this._formatRequest(t5) }] });
    this.handshakeId = r5.id, this.handshakeTopic = pr(), this._eventManager.trigger({ event: "display_uri", params: [this.uri] }), this.on("modal_closed", () => {
      throw new Error(In);
    });
    let o4 = () => {
      this.killSession();
    };
    try {
      let i4 = await this._sendCallRequest(r5);
      return i4 && o4(), i4;
    } catch (i4) {
      throw o4(), i4;
    }
  }
  async connect(t5) {
    if (!this._qrcodeModal)
      throw new Error(ta);
    return this.connected ? { chainId: this.chainId, accounts: this.accounts } : (await this.createSession(t5), new Promise(async (r5, o4) => {
      this.on("modal_closed", () => o4(new Error(In))), this.on("connect", (i4, p5) => {
        if (i4)
          return o4(i4);
        r5(p5.params[0]);
      });
    }));
  }
  async createSession(t5) {
    if (this._connected)
      throw new Error(vr);
    if (this.pending)
      return;
    this._key = await this._generateKey();
    let r5 = this._formatRequest({ method: "wc_sessionRequest", params: [{ peerId: this.clientId, peerMeta: this.clientMeta, chainId: t5 && t5.chainId ? t5.chainId : null }] });
    this.handshakeId = r5.id, this.handshakeTopic = pr(), this._sendSessionRequest(r5, "Session update rejected", { topic: this.handshakeTopic }), this._eventManager.trigger({ event: "display_uri", params: [this.uri] });
  }
  approveSession(t5) {
    if (this._connected)
      throw new Error(vr);
    this.chainId = t5.chainId, this.accounts = t5.accounts, this.networkId = t5.networkId || 0, this.rpcUrl = t5.rpcUrl || "";
    let r5 = { approved: true, chainId: this.chainId, networkId: this.networkId, accounts: this.accounts, rpcUrl: this.rpcUrl, peerId: this.clientId, peerMeta: this.clientMeta }, o4 = { id: this.handshakeId, jsonrpc: "2.0", result: r5 };
    this._sendResponse(o4), this._connected = true, this._setStorageSession(), this._eventManager.trigger({ event: "connect", params: [{ peerId: this.peerId, peerMeta: this.peerMeta, chainId: this.chainId, accounts: this.accounts }] });
  }
  rejectSession(t5) {
    if (this._connected)
      throw new Error(vr);
    let r5 = t5 && t5.message ? t5.message : $s, o4 = this._formatResponse({ id: this.handshakeId, error: { message: r5 } });
    this._sendResponse(o4), this._connected = false, this._eventManager.trigger({ event: "disconnect", params: [{ message: r5 }] }), this._removeStorageSession();
  }
  updateSession(t5) {
    if (!this._connected)
      throw new Error(fe);
    this.chainId = t5.chainId, this.accounts = t5.accounts, this.networkId = t5.networkId || 0, this.rpcUrl = t5.rpcUrl || "";
    let r5 = { approved: true, chainId: this.chainId, networkId: this.networkId, accounts: this.accounts, rpcUrl: this.rpcUrl }, o4 = this._formatRequest({ method: "wc_sessionUpdate", params: [r5] });
    this._sendSessionRequest(o4, "Session update rejected"), this._eventManager.trigger({ event: "session_update", params: [{ chainId: this.chainId, accounts: this.accounts }] }), this._manageStorageSession();
  }
  async killSession(t5) {
    let r5 = t5 ? t5.message : "Session Disconnected", o4 = { approved: false, chainId: null, networkId: null, accounts: null }, i4 = this._formatRequest({ method: "wc_sessionUpdate", params: [o4] });
    await this._sendRequest(i4), this._handleSessionDisconnect(r5);
  }
  async sendTransaction(t5) {
    if (!this._connected)
      throw new Error(fe);
    let r5 = mr(t5), o4 = this._formatRequest({ method: "eth_sendTransaction", params: [r5] });
    return await this._sendCallRequest(o4);
  }
  async signTransaction(t5) {
    if (!this._connected)
      throw new Error(fe);
    let r5 = mr(t5), o4 = this._formatRequest({ method: "eth_signTransaction", params: [r5] });
    return await this._sendCallRequest(o4);
  }
  async signMessage(t5) {
    if (!this._connected)
      throw new Error(fe);
    let r5 = this._formatRequest({ method: "eth_sign", params: t5 });
    return await this._sendCallRequest(r5);
  }
  async signPersonalMessage(t5) {
    if (!this._connected)
      throw new Error(fe);
    t5 = Mn(t5);
    let r5 = this._formatRequest({ method: "personal_sign", params: t5 });
    return await this._sendCallRequest(r5);
  }
  async signTypedData(t5) {
    if (!this._connected)
      throw new Error(fe);
    let r5 = this._formatRequest({ method: "eth_signTypedData", params: t5 });
    return await this._sendCallRequest(r5);
  }
  async updateChain(t5) {
    if (!this._connected)
      throw new Error("Session currently disconnected");
    let r5 = this._formatRequest({ method: "wallet_updateChain", params: [t5] });
    return await this._sendCallRequest(r5);
  }
  unsafeSend(t5, r5) {
    return this._sendRequest(t5, r5), this._eventManager.trigger({ event: "call_request_sent", params: [{ request: t5, options: r5 }] }), new Promise((o4, i4) => {
      this._subscribeToResponse(t5.id, (p5, m5) => {
        if (p5) {
          i4(p5);
          return;
        }
        if (!m5)
          throw new Error(js);
        o4(m5);
      });
    });
  }
  async sendCustomRequest(t5, r5) {
    if (!this._connected)
      throw new Error(fe);
    switch (t5.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return ir(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        t5.params && (t5.params[0] = mr(t5.params[0]));
        break;
      case "personal_sign":
        t5.params && (t5.params = Mn(t5.params));
        break;
      default:
        break;
    }
    let o4 = this._formatRequest(t5);
    return await this._sendCallRequest(o4, r5);
  }
  approveRequest(t5) {
    if (me(t5)) {
      let r5 = this._formatResponse(t5);
      this._sendResponse(r5);
    } else
      throw new Error(Ys);
  }
  rejectRequest(t5) {
    if (Me(t5)) {
      let r5 = this._formatResponse(t5);
      this._sendResponse(r5);
    } else
      throw new Error(Js);
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(t5, r5) {
    let o4 = this._formatRequest(t5), i4 = await this._encrypt(o4), p5 = typeof (r5 == null ? void 0 : r5.topic) < "u" ? r5.topic : this.peerId, m5 = JSON.stringify(i4), M4 = typeof (r5 == null ? void 0 : r5.forcePushNotification) < "u" ? !r5.forcePushNotification : ws(o4);
    this._transport.send(m5, p5, M4);
  }
  async _sendResponse(t5) {
    let r5 = await this._encrypt(t5), o4 = this.peerId, i4 = JSON.stringify(r5), p5 = true;
    this._transport.send(i4, o4, p5);
  }
  async _sendSessionRequest(t5, r5, o4) {
    this._sendRequest(t5, o4), this._subscribeToSessionResponse(t5.id, r5);
  }
  _sendCallRequest(t5, r5) {
    return this._sendRequest(t5, r5), this._eventManager.trigger({ event: "call_request_sent", params: [{ request: t5, options: r5 }] }), this._subscribeToCallResponse(t5.id);
  }
  _formatRequest(t5) {
    if (typeof t5.method > "u")
      throw new Error(zs);
    return { id: typeof t5.id > "u" ? ps() : t5.id, jsonrpc: "2.0", method: t5.method, params: typeof t5.params > "u" ? [] : t5.params };
  }
  _formatResponse(t5) {
    if (typeof t5.id > "u")
      throw new Error(Qs);
    let r5 = { id: t5.id, jsonrpc: "2.0" };
    if (Me(t5)) {
      let o4 = xs(t5.error);
      return Object.assign(Object.assign(Object.assign({}, r5), t5), { error: o4 });
    } else if (me(t5))
      return Object.assign(Object.assign({}, r5), t5);
    throw new Error(Tn);
  }
  _handleSessionDisconnect(t5) {
    let r5 = t5 || "Session Disconnected";
    this._connected || (this._qrcodeModal && this._qrcodeModal.close(), Qe(fn)), this._connected && (this._connected = false), this._handshakeId && (this._handshakeId = 0), this._handshakeTopic && (this._handshakeTopic = ""), this._peerId && (this._peerId = ""), this._eventManager.trigger({ event: "disconnect", params: [{ message: r5 }] }), this._removeStorageSession(), this.transportClose();
  }
  _handleSessionResponse(t5, r5) {
    r5 ? r5.approved ? (this._connected ? (r5.chainId && (this.chainId = r5.chainId), r5.accounts && (this.accounts = r5.accounts), this._eventManager.trigger({ event: "session_update", params: [{ chainId: this.chainId, accounts: this.accounts }] })) : (this._connected = true, r5.chainId && (this.chainId = r5.chainId), r5.accounts && (this.accounts = r5.accounts), r5.peerId && !this.peerId && (this.peerId = r5.peerId), r5.peerMeta && !this.peerMeta && (this.peerMeta = r5.peerMeta), this._eventManager.trigger({ event: "connect", params: [{ peerId: this.peerId, peerMeta: this.peerMeta, chainId: this.chainId, accounts: this.accounts }] })), this._manageStorageSession()) : this._handleSessionDisconnect(t5) : this._handleSessionDisconnect(t5);
  }
  async _handleIncomingMessages(t5) {
    if (![this.clientId, this.handshakeTopic].includes(t5.topic))
      return;
    let o4;
    try {
      o4 = JSON.parse(t5.payload);
    } catch (p5) {
      return;
    }
    let i4 = await this._decrypt(o4);
    i4 && this._eventManager.trigger(i4);
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(t5, r5) {
    this.on(`response:${t5}`, r5);
  }
  _subscribeToSessionResponse(t5, r5) {
    this._subscribeToResponse(t5, (o4, i4) => {
      if (o4) {
        this._handleSessionResponse(o4.message);
        return;
      }
      me(i4) ? this._handleSessionResponse(r5, i4.result) : i4.error && i4.error.message ? this._handleSessionResponse(i4.error.message) : this._handleSessionResponse(r5);
    });
  }
  _subscribeToCallResponse(t5) {
    return new Promise((r5, o4) => {
      this._subscribeToResponse(t5, (i4, p5) => {
        if (i4) {
          o4(i4);
          return;
        }
        me(p5) ? r5(p5.result) : p5.error && p5.error.message ? o4(new Error(p5.error.message)) : o4(new Error(Tn));
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      this._qrcodeModal && this._qrcodeModal.open(this.uri, () => {
        this._eventManager.trigger({ event: "modal_closed", params: [] });
      }, this._qrcodeModalOptions);
    }), this.on("connect", () => {
      this._qrcodeModal && this._qrcodeModal.close();
    }), this.on("call_request_sent", (t5, r5) => {
      let { request: o4 } = r5.params[0];
      if (xo() && this._signingMethods.includes(o4.method)) {
        let i4 = ze(fn);
        i4 && (globalThis.location.href = i4.href);
      }
    }), this.on("wc_sessionRequest", (t5, r5) => {
      t5 && this._eventManager.trigger({ event: "error", params: [{ code: "SESSION_REQUEST_ERROR", message: t5.toString() }] }), this.handshakeId = r5.id, this.peerId = r5.params[0].peerId, this.peerMeta = r5.params[0].peerMeta;
      let o4 = Object.assign(Object.assign({}, r5), { method: "session_request" });
      this._eventManager.trigger(o4);
    }), this.on("wc_sessionUpdate", (t5, r5) => {
      t5 && this._handleSessionResponse(t5.message), this._handleSessionResponse("Session disconnected", r5.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (t5) => this._handleIncomingMessages(t5)), this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] })), this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] })), this._transport.on("error", () => this._eventManager.trigger({ event: "transport_error", params: ["Websocket connection failed"] })), this._transport.open();
  }
  _formatUri() {
    let t5 = this.protocol, r5 = this.handshakeTopic, o4 = this.version, i4 = encodeURIComponent(this.bridge), p5 = this.key;
    return `${t5}:${r5}@${o4}?bridge=${i4}&key=${p5}`;
  }
  _parseUri(t5) {
    let r5 = Fs(t5);
    if (r5.protocol === this.protocol) {
      if (!r5.handshakeTopic)
        throw Error("Invalid or missing handshakeTopic parameter value");
      let o4 = r5.handshakeTopic;
      if (!r5.bridge)
        throw Error("Invalid or missing bridge url parameter value");
      let i4 = decodeURIComponent(r5.bridge);
      if (!r5.key)
        throw Error("Invalid or missing key parameter value");
      let p5 = r5.key;
      return { handshakeTopic: o4, bridge: i4, key: p5 };
    } else
      throw new Error(Xs);
  }
  async _generateKey() {
    return this._cryptoLib ? await this._cryptoLib.generateKey() : null;
  }
  async _encrypt(t5) {
    let r5 = this._key;
    return this._cryptoLib && r5 ? await this._cryptoLib.encrypt(t5, r5) : null;
  }
  async _decrypt(t5) {
    let r5 = this._key;
    return this._cryptoLib && r5 ? await this._cryptoLib.decrypt(t5, r5) : null;
  }
  _getStorageSession() {
    let t5 = null;
    return this._sessionStorage && (t5 = this._sessionStorage.getSession()), t5;
  }
  _setStorageSession() {
    this._sessionStorage && this._sessionStorage.setSession(this.session);
  }
  _removeStorageSession() {
    this._sessionStorage && this._sessionStorage.removeSession();
  }
  _manageStorageSession() {
    this._connected ? this._setStorageSession() : this._removeStorageSession();
  }
  _registerPushServer(t5) {
    if (!t5.url || typeof t5.url != "string")
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    if (!t5.type || typeof t5.type != "string")
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    if (!t5.token || typeof t5.token != "string")
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    let r5 = { bridge: this.bridge, topic: this.clientId, type: t5.type, token: t5.token, peerName: "", language: t5.language || "" };
    this.on("connect", async (o4, i4) => {
      if (o4)
        throw o4;
      if (t5.peerMeta) {
        let p5 = i4.params[0].peerMeta.name;
        r5.peerName = p5;
      }
      try {
        if (!(await (await fetch(`${t5.url}/new`, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: JSON.stringify(r5) })).json()).success)
          throw Error("Failed to register in Push Server");
      } catch (p5) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var oa = Rn;
var Yn = {};
ve(Yn, { decrypt: () => Bf, encrypt: () => Of, generateKey: () => da, verifyHmac: () => pa });
y4();
w5();
x4();
var Ht = {};
ve(Ht, { AES_BROWSER_ALGO: () => Yt, AES_LENGTH: () => Ae, AES_NODE_ALGO: () => hf, DECRYPT_OP: () => Fn, ENCRYPT_OP: () => Wn, ERROR_BAD_MAC: () => Mf, HEX_ENC: () => Cf, HMAC_BROWSER: () => ge, HMAC_BROWSER_ALGO: () => Un, HMAC_LENGTH: () => xr, HMAC_NODE_ALGO: () => df, IV_LENGTH: () => wf, KEY_LENGTH: () => yf, LENGTH_0: () => ff, LENGTH_1: () => Bn, LENGTH_1024: () => lf, LENGTH_128: () => cf, LENGTH_16: () => Dn, LENGTH_256: () => wr, LENGTH_32: () => yr, LENGTH_512: () => Pn, LENGTH_64: () => uf, MAC_LENGTH: () => xf, PREFIX_LENGTH: () => vf, RIPEMD160_NODE_ALGO: () => gf, SHA256_BROWSER_ALGO: () => Hn, SHA256_NODE_ALGO: () => pf, SHA512_BROWSER_ALGO: () => Nn, SHA512_NODE_ALGO: () => mf, SIGN_OP: () => qn, UTF8_ENC: () => _f, VERIFY_OP: () => Vn, aesCbcDecrypt: () => jn, aesCbcEncrypt: () => $n, assert: () => ha, hmacSha256Sign: () => _r, hmacSha256Verify: () => kf, hmacSha512Sign: () => Tf, hmacSha512Verify: () => If, isConstantTime: () => Le, pkcs7: () => la, randomBytes: () => On, ripemd160: () => Rf, sha256: () => Af, sha512: () => Lf });
y4();
w5();
x4();
y4();
w5();
x4();
var sa = Zt(Ce());
function On(e5) {
  return sa.getBrowerCrypto().getRandomValues(new Uint8Array(e5));
}
y4();
w5();
x4();
y4();
w5();
x4();
var ue = Zt(Ce());
y4();
w5();
x4();
y4();
w5();
x4();
y4();
w5();
x4();
var ff = 0;
var Bn = 1;
var Dn = 16;
var yr = 32;
var uf = 64;
var cf = 128;
var wr = 256;
var Pn = 512;
var lf = 1024;
var Ae = 256;
var xr = 256;
var Yt = "AES-CBC";
var Un = `SHA-${Ae}`;
var ge = "HMAC";
var Hn = "SHA-256";
var Nn = "SHA-512";
var hf = `aes-${Ae}-cbc`;
var df = `sha${xr}`;
var pf = "sha256";
var mf = "sha512";
var gf = "ripemd160";
var vf = 1;
var yf = 32;
var wf = 16;
var xf = 32;
y4();
w5();
x4();
var Cf = "hex";
var _f = "utf8";
y4();
w5();
x4();
var Mf = "Bad MAC";
y4();
w5();
x4();
var Wn = "encrypt";
var Fn = "decrypt";
var qn = "sign";
var Vn = "verify";
function Sf(e5) {
  return e5 === Yt ? { length: Ae, name: Yt } : { hash: { name: Un }, name: ge };
}
function bf(e5) {
  return e5 === Yt ? [Wn, Fn] : [qn, Vn];
}
async function Cr(e5, t5 = Yt) {
  return ue.getSubtleCrypto().importKey("raw", e5, Sf(t5), true, bf(t5));
}
async function aa(e5, t5, r5) {
  let o4 = ue.getSubtleCrypto(), i4 = await Cr(t5, Yt), p5 = await o4.encrypt({ iv: e5, name: Yt }, i4, r5);
  return new Uint8Array(p5);
}
async function fa(e5, t5, r5) {
  let o4 = ue.getSubtleCrypto(), i4 = await Cr(t5, Yt), p5 = await o4.decrypt({ iv: e5, name: Yt }, i4, r5);
  return new Uint8Array(p5);
}
async function Zn(e5, t5) {
  let r5 = ue.getSubtleCrypto(), o4 = await Cr(e5, ge), i4 = await r5.sign({ length: xr, name: ge }, o4, t5);
  return new Uint8Array(i4);
}
async function Gn(e5, t5) {
  let r5 = ue.getSubtleCrypto(), o4 = await Cr(e5, ge), i4 = await r5.sign({ length: 512, name: ge }, o4, t5);
  return new Uint8Array(i4);
}
async function ua(e5) {
  let r5 = await ue.getSubtleCrypto().digest({ name: Hn }, e5);
  return new Uint8Array(r5);
}
async function ca(e5) {
  let r5 = await ue.getSubtleCrypto().digest({ name: Nn }, e5);
  return new Uint8Array(r5);
}
function $n(e5, t5, r5) {
  return aa(e5, t5, r5);
}
function jn(e5, t5, r5) {
  return fa(e5, t5, r5);
}
y4();
w5();
x4();
var G3 = {};
ve(G3, { assert: () => ha, isConstantTime: () => Le, pkcs7: () => la });
y4();
w5();
x4();
var Bt = {};
y4();
w5();
x4();
O3(Bt, Zt(Ce()));
O3(G3, Bt);
y4();
w5();
x4();
var Ef = [[16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [9, 9, 9, 9, 9, 9, 9, 9, 9], [8, 8, 8, 8, 8, 8, 8, 8], [7, 7, 7, 7, 7, 7, 7], [6, 6, 6, 6, 6, 6], [5, 5, 5, 5, 5], [4, 4, 4, 4], [3, 3, 3], [2, 2], [1]];
var la = { pad(e5) {
  let t5 = Ef[e5.byteLength % 16 || 0], r5 = new Uint8Array(e5.byteLength + t5.length);
  return r5.set(e5), r5.set(t5, e5.byteLength), r5;
}, unpad(e5) {
  return e5.subarray(0, e5.byteLength - e5[e5.byteLength - 1]);
} };
y4();
w5();
x4();
y4();
w5();
x4();
function ha(e5, t5) {
  if (!e5)
    throw new Error(t5 || "Assertion failed");
}
function Le(e5, t5) {
  if (e5.length !== t5.length)
    return false;
  let r5 = 0;
  for (let o4 = 0; o4 < e5.length; o4++)
    r5 |= e5[o4] ^ t5[o4];
  return r5 === 0;
}
async function _r(e5, t5) {
  return await Zn(e5, t5);
}
async function kf(e5, t5, r5) {
  let o4 = await Zn(e5, t5);
  return Le(o4, r5);
}
async function Tf(e5, t5) {
  return await Gn(e5, t5);
}
async function If(e5, t5, r5) {
  let o4 = await Gn(e5, t5);
  return Le(o4, r5);
}
y4();
w5();
x4();
async function Af(e5) {
  return await ua(e5);
}
async function Lf(e5) {
  return await ca(e5);
}
async function Rf(e5) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}
O3(Ht, G3);
async function da(e5) {
  let t5 = (e5 || 256) / 8, r5 = On(t5);
  return $o(xe(r5));
}
async function pa(e5, t5) {
  let r5 = ne(e5.data), o4 = ne(e5.iv), i4 = ne(e5.hmac), p5 = re2(i4, false), m5 = mn(r5, o4), M4 = await _r(t5, m5), b3 = re2(M4, false);
  return Ft(p5) === Ft(b3);
}
async function Of(e5, t5, r5) {
  let o4 = ee2(nr(t5)), i4 = r5 || await da(128), p5 = ee2(nr(i4)), m5 = re2(p5, false), M4 = JSON.stringify(e5), b3 = pn(M4), R3 = await $n(p5, o4, b3), L4 = re2(R3, false), T5 = mn(R3, p5), D4 = await _r(o4, T5), P4 = re2(D4, false);
  return { data: L4, hmac: P4, iv: m5 };
}
async function Bf(e5, t5) {
  let r5 = ee2(nr(t5));
  if (!r5)
    throw new Error("Missing key: required for decryption");
  if (!await pa(e5, r5))
    return null;
  let i4 = ne(e5.data), p5 = ne(e5.iv), m5 = await jn(p5, r5, i4), M4 = dn(m5), b3;
  try {
    b3 = JSON.parse(M4);
  } catch (R3) {
    return null;
  }
  return b3;
}
var Jn = class extends oa {
  constructor(t5, r5) {
    super({ cryptoLib: Yn, connectorOpts: t5, pushServerOpts: r5 });
  }
};
var ma = Jn;
y4();
w5();
x4();
var zn = { ["connection_failed"]: "Unable to establish connection to Worldcoin app. Please verify internet connection and try again.", ["verification_rejected"]: "User rejected verification request in Worldcoin app.", ["already_signed"]: "User has previously signed and submitted proof for this action.", ["invalid_action_id"]: "The provided action ID is not valid. Make sure it's a valid string or it's properly hashed and encoded if using raw (advanced). Review the docs for details.", ["invalid_signal"]: "The provided signal is not valid. Make sure it's a valid string or it's properly hashed and encoded if using raw (advanced). Review the docs for details.", ["unexpected_response"]: "Received an unexpected response from WLD app. Please try again.", ["generic_error"]: "An unhandled exception ocurred. Please try again." };
var ga = { ["connection_failed"]: { title: "Unable to connect", caption: "We could not establish a connection to the Worldcoin app. Please verify your internet connection and try again." }, ["verification_rejected"]: { title: "Verification rejected!", caption: "You rejected the verification request in the Worldcoin app. If this was a mistake, please try again.", noRetry: true }, ["already_signed"]: { title: "Previously verified!", caption: "You have already verified your identity for this action once. You cannot verify the same action twice.", noRetry: true }, ["invalid_action_id"]: { caption: "The verification request was invalid. Please contact the app before trying again.", noRetry: true }, ["invalid_signal"]: { caption: "The verification request was invalid. Please contact the app before trying again.", noRetry: true } };
var Gt;
try {
  Gt = new ma({ bridge: "https://bridge.walletconnect.org" });
} catch (e5) {
  console.error("Unable to create WalletConnect connector");
}
var Ut = kea([path(["logic", "verificationLogic"]), actions({ initConnection: true, setConnectorUri: (e5) => ({ connectorUri: e5 }), setConnectionStartTime: (e5) => ({ startTime: e5 }), handleConnectionEstablished: true, setVerificationState: (e5) => ({ verificationState: e5 }), setError: (e5) => ({ errorCode: e5 }), setSuccess: (e5) => ({ result: e5 }), terminate: true, tryAgain: true, reset: true }), connect({ actions: [Et, ["finishWidgetLoading", "setQrCodeContent", "disableModal"]] }), reducers({ connectorUri: [null, { setConnectorUri: (e5, { connectorUri: t5 }) => t5 }], connectionStartTime: [null, { setConnectionStartTime: (e5, { startTime: t5 }) => t5 }], verificationState: [0, { setVerificationState: (e5, { verificationState: t5 }) => t5, setError: () => 3, setSuccess: () => 2, reset: (e5) => e5 === 2 ? 2 : 0 }], errorResult: [null, { setError: (e5, { errorCode: t5 }) => t5, reset: () => null }], successResult: [null, { setSuccess: (e5, { result: t5 }) => t5, reset: () => null }] }), listeners2(({ actions: e5, values: t5 }) => ({ initConnection: async () => {
  if (!t5.connectorUri) {
    if (Gt.connected)
      try {
        await Gt.killSession();
      } catch (r5) {
        console.error("Error while killing session", r5);
      }
    try {
      await Gt.createSession(), e5.setConnectorUri(Gt.uri), e5.setConnectionStartTime(performance.now());
    } catch (r5) {
      console.error("Error while creating WalletConnect session", r5);
    }
    Gt.on("connect", async (r5) => {
      r5 ? (e5.setError("connection_failed"), console.error(`Failed to establish connection to WLD app: ${r5}`)) : e5.handleConnectionEstablished();
    }), fo();
  }
}, setConnectorUri: ({ connectorUri: r5 }) => {
  if (!r5)
    return;
  let o4 = en(Gt);
  e5.setQrCodeContent(o4), e5.finishWidgetLoading();
}, handleConnectionEstablished: async () => {
  e5.setVerificationState(1), uo(t5.connectionStartTime ? (performance.now() - t5.connectionStartTime) / 1e3 : void 0);
  try {
    let r5 = await Gt.sendCustomRequest(Qr(Et.props));
    Kr(r5) ? e5.setSuccess(r5) : (e5.setError("unexpected_response"), console.error(zn["unexpected_response"], r5));
  } catch (r5) {
    let o4 = "generic_error", i4 = r5.message;
    i4 && Object.values(qe).includes(i4) && (o4 = i4), e5.setError(o4);
  }
  try {
    try {
      await Gt.killSession();
    } catch (r5) {
      console.error("Error while killing session", r5);
    }
  } catch (r5) {
  }
}, setSuccess: async () => {
  co();
}, setError: ({ errorCode: r5 }) => {
  lo(r5);
}, terminate: async (r5, o4) => {
  var i4, p5;
  o4(), t5.verificationState !== 0 && (t5.verificationState === 2 && t5.successResult && Et.props.on_success(t5.successResult), (t5.verificationState !== 2 || !t5.successResult) && ((p5 = (i4 = Et.props).on_error) == null || p5.call(i4, { code: t5.errorResult || "generic_error", detail: t5.internalError })), e5.reset());
}, reset: async () => {
  if (Gt.connected)
    try {
      await Gt.killSession();
    } catch (r5) {
      console.error("Error while killing session", r5);
    }
}, tryAgain: () => {
  e5.reset(), e5.initConnection();
} })), selectors({ endUserError: [(e5) => [e5.errorResult], (e5) => {
  var t5;
  return (t5 = ga[e5 || "generic_error"]) != null ? t5 : null;
}], internalError: [(e5) => [e5.errorResult], (e5) => {
  var t5;
  return (t5 = zn[e5 || "generic_error"]) != null ? t5 : "";
}] }), events(({ actions: e5 }) => ({ afterMount: [e5.initConnection] }))]);
var $f = E5("button", { display: "grid", gridGap: "8px", alignItems: "center", boxSizing: "border-box", height: 56, width: "100%", maxWidth: 350, minWidth: 250, padding: "0 16px", textAlign: "left", color: "$captchaColor", background: `
    linear-gradient(to right, $background, $background) padding-box,
    linear-gradient(to right, $captchaGradientFrom, $captchaGradientTo) border-box
  `, border: "2px solid transparent", borderRadius: "$lg", cursor: "pointer", "&:disabled": { cursor: "not-allowed", opacity: "0.6" }, variants: { grid: { false: { gridTemplateColumns: "auto" }, true: { gridTemplateColumns: "auto 1fr auto" } } } });
var jf = E5("div", { boxSizing: "border-box", width: 20, height: 20, fontSize: "20px", border: "1px solid", borderRadius: "50%", variants: { checked: { true: { border: 0 } } } });
var Yf = E5("div", { fontSize: "14px", fontWeight: "600", lineHeight: "18px", fontFamily: "Sora" });
var Jf = E5("div", { "--gradient-from": "$colors$gradientFrom", "--gradient-to": "$colors$gradientTo", display: "grid", alignItems: "center", justifyContent: "center", background: "none", border: "none", padding: "0", cursor: "pointer" });
var zf = E5("h1", { fontSize: "14px", textAlign: "center", fontFamily: "Rubik", color: "$color" });
var Qf = ee({ "0%": { transform: "rotate(0deg)" }, "100%": { transform: "rotate(360deg)" } });
var Kf = E5("div", { width: "24px", height: "24px", margin: "0px auto", animation: `${Qf} 2000ms linear infinite` });
function ya() {
  let { isWidgetEnabled: e5, isWidgetInitialized: t5, widgetLoading: r5 } = useValues(Et), { activateModal: o4, setModalView: i4 } = useActions(Et), { verificationState: p5 } = useValues(Ut), m5 = (0, import_react7.useMemo)(() => p5 === 2, [p5]);
  return f4.createElement(Qi, null, f4.createElement($f, { onClick: () => {
    i4(0), o4();
  }, "data-testid": "world-id-box", disabled: m5 || r5 || !t5 || !e5, grid: t5 && !r5 }, t5 && !r5 && f4.createElement(f4.Fragment, null, f4.createElement(jf, { checked: m5 }, m5 && f4.createElement($e, null)), f4.createElement(Yf, null, "I'm a unique person"), f4.createElement(Jf, { onClick: (b3) => {
    !e5 || r5 || (b3.stopPropagation(), i4(1), o4());
  } }, f4.createElement(Yi, null))), !t5 && !r5 && f4.createElement(zf, null, "Widget is unavailable"), r5 && f4.createElement(Kf, null, f4.createElement(Ge, { style: { width: "100%", height: "100%" } }))));
}
y4();
w5();
x4();
y4();
w5();
x4();
var tu = E5("div", { width: "100%", height: "100vh", position: "fixed", zIndex: 2147483647, top: "0", bottom: "0", left: "0", right: "0", backgroundColor: "rgba(0,0,0,0.6)", color: "#FFFFFF", display: "grid", alignContent: "center", justifyContent: "center", transition: "opacity, visibility ease-out 1s", opacity: "0", pointerEvents: "none", visibility: "hidden", "@smDown": { alignContent: "end", justifyContent: "stretch" }, variants: { open: { true: { opacity: "1", pointerEvents: "all", visibility: "visible" }, false: { opacity: "0", pointerEvents: "none", visibility: "hidden" } } } });
function wa(e5) {
  let t5 = (0, import_react8.useCallback)((r5) => {
    r5.currentTarget === r5.target && e5.onClose();
  }, [e5.onClose]);
  return f4.createElement(tu, { open: e5.open, onClick: t5, "data-testid": "overlay" }, e5.children);
}
y4();
w5();
x4();
y4();
w5();
x4();
var Xt = E5("div", { boxSizing: "border-box", padding: "24px", color: "$color", background: "$background", borderRadius: "$lg", boxShadow: "0px 8px 64px rgba(0, 0, 0, 0.08)", "@smDown": { borderRadius: "$xl $xl 0 0" } });
y4();
w5();
x4();
var ce = E5("div", { display: "grid", columnGap: "12px", marginTop: -16, padding: "16px 0", variants: { extended: { true: { gridTemplateColumns: "auto 1fr auto auto", "@smDown": { gridTemplateColumns: "auto 1fr auto" } }, false: { gridTemplateColumns: "1fr auto", "@smDown": { gridTemplateColumns: "1fr auto" } } } } });
y4();
w5();
x4();
var eu = E5("div", { flexGrow: 1, display: "grid", alignItems: "center", fontSize: "24px", variants: { centered: { true: { justifyContent: "center" } } } });
function le(e5) {
  return f4.createElement(eu, Vt({}, e5), f4.createElement(Ji, null));
}
y4();
w5();
x4();
var nu = ee({ "0%": { transform: "rotate(0deg)" }, "100%": { transform: "rotate(360deg)" } });
var iu = E5("svg", { display: "block", fontSize: "32px", transform: "translateZ(0)", animation: `${nu} 2s infinite linear` });
function xa(e5) {
  return f4.createElement(iu, Vt({ width: "1em", height: "1em", viewBox: "0 0 36 36", fill: "none" }, e5), f4.createElement("circle", { cx: "17.9997", cy: "17.9997", r: "15.9997", stroke: "var(--colors-loaderBg)", strokeWidth: "4" }), f4.createElement("path", { d: "M33.9981 17.9997C33.9981 15.3386 33.3343 12.7194 32.0668 10.3795C30.7994 8.03951 28.9683 6.05265 26.7394 4.59879C24.5104 3.14492 21.9541 2.26998 19.3017 2.05319C16.6494 1.83639 13.9849 2.28459 11.5495 3.3572C9.11404 4.42981 6.9846 6.09295 5.35399 8.19602C3.72338 10.2991 2.64309 12.7757 2.21094 15.4015", stroke: "url(#paint0_linear_7782_165735)", strokeWidth: "4", strokeLinecap: "round", strokeLinejoin: "round" }), f4.createElement("defs", null, f4.createElement("linearGradient", { id: "paint0_linear_7782_165735", x1: "36.9975", y1: "17.9997", x2: "1.99805", y2: "17.9997", gradientUnits: "userSpaceOnUse" }, f4.createElement("stop", { stopColor: "var(--colors-loaderFg)" }), f4.createElement("stop", { offset: "1", stopColor: "var(--colors-loaderFg)", stopOpacity: "0" }))));
}
y4();
w5();
x4();
var It = E5("div", { margin: 0, variants: { variant: { h1: { fontFamily: '"Sora"', fontSize: "24px", fontWeight: "600", lineHeight: "28.8px", "@smDown": { fontSize: "26px", lineHeight: "31.2px" } }, h2: { fontFamily: '"Sora"', fontSize: "20px", fontWeight: "600", lineHeight: "24px" }, h3: { fontFamily: '"Sora"', fontSize: "18px", fontWeight: "600", lineHeight: "24px" }, p1: { fontFamily: '"Rubik"', fontSize: "14px", fontWeight: "400", lineHeight: "18px" } }, color: { gradient: { background: "linear-gradient(to right, $buttonGradientFrom, $buttonGradientTo)", backgroundClip: "text", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" } }, centered: { true: { textAlign: "center" } } } });
y4();
w5();
x4();
var qt = E5("button", { display: "inline-grid", gridAutoFlow: "column", alignItems: "center", padding: 0, border: 0, outline: 0, background: "transparent", borderRadius: "$lg", cursor: "pointer", variants: { variant: { default: {}, link: { fontFamily: '"Rubik"', fontSize: "18px", fontWeight: 500 } }, size: { sm: { height: 24, padding: "0 10px", fontSize: "11px", borderRadius: "$sm" }, lg: { height: 54, fontFamily: '"Sora"', fontSize: "14px", fontWeight: 600, lineHeight: "18px", textTransform: "uppercase" }, xl: { height: 60 } }, color: { default: {}, neutral: {}, primary: {}, gradient: {} }, fullWidth: { true: { width: "100%" } } }, defaultVariants: { variant: "default", color: "default" }, compoundVariants: [{ variant: "default", color: "default", css: { color: "$color", background: "$buttonDefaultBg" } }, { variant: "default", color: "neutral", css: { color: "$buttonNeutralColor", background: "$buttonNeutralBg" } }, { variant: "default", color: "primary", css: { color: "$buttonPrimaryColor", background: "$buttonPrimaryBg" } }, { variant: "default", color: "gradient", css: { color: "$color", position: "relative", minHeight: 44, padding: "0 24px", fontFamily: "Sora", fontSize: "16px", fontWeight: 600, lineHeight: "18px", textTransform: "uppercase", background: `
          linear-gradient(to right, $background, $background) padding-box,
          linear-gradient(to right, $buttonGradientFrom, $buttonGradientTo) border-box
        `, border: "2px solid transparent", "@smDown": { transition: "box-shadow 200ms", boxShadow: "0px 10px 20px rgba(255, 104, 72, 0.2);", "&:hover": { boxShadow: "0px 10px 20px rgba(255, 104, 72, 0.4);" } } } }, { variant: "link", color: "default", css: { "@smDown": { fontWeight: 500, color: "$grey5" } } }, { variant: "link", color: "primary", css: { "@smDown": { fontWeight: 500, color: "$primary" } } }] });
var su = E5(Xt, { display: "flex", flexFlow: "column", alignItems: "center", width: 400 });
var au = E5(xa, { margin: "64px" });
var fu = E5(It, { marginBottom: 8 });
var uu = E5(It, { maxWidth: 240, marginBottom: 24 });
function Ca() {
  let { terminate: e5 } = useActions(Ut);
  return f4.createElement(su, null, f4.createElement(ce, null, f4.createElement(le, { centered: true })), f4.createElement(au, null), f4.createElement(fu, { variant: "h3", centered: true }, "Confirm Identity"), f4.createElement(uu, { variant: "p1", centered: true }, "Please confirm your identity inside your Worldcoin mobile app."), f4.createElement(qt, { size: "lg", fullWidth: true, onClick: e5 }, "Cancel"));
}
y4();
w5();
x4();
y4();
w5();
x4();
function _a() {
  let [e5, t5] = (0, import_react10.useState)("desktop");
  return (0, import_react10.useEffect)(() => {
    let r5 = globalThis.matchMedia("(max-width: 768px)");
    function o4(i4) {
      i4.matches ? t5("mobile") : t5("desktop");
    }
    return o4(r5), r5.addEventListener("change", o4), () => {
      r5.removeEventListener("change", o4);
    };
  }, []), { media: e5 };
}
y4();
w5();
x4();
var mu = globalThis.btoa((0, import_server.renderToString)(f4.createElement(Ge, null)));
var Sa = new import_qr_code_styling_new.default({ width: 183, height: 183, type: "svg", image: `data:image/svg+xml;base64,${mu}`, cornersSquareOptions: { type: "extra-rounded" }, cornersDotOptions: { type: "dot" }, dotsOptions: { color: "var(--colors-qrcode)", type: "extra-rounded" }, backgroundOptions: { color: "transparent" }, imageOptions: { margin: 4, hideBackgroundDots: true } });
var gu = E5("div", { position: "relative", zIndex: "0", boxSizing: "border-box", display: "flex", width: "216px", height: "216px", alignItems: "center", justifyContent: "center", border: "1px solid $qrcodeBorder", borderRadius: "2px", "&::before, &::after": { content: "", display: "block", position: "absolute", zIndex: " -1", background: "$background" }, "&::before": { top: "24px", bottom: "24px", left: "-1px", right: "-1px" }, "&::after": { top: "-1px", bottom: "-1px", left: "24px", right: "24px" }, "& > *": { position: "relative" } });
var ba = ({ data: e5 }) => {
  let t5 = (0, import_react11.useRef)(null);
  return (0, import_react11.useEffect)(() => {
    !t5.current || t5 != null && t5.current && Sa.append(t5.current);
  }, []), (0, import_react11.useEffect)(() => {
    Sa.update({ data: e5 });
  }, [e5]), f4.createElement(gu, { ref: t5 });
};
y4();
w5();
x4();
var Qn = E5("button", { display: "grid", placeContent: "center", width: 40, height: 40, margin: 0, padding: 0, fontSize: "24px", color: "$color", background: "transparent", border: "1px solid transparent", borderRadius: "$sm", cursor: "pointer", "@smDown": { borderRadius: "50%" }, variants: { bordered: { true: { borderColor: "#BBBEC74D" } } } });
y4();
w5();
x4();
var vu = re("a", { backgroundColor: "$devButtonBg", color: "$color", borderRadius: "$lg", padding: "12px", display: "grid", gridTemplateColumns: "auto 1fr", justifyContent: "start", alignContent: "start", columnGap: "10px", rowGap: "2px", border: "1px solid", borderColor: "$devButtonBorder", cursor: "pointer", textDecoration: "none" });
var yu = re("h3", { color: "$color", fontFamily: '"Rubik"', fontWeight: "500", fontSize: "12px", margin: "0", textAlign: "left", userSelect: "none", alignSelf: "end" });
var wu = re("div", { color: "$grey5", margin: "0", fontFamily: '"Rubik"', fontSize: "10px", textAlign: "left", userSelect: "none", alignSelf: "start" });
var xu = re("div", { gridRow: "span 2" });
var Re = (e5) => f4.createElement(vu, { href: e5.href, target: "_blank", rel: "noopener" }, f4.createElement(xu, null, e5.icon), f4.createElement(yu, null, e5.heading), f4.createElement(wu, null, e5.description));
y4();
w5();
x4();
var Cu = re("div", { display: "grid", alignItems: "center", rowGap: "24px", color: "$color", padding: "12px 12px 0" });
var Kn = re(It);
var _u = re("a", { color: "$primary" });
var Ea = () => f4.createElement(Cu, null, f4.createElement(Kn, { variant: "p1" }, "World ID, in a completely privacy-preserving way, verifies a human is performing an action only once."), f4.createElement(Kn, { variant: "p1" }, "World ID enables proving human uniqueness without intruding on privacy, you don't have to tell us or anyone else anything about yourself."), f4.createElement(Kn, { variant: "p1" }, "World ID uses a device called the Orb. The Orb solves the verification problem through biometrics. Learn more about World ID, Worldcoin and the Orb", " ", f4.createElement(_u, { href: "https://worldcoin.org/blog", target: "_blank", rel: "noopener" }, "here"), "."));
var Eu = E5("div", { transitionProperty: "max-height", transition: "1000ms", variants: { centered: { true: { maxHeight: "320px" }, false: { maxHeight: "562px" } } } });
var ku = E5(Xt, { width: 500, "@smDown": { width: "auto" } });
var Tu = E5("div", { display: "grid", gridTemplate: `
    "text code" auto
    "copy code" 1fr / 1fr auto
  `, alignItems: "end", justifyItems: "start", "@smDown": { justifyItems: "center", gridTemplate: `
      "code"
      "text"
      "cta"
      "copy"
    ` } });
var Iu = E5("div", { gridArea: "text", "@smDown": { maxWidth: 340 } });
var Au = E5(It, { maxWidth: 236, marginTop: 16, "@smDown": { maxWidth: "none", marginTop: 24, textAlign: "center" } });
var Lu = E5(It, { maxWidth: 212, marginTop: 12, "@smDown": { maxWidth: "none", margin: "16px 0 32px", textAlign: "center" } });
var Ru = E5("div", { gridArea: "copy" });
var Ou = E5("div", { gridArea: "code" });
var Bu = E5("div", { gridArea: "cta", display: "none", "@smDown": { display: "block", width: "100%" } });
var Du = E5(Xt, { width: 500, marginTop: "8px", transitionProperty: "opacity, transform, visibility", transition: "1000ms", variants: { hidden: { true: { opacity: "0", visibility: "hidden", transform: "translateY(100%)" } } }, "@smDown": { display: "none" } });
var Pu = E5("div", { width: "100%", display: "grid", gridTemplateColumns: "1fr auto", gridTemplateRows: "auto auto", gridGap: "16px 0", alignItems: "center" });
var Uu = E5("div", { gridColumn: "1 / 3" });
var Hu = E5("div", { width: "100%", display: "grid", rowGap: "12px" });
var Nu = E5("div", { display: "grid", gridTemplateColumns: "1fr auto", alignItems: "center" });
var Wu = E5("div", { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px" });
var Fu = E5("div", { background: "$primaryA10", border: "1px solid", borderColor: "$primaryA50", borderRadius: "$md", padding: "4px 10px", display: "grid", gridTemplateColumns: "auto 1fr", columnGap: "8px", alignItems: "center", color: "$primary" });
function Aa() {
  let { qrCodeContent: e5, isDevMode: t5, modalView: r5 } = useValues(Et), { disableModal: o4, setModalView: i4 } = useActions(Et), { terminate: p5 } = useActions(Ut), { media: m5 } = _a(), [M4, b3] = (0, import_react12.useState)(false), R3 = (0, import_react12.useCallback)(() => {
    b3((D4) => !D4);
  }, []), L4 = (0, import_react12.useMemo)(() => r5 === 0, [r5]);
  function T5(D4) {
    let [P4, kt] = (0, import_react12.useState)(false);
    (0, import_react12.useEffect)(() => {
      if (P4) {
        let U3 = setTimeout(() => kt(false), 2e3);
        return () => clearTimeout(U3);
      }
      return () => null;
    }, [P4]);
    let Nt = (0, import_react12.useCallback)(() => {
      !D4.data || navigator.clipboard.writeText(D4.data).then(() => {
        kt(true);
      });
    }, [D4.data]);
    return f4.createElement(qt, { variant: D4.variant, size: D4.size, color: D4.color, onClick: Nt }, P4 ? f4.createElement(f4.Fragment, null, f4.createElement($e, { style: { marginRight: 4 } }), " Copied!") : "Copy QR code");
  }
  return f4.createElement(Eu, { centered: !L4 }, f4.createElement(ku, null, f4.createElement(ce, { extended: !L4 }, !L4 && f4.createElement(Qn, { onClick: () => i4(0), bordered: true }, f4.createElement(Xi, null)), f4.createElement(le, null), f4.createElement(Qn, { bordered: true, onClick: () => {
    p5(), o4();
  } }, f4.createElement(Ki, null))), f4.createElement(Tu, null, L4 && f4.createElement(f4.Fragment, null, f4.createElement(Iu, null, f4.createElement(Au, { variant: "h1", color: "gradient" }, "Prove you haven\u2019t done this before with World ID"), f4.createElement(Lu, { variant: "p1" }, "Scan or copy this QR code with your phone\u2019s camera or Worldcoin mobile app.")), f4.createElement(Ru, null, m5 === "desktop" && f4.createElement(T5, { color: "neutral", size: "sm", data: e5 }), m5 !== "desktop" && !M4 && f4.createElement(qt, { variant: "link", color: "default", size: "xl", onClick: R3 }, "Show QR code instead"), m5 !== "desktop" && M4 && f4.createElement(T5, { variant: "link", color: "primary", size: "xl", data: e5 })), f4.createElement(Ou, null, m5 !== "desktop" && !M4 ? f4.createElement(zi, null) : e5 ? f4.createElement(ba, { data: e5 }) : null), f4.createElement(Bu, null, f4.createElement(qt, { color: "gradient", size: "xl", fullWidth: true }, "Get Worldcoin app"))), !L4 && f4.createElement(Ea, null))), f4.createElement(Du, { hidden: !L4 }, m5 === "desktop" && !t5 && f4.createElement(Pu, null, f4.createElement(Uu, null, f4.createElement(It, { variant: "h2" }, "Don\u2019t have the Worldcoin app yet?")), f4.createElement(It, { variant: "p1" }, "Proving unique-humanness through biometrics, without intruding privacy."), f4.createElement(qt, { color: "gradient" }, "Install now")), m5 === "desktop" && t5 && f4.createElement(Hu, null, f4.createElement(Nu, null, f4.createElement(It, { variant: "h2" }, "Running in dev mode"), f4.createElement(Fu, null, f4.createElement(ro, null), f4.createElement(It, { variant: "p1" }, "Dev Mode"))), f4.createElement(Wu, null, f4.createElement(Re, { href: "https://simulator.worldcoin.org", icon: f4.createElement(no, null), heading: "Simulator", description: f4.createElement("span", { style: { margin: 0 } }, "Open the simulator to ", f4.createElement("strong", null, "scan the QR code"), " and mock a verification.") }), f4.createElement(Re, { href: "https://worldcoin.org/verify", icon: f4.createElement(io, null), heading: "Worldcoin app", description: "Open or install Worldcoin app to test in production" }), f4.createElement(Re, { href: "https://id.worldcoin.org/test", icon: f4.createElement(oo, null), heading: "Testing", description: "Docs on how to test with the Staging network" }), f4.createElement(Re, { href: "https://id.worldcoin.org/docs/js", icon: f4.createElement(so, null), heading: "Docs", description: "Docs for this widget" })))));
}
y4();
w5();
x4();
y4();
w5();
x4();
var Sr = E5("div", { display: "grid", placeContent: "center", width: 72, height: 72, fontSize: "24px", borderRadius: "50%", variants: { variant: { default: {}, contained: {} }, color: { default: { color: "$circleDefaultColor", backgroundColor: "$circleDefaultBg" }, primary: { color: "$circlePrimaryColor", backgroundColor: "$circlePrimaryBg" } } }, defaultVariants: { color: "default" } });
var qu = E5(Xt, { display: "flex", flexFlow: "column", alignItems: "center", width: 400 });
var Vu = E5(Sr, { margin: "60px 0 48px 0" });
var Zu = E5(It, { marginBottom: 8 });
var Gu = E5(It, { maxWidth: 290, marginBottom: 24 });
function Ra() {
  let { terminate: e5 } = useActions(Ut), { disableModal: t5 } = useActions(Et);
  return f4.createElement(qu, null, f4.createElement(ce, null, f4.createElement(le, { centered: true })), f4.createElement(Vu, { color: "primary" }, f4.createElement(eo, null)), f4.createElement(Zu, { variant: "h3", centered: true }, "Identity Confirmed!"), f4.createElement(Gu, { variant: "p1", centered: true }, "Yay! Your identity has been successfully confirmed. You can start using your WorldID."), f4.createElement(qt, { color: "primary", size: "lg", fullWidth: true, onClick: () => {
    e5(), t5();
  } }, "Continue"));
}
y4();
w5();
x4();
var Yu = E5(Xt, { display: "flex", flexFlow: "column", alignItems: "center", width: 400 });
var Ju = E5(Sr, { margin: "60px 0 48px 0" });
var zu = E5(It, { marginBottom: 8 });
var Qu = E5(It, { maxWidth: 290, marginBottom: 24 });
function Oa() {
  let { endUserError: e5 } = useValues(Ut), { tryAgain: t5, terminate: r5 } = useActions(Ut);
  return f4.createElement(Yu, null, f4.createElement(ce, null, f4.createElement(le, { centered: true })), f4.createElement(Ju, { color: e5 != null && e5.noRetry ? "default" : "primary" }, f4.createElement(to, null)), f4.createElement(zu, { variant: "h3", centered: true }, (e5 == null ? void 0 : e5.title) || "Something went wrong"), f4.createElement(Qu, { variant: "p1", centered: true }, (e5 == null ? void 0 : e5.caption) || "Sorry, there was a problem with your request, please try again."), e5 != null && e5.noRetry ? f4.createElement(qt, { size: "lg", fullWidth: true, onClick: r5 }, "Close") : f4.createElement(qt, { color: "primary", size: "lg", fullWidth: true, onClick: t5 }, "Try again"));
}
function Pa() {
  let { isModalVisible: e5 } = useValues(Et), { verificationState: t5 } = useValues(Ut), { terminate: r5 } = useActions(Ut), { disableModal: o4 } = useActions(Et);
  return f4.createElement(wa, { open: e5, onClose: () => {
    r5(), o4();
  } }, t5 === 3 && f4.createElement(Oa, null), t5 === 2 && f4.createElement(Ra, null), t5 === 1 && f4.createElement(Ca, null), t5 === 0 && f4.createElement(Aa, null));
}
var tc = E5("div", { width: "100%", maxWidth: "300px" });
function ec(e5) {
  let t5 = _i(Vt({}, e5), { action_id: e5.actionId, enable_telemetry: e5.enableTelemetry, app_name: e5.appName, signal_description: e5.signalDescription, advanced_use_raw_signal: e5.advancedUseRawSignal, advanced_use_raw_action_id: e5.advancedUseRawActionId, disable_remote_fonts: e5.disableRemoteFonts, on_success: e5.onSuccess, on_error: e5.onError, on_init_success: e5.onInitSuccess, on_init_error: e5.onInitError });
  Et(t5);
  let { widgetLoading: r5 } = useValues(Et);
  return (0, import_react15.useEffect)(() => {
    e5.disableRemoteFonts || Gi();
  }, [e5.disableRemoteFonts]), f4.createElement(tc, { className: e5.theme === "dark" ? ji : $i }, f4.createElement(ya, null), !r5 && f4.createElement(Pa, null));
}

// src/App/App.tsx
var import_classnames4 = __toESM(require_classnames(), 1);
var import_react19 = __toESM(require_react(), 1);

// src/App/Modal/Modal.tsx
init_virtual_process_polyfill();
init_buffer();

// src/common/Icon/index.tsx
init_virtual_process_polyfill();
init_buffer();
var import_classnames2 = __toESM(require_classnames(), 1);
var import_react16 = __toESM(require_react(), 1);

// src/common/Icon/icon.module.css
var _default = {};

// src/common/Icon/index.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Icon = import_react16.default.memo(function Icon2({
  src,
  className,
  useMask = true
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
    className: (0, import_classnames2.default)(
      _default.icon,
      "icon pointer-events-none flex",
      {
        "bg-current": useMask,
        "no-mask": !useMask
      },
      className
    ),
    style: { "--image": `url(${src})` }
  });
});

// src/App/Modal/Modal.tsx
var import_classnames3 = __toESM(require_classnames(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Modal = import_react17.default.memo(function Modal2(props2) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
    className: (0, import_classnames3.default)(
      "fixed top-0 left-0 grid min-h-screen w-screen content-center justify-items-center",
      "bg-000000/70 p-4 transition-visibility/opacity",
      {
        "pointer-events-none invisible select-none opacity-0": props2.visibility === "off"
      }
    ),
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
      className: (0, import_classnames3.default)(
        "grid min-h-[192px] w-full max-w-sm content-center justify-items-center gap-y-3",
        "rounded-20 bg-18161b p-10 text-ffffff"
      ),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon, {
          src: props2.icon,
          className: "h-8 w-8",
          useMask: false
        }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
          className: "mt-3 text-20",
          children: props2.status
        }),
        props2.description && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
          className: "text-center",
          children: props2.description
        }),
        props2.buttonText && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
          onClick: props2.onClick,
          className: "mt-5 w-full bg-df57bc",
          children: props2.buttonText
        })
      ]
    })
  });
});

// src/App/Modal/modal-variants.tsx
init_virtual_process_polyfill();
init_buffer();

// src/static/fail.svg
var fail_default = "data:image/svg+xml;base64,PHN2ZwogIHdpZHRoPSIzMiIKICBoZWlnaHQ9IjMyIgogIHZpZXdCb3g9IjAgMCAzMiAzMiIKICBmaWxsPSJub25lIgogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKPgogIDxjaXJjbGUKICAgIGN4PSIxNiIKICAgIGN5PSIxNiIKICAgIHI9IjE2IgogICAgZmlsbD0iI0RGNTdCQyIKICAvPgogIDxwYXRoCiAgICBkPSJNMTMuODkwNiAxMy44ODk5TDE4Ljc4MSAxOC43ODAzTTE4Ljc4MSAxMy44ODk5TDEzLjg5MDYgMTguNzgwMyIKICAgIHN0cm9rZT0id2hpdGUiCiAgICBzdHJva2UtbGluZWNhcD0icm91bmQiCiAgICBzdHJva2UtbGluZWpvaW49InJvdW5kIgogIC8+Cjwvc3ZnPgo=";

// src/static/spinner.svg
var spinner_default = "data:image/svg+xml;base64,PHN2ZwogIHdpZHRoPSIzMiIKICBoZWlnaHQ9IjMyIgogIHZpZXdCb3g9IjAgMCAzMiAzMiIKICBmaWxsPSJub25lIgogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKPgogIDxwYXRoCiAgICBkPSJNMTUuOTk5OCAyOC42NjY2TDE1Ljk5OTggMjcuMzMzM0wxNS45OTk4IDI4LjY2NjZaTTE1Ljk5OTggNC42NjY1OUMxNS4yNjM1IDQuNjY2NTkgMTQuNjY2NSA0LjA2OTYzIDE0LjY2NjUgMy4zMzMyNUMxNC42NjY1IDIuNTk2ODcgMTUuMjYzNSAxLjk5OTkyIDE1Ljk5OTggMS45OTk5MkwxNS45OTk4IDQuNjY2NTlaTTEuOTk5ODQgMTUuOTk5OUMxLjk5OTg0IDE1LjI2MzUgMi41OTY3OSAxNC42NjY2IDMuMzMzMTcgMTQuNjY2NkM0LjA2OTU1IDE0LjY2NjYgNC42NjY1IDE1LjI2MzUgNC42NjY1IDE1Ljk5OTlMMS45OTk4NCAxNS45OTk5Wk0xNS45OTk4IDI3LjMzMzNDMjIuMjU5MSAyNy4zMzMzIDI3LjMzMzIgMjIuMjU5MSAyNy4zMzMyIDE1Ljk5OTlMMjkuOTk5OCAxNS45OTk5QzI5Ljk5OTggMjMuNzMxOSAyMy43MzE4IDI5Ljk5OTkgMTUuOTk5OCAyOS45OTk5TDE1Ljk5OTggMjcuMzMzM1pNMjcuMzMzMiAxNS45OTk5QzI3LjMzMzIgOS43NDA2OSAyMi4yNTkxIDQuNjY2NTggMTUuOTk5OCA0LjY2NjU5TDE1Ljk5OTggMS45OTk5MkMyMy43MzE4IDEuOTk5OTIgMjkuOTk5OCA4LjI2NzkzIDI5Ljk5OTggMTUuOTk5OUwyNy4zMzMyIDE1Ljk5OTlaTTE1Ljk5OTggMjkuOTk5OUMxNC4xNjEzIDI5Ljk5OTkgMTIuMzQwOCAyOS42Mzc4IDEwLjY0MjMgMjguOTM0MkwxMS42NjI4IDI2LjQ3MDZDMTMuMDM3OCAyNy4wNDAxIDE0LjUxMTUgMjcuMzMzMyAxNS45OTk4IDI3LjMzMzNMMTUuOTk5OCAyOS45OTk5Wk0xMC42NDIzIDI4LjkzNDJDOC45NDM3MSAyOC4yMzA3IDcuNDAwMzYgMjcuMTk5NCA2LjEwMDM0IDI1Ljg5OTRMNy45ODU5NiAyNC4wMTM4QzkuMDM4MzYgMjUuMDY2MiAxMC4yODc3IDI1LjkwMSAxMS42NjI4IDI2LjQ3MDZMMTAuNjQyMyAyOC45MzQyWk02LjEwMDM0IDI1Ljg5OTRDNC44MDAzMiAyNC41OTk0IDMuNzY5MDkgMjMuMDU2IDMuMDY1NTIgMjEuMzU3NUw1LjUyOTIgMjAuMzM3QzYuMDk4NzUgMjEuNzEyIDYuOTMzNTYgMjIuOTYxNCA3Ljk4NTk2IDI0LjAxMzhMNi4xMDAzNCAyNS44OTk0Wk0zLjA2NTUyIDIxLjM1NzVDMi4zNjE5NiAxOS42NTg5IDEuOTk5ODQgMTcuODM4NCAxLjk5OTg0IDE1Ljk5OTlMNC42NjY1IDE1Ljk5OTlDNC42NjY1IDE3LjQ4ODIgNC45NTk2NSAxOC45NjIgNS41MjkyIDIwLjMzN0wzLjA2NTUyIDIxLjM1NzVaIgogICAgZmlsbD0iI0RGNTdCQyIKICAvPgoKICA8YW5pbWF0ZVRyYW5zZm9ybQogICAgYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIgogICAgYXR0cmlidXRlVHlwZT0iWE1MIgogICAgdHlwZT0icm90YXRlIgogICAgZnJvbT0iMCIKICAgIHRvPSIzNjAiCiAgICBkdXI9IjFzIgogICAgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiCiAgLz4KPC9zdmc+Cg==";

// src/static/wrong-chain.svg
var wrong_chain_default = "data:image/svg+xml;base64,PHN2ZwogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICBmaWxsPSJub25lIgogIHZpZXdCb3g9IjAgMCAzMiAzNCIKPgogIDxjaXJjbGUKICAgIGN4PSIxNiIKICAgIGN5PSIxNiIKICAgIHI9IjE2IgogICAgZmlsbD0iI0RGNTdCQyIKICAvPgogIDxwYXRoCiAgICBmaWxsPSIjZmZmIgogICAgZD0iTTIxLjE0NCAxMi41MDJjLS4zNjYtLjIxNC0uODM2LS4yMTQtMS4yNTQgMGwtMi45MjQgMS43NjItMS45ODQgMS4xMjItMi44NzIgMS43NjJjLS4zNjYuMjE0LS44MzYuMjE0LTEuMjU0IDBMOC42MTEgMTUuNzZhMS4zMDggMS4zMDggMCAwIDEtLjYyNy0xLjEyMnYtMi42N2MwLS40MjguMjEtLjg1NS42MjctMS4xMjJsMi4yNDUtMS4zMzZjLjM2Ni0uMjEzLjgzNi0uMjEzIDEuMjU0IDBsMi4yNDUgMS4zOWMuMzY2LjIxMy42MjcuNjQuNjI3IDEuMTJ2MS43NjNsMS45ODQtMS4xNzV2LTEuODE2YzAtLjQyNy0uMjA5LS44NTQtLjYyNy0xLjEyMWwtNC4xNzctMi41MWMtLjM2Ni0uMjE0LS44MzYtLjIxNC0xLjI1MyAwTDYuNjI3IDkuNzIzYy0uNDE4LjIxNC0uNjI3LjY0MS0uNjI3IDEuMDY4djUuMDIxYzAgLjQyNy4yMDkuODU1LjYyNyAxLjEyMmw0LjIzIDIuNTFjLjM2NS4yMTQuODM1LjIxNCAxLjI1MyAwbDIuODcyLTEuNzEgMS45ODQtMS4xNzQgMi44NzItMS43MWMuMzY2LS4yMTMuODM2LS4yMTMgMS4yNTMgMGwyLjI0NiAxLjMzNmMuMzY1LjIxNC42MjYuNjQuNjI2IDEuMTIydjIuNjdjMCAuNDI4LS4yMDguODU1LS42MjYgMS4xMjJsLTIuMTkzIDEuMzM1Yy0uMzY2LjIxNC0uODM2LjIxNC0xLjI1NCAwTDE3LjY0NSAyMS4xYTEuMzA4IDEuMzA4IDAgMCAxLS42MjctMS4xMjJWMTguMjdsLTEuOTg0IDEuMTc1djEuNzYzYzAgLjQyNy4yMDkuODU0LjYyNyAxLjEyMWw0LjIzIDIuNTFjLjM2NS4yMTQuODM1LjIxNCAxLjI1MyAwbDQuMjMtMi41MWMuMzY1LS4yMTMuNjI2LS42NC42MjYtMS4xMjF2LTUuMDc0YzAtLjQyOC0uMjA5LS44NTUtLjYyNy0xLjEyMmwtNC4yMy0yLjUxWiIKICAvPgogIDxjaXJjbGUKICAgIGN4PSIyNyIKICAgIGN5PSIyOSIKICAgIHI9IjUiCiAgICBmaWxsPSIjZmZmIgogIC8+CiAgPHBhdGgKICAgIGZpbGw9IiNERjU3QkMiCiAgICBkPSJNMjguNDU5IDI4LjA2M2ExLjU2MiAxLjU2MiAwIDEgMC0zLjEyNSAwIC4zMTMuMzEzIDAgMSAwIC42MjUgMCAuOTM3LjkzNyAwIDEgMSAuOTM3LjkzNy4zMTMuMzEzIDAgMCAwLS4zMTMuMzEzdi42MjVhLjMxMy4zMTMgMCAxIDAgLjYyNiAwdi0uMzQ0YTEuNTYzIDEuNTYzIDAgMCAwIDEuMjUtMS41MzJaTTI2Ljg5NiAzMS41YS4zMTIuMzEyIDAgMSAwIDAtLjYyNS4zMTIuMzEyIDAgMCAwIDAgLjYyNVoiCiAgLz4KPC9zdmc+Cg==";

// src/App/Modal/modal-variants.tsx
var import_react18 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var modalVariants = {
  confirmation: {
    icon: spinner_default,
    status: "Waiting for confirmation",
    description: "We\u2019ve established a connection to your wallet, now please confirm the signature request."
  },
  fail: {
    icon: fail_default,
    status: "Something went wrong!",
    description: "Sorry, looks like something went wrong there. Please try again or come back later.",
    button: "OK"
  },
  pending: {
    icon: spinner_default,
    status: "Please wait..."
  },
  wrongChainId: {
    icon: wrong_chain_default,
    status: "Please switch to Mumbai chain",
    description: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_react18.Fragment, {
      children: [
        "Looks like you connected a wallet on a different chain. Please switch to",
        " ",
        "Polygon Mumbai Testnet. ",
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("br", {}),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("a", {
          className: "text-df57bc transition-opacity hover:opacity-75",
          href: "https://docs.polygon.technology/docs/develop/network-details/network/",
          target: "_blank",
          rel: "noreferrer",
          children: "How to connect?"
        })
      ]
    }),
    button: "OK"
  }
};

// src/App/App.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var App = import_react19.default.memo(function App2() {
  const [screen, setScreen] = import_react19.default.useState(0 /* Initial */);
  const [worldIDProof, setWorldIDProof] = import_react19.default.useState(null);
  const [walletAddress, setWalletAddress] = import_react19.default.useState("");
  const [modalContent, setModalContent] = import_react19.default.useState(
    modalVariants.confirmation
  );
  const modal = useToggle();
  const connectWallet = import_react19.default.useCallback(async () => {
    try {
      provider.enable().then(() => {
        if (provider.chainId !== 80001) {
          modal.toggle("on");
          setModalContent(modalVariants.wrongChainId);
          provider.disconnect().catch(console.error.bind(console));
        } else {
          setWalletAddress(provider.accounts[0]);
          setScreen(1 /* Confirm */);
        }
      }).catch((error2) => console.error(error2));
    } catch (err) {
      console.error(err);
    }
  }, [provider]);
  const logout = () => {
    provider.disconnect().catch(console.error.bind(console));
    window.location.reload();
  };
  const modalButtonAction = import_react19.default.useCallback(() => {
    modal.toggle("off");
  }, [modal]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
    className: "relative grid h-full w-full content-between bg-0f0b16 px-6 pt-5 xs:px-16 xs:pb-4.5 xs:pt-9",
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
        className: (0, import_classnames4.default)(
          "relative grid gap-y-10 2xl:gap-y-64",
          { "xs:gap-y-25": screen !== 2 /* Congratulations */ },
          { "xs:gap-y-48": screen === 2 /* Congratulations */ }
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("header", {
            className: "flex items-center py-2.5",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
                className: "text-20 font-bold text-ffffff xs:text-32",
                style: { flexGrow: 1 }
              }),
              walletAddress && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
                className: "font-bold text-ffffff",
                children: [
                  midEllipsis(walletAddress, 12),
                  " ",
                  /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("b", {
                    children: [
                      "-",
                      " ",
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
                        className: "cursor-pointer font-bold",
                        onClick: logout,
                        children: "Logout"
                      })
                    ]
                  })
                ]
              })
            ]
          }),
          screen !== 2 /* Congratulations */ && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
            className: "grid justify-items-center gap-y-3 justify-self-center text-ffffff xs:gap-y-4",
            children: [
              screen === 0 /* Initial */ && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
                className: "grid justify-items-center gap-y-3 ",
                children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
                  onClick: connectWallet,
                  type: "button",
                  className: "bg-df57bc hover:bg-df57bc/70",
                  children: "Connect Wallet to Claim"
                })
              }),
              screen === 1 /* Confirm */ && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
                className: "grid w-full max-w-[254px] gap-y-8",
                children: walletAddress && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
                  children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ec, {
                    signal: walletAddress,
                    actionId: ACTION_ID,
                    onSuccess: (proof) => setWorldIDProof(proof),
                    debug: true
                  })
                })
              }),
              worldIDProof && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
                children: "okok"
              })
            ]
          })
        ]
      }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Modal, {
        status: modalContent.status,
        description: modalContent.description,
        buttonText: modalContent.button,
        icon: modalContent.icon,
        visibility: modal.state,
        onClick: modalButtonAction
      })
    ]
  });
});

// src/main.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var container = document.getElementById("root");
if (!container)
  throw new ReferenceError(`Unable to found root element`);
var root = ReactDOMClient.createRoot(container);
root.render(
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react20.default.StrictMode, {
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, {})
  })
);
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=main.js.map
